#!/usr/bin/env node
/* global __dirname */

const fs = require("node:fs");
const path = require("node:path");

// Resolve paths relative to repo root
const repoRoot = path.resolve(__dirname, "../../");
const auditsDir = path.join(repoRoot, "docs/audits");
const outputFile = path.join(auditsDir, "RESULTS_INDEX.md");

/**
 * Recursively find all directories matching a pattern
 */
function findAuditDirectories(baseDir, pattern) {
  const results = [];

  if (!fs.existsSync(baseDir)) {
    return results;
  }

  function walk(dir, depth = 0) {
    if (!fs.existsSync(dir)) return;

    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      if (!entry.isDirectory()) continue;

      const fullPath = path.join(dir, entry.name);

      // Check if this matches the pattern (audit-*)
      if (entry.name.match(pattern)) {
        results.push(fullPath);
      }

      // Continue walking subdirectories
      walk(fullPath, depth + 1);
    }
  }

  walk(baseDir);
  return results;
}

/**
 * Extract date from audit directory name (audit-YYYY-MM-DD or audit-YYYY-MM-DD-HH-MM)
 */
function extractDate(dirName) {
  const match = dirName.match(/audit-(\d{4}-\d{2}-\d{2})/);
  return match ? match[1] : null;
}

/**
 * Collect all audit results
 */
function collectAuditResults() {
  const results = [];

  // Single-session audits: docs/audits/single-session/*/audit-*/
  const singleSessionBase = path.join(auditsDir, "single-session");
  if (fs.existsSync(singleSessionBase)) {
    const categories = fs
      .readdirSync(singleSessionBase, { withFileTypes: true })
      .filter((entry) => entry.isDirectory());

    for (const category of categories) {
      const categoryPath = path.join(singleSessionBase, category.name);
      const auditDirs = findAuditDirectories(categoryPath, /^audit-/);

      for (const auditDir of auditDirs) {
        const dirName = path.basename(auditDir);
        const date = extractDate(dirName);
        const relativePath = path.relative(auditsDir, auditDir);

        if (date) {
          results.push({
            date,
            type: "Single-Session",
            category: category.name,
            path: relativePath,
          });
        }
      }
    }
  }

  // Comprehensive audits: docs/audits/comprehensive/audit-*/
  const comprehensiveBase = path.join(auditsDir, "comprehensive");
  const comprehensiveAudits = findAuditDirectories(comprehensiveBase, /^audit-/);

  for (const auditDir of comprehensiveAudits) {
    const dirName = path.basename(auditDir);
    const date = extractDate(dirName);
    const relativePath = path.relative(auditsDir, auditDir);

    if (date) {
      results.push({
        date,
        type: "Comprehensive",
        category: "N/A",
        path: relativePath,
      });
    }
  }

  // Multi-AI audits: docs/audits/multi-ai/*/ (skip templates/)
  const multiAiBase = path.join(auditsDir, "multi-ai");
  if (fs.existsSync(multiAiBase)) {
    const entries = fs
      .readdirSync(multiAiBase, { withFileTypes: true })
      .filter((entry) => entry.isDirectory() && entry.name !== "templates");

    for (const entry of entries) {
      const entryPath = path.join(multiAiBase, entry.name);
      const dirName = entry.name;
      const date = extractDate(dirName);
      const relativePath = path.relative(auditsDir, entryPath);

      if (date) {
        results.push({
          date,
          type: "Multi-AI",
          category: "N/A",
          path: relativePath,
        });
      }
    }
  }

  // Sort by date descending
  results.sort((a, b) => b.date.localeCompare(a.date));

  return results;
}

/**
 * Generate markdown content
 */
function generateMarkdown(results) {
  const now = new Date().toISOString().split("T")[0];

  let content = `<!-- AUTO-GENERATED -- do not edit manually -->

# Audit Results Index

<!-- prettier-ignore-start -->
**Document Version:** 1.0
**Last Updated:** ${now}
**Status:** ACTIVE
**Auto-Generated:** This file is auto-generated by \`scripts/audit/generate-results-index.js\`
<!-- prettier-ignore-end -->

This index provides a comprehensive overview of all audit results in this repository.

## Results Table

`;

  if (results.length === 0) {
    content += "_No audit results found._\n";
  } else {
    // Generate table
    content += "| Date | Type | Category | Path |\n";
    content += "|------|------|----------|------|\n";

    for (const result of results) {
      const link = `[${result.path}](./${result.path}/)`;
      content += `| ${result.date} | ${result.type} | ${result.category} | ${link} |\n`;
    }
  }

  content += `\n---\n\n_Last generated: ${new Date().toISOString()}_\n`;

  return content;
}

/**
 * Main execution
 */
function main() {
  console.log("Generating audit results index...");
  console.log(`Repository root: ${repoRoot}`);
  console.log(`Audits directory: ${auditsDir}`);

  // Ensure audits directory exists
  if (!fs.existsSync(auditsDir)) {
    console.warn(`Warning: Audits directory does not exist: ${auditsDir}`);
    fs.mkdirSync(auditsDir, { recursive: true });
  }

  // Collect results
  const results = collectAuditResults();
  console.log(`Found ${results.length} audit results`);

  // Generate markdown
  const markdown = generateMarkdown(results);

  // Write output file (with symlink guard)
  try {
    const stat = fs.lstatSync(outputFile);
    if (stat.isSymbolicLink()) {
      console.error(`Error: ${outputFile} is a symlink — refusing to write`);
      process.exit(2);
    }
  } catch {
    // File doesn't exist yet — safe to write
  }
  fs.writeFileSync(outputFile, markdown, "utf8");
  console.log(`✓ Generated: ${outputFile}`);
  console.log(`  - Single-Session: ${results.filter((r) => r.type === "Single-Session").length}`);
  console.log(`  - Comprehensive: ${results.filter((r) => r.type === "Comprehensive").length}`);
  console.log(`  - Multi-AI: ${results.filter((r) => r.type === "Multi-AI").length}`);

  process.exit(0);
}

// Run the script
main();
