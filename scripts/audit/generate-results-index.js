#!/usr/bin/env node
/* global __dirname */

const fs = require("node:fs");
const path = require("node:path");

// Resolve paths relative to repo root
const repoRoot = path.resolve(__dirname, "../../");
const auditsDir = path.join(repoRoot, "docs/audits");
const outputFile = path.join(auditsDir, "RESULTS_INDEX.md");

/**
 * Recursively find all directories matching a pattern
 */
function findAuditDirectories(baseDir, pattern) {
  const results = [];

  if (!fs.existsSync(baseDir)) {
    return results;
  }

  function walk(dir, depth = 0) {
    if (!fs.existsSync(dir)) return;

    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      if (entry.isSymbolicLink()) continue;
      if (!entry.isDirectory()) continue;

      const fullPath = path.join(dir, entry.name);

      // Check if this matches the pattern (audit-*)
      if (entry.name.match(pattern)) {
        results.push(fullPath);
      }

      // Continue walking subdirectories
      walk(fullPath, depth + 1);
    }
  }

  walk(baseDir);
  return results;
}

/**
 * Extract date from audit directory name (audit-YYYY-MM-DD or audit-YYYY-MM-DD-HH-MM)
 */
function extractDate(dirName) {
  const match = dirName.match(/audit-(\d{4}-\d{2}-\d{2})/);
  return match ? match[1] : null;
}

/**
 * Collect single-session audit results from category subdirectories.
 */
// Map directory names to canonical category names
const DIR_TO_CANONICAL = {
  code: "code-quality",
  security: "security",
  performance: "performance",
  refactoring: "refactoring",
  documentation: "documentation",
  process: "process",
  "engineering-productivity": "engineering-productivity",
  enhancements: "enhancements",
  "ai-optimization": "ai-optimization",
};

function collectSingleSessionAudits() {
  const results = [];
  const singleSessionBase = path.join(auditsDir, "single-session");
  if (!fs.existsSync(singleSessionBase)) return results;

  const categories = fs
    .readdirSync(singleSessionBase, { withFileTypes: true })
    .filter((entry) => entry.isDirectory());

  for (const category of categories) {
    const categoryPath = path.join(singleSessionBase, category.name);
    const auditDirs = findAuditDirectories(categoryPath, /^audit-/);

    for (const auditDir of auditDirs) {
      const date = extractDate(path.basename(auditDir));
      if (date) {
        results.push({
          date,
          type: "Single-Session",
          category: DIR_TO_CANONICAL[category.name] || category.name,
          path: path.relative(auditsDir, auditDir),
        });
      }
    }
  }
  return results;
}

/**
 * Collect comprehensive audit results.
 */
function collectComprehensiveAudits() {
  const results = [];
  const comprehensiveBase = path.join(auditsDir, "comprehensive");
  const auditDirs = findAuditDirectories(comprehensiveBase, /^audit-/);

  for (const auditDir of auditDirs) {
    const date = extractDate(path.basename(auditDir));
    if (date) {
      results.push({
        date,
        type: "Comprehensive",
        category: "N/A",
        path: path.relative(auditsDir, auditDir),
      });
    }
  }
  return results;
}

/**
 * Collect multi-AI audit results (skip templates/).
 */
function collectMultiAiAudits() {
  const results = [];
  const multiAiBase = path.join(auditsDir, "multi-ai");
  if (!fs.existsSync(multiAiBase)) return results;

  const entries = fs
    .readdirSync(multiAiBase, { withFileTypes: true })
    .filter((entry) => entry.isDirectory() && entry.name !== "templates");

  for (const entry of entries) {
    const date = extractDate(entry.name);
    if (date) {
      results.push({
        date,
        type: "Multi-AI",
        category: "N/A",
        path: path.relative(auditsDir, path.join(multiAiBase, entry.name)),
      });
    }
  }
  return results;
}

/**
 * Collect all audit results
 */
function collectAuditResults() {
  const results = [
    ...collectSingleSessionAudits(),
    ...collectComprehensiveAudits(),
    ...collectMultiAiAudits(),
  ];
  results.sort((a, b) => b.date.localeCompare(a.date));
  return results;
}

/**
 * Generate markdown content
 */
function generateMarkdown(results) {
  const now = new Date().toISOString().split("T")[0];

  let content = `<!-- AUTO-GENERATED -- do not edit manually -->

# Audit Results Index

<!-- prettier-ignore-start -->
**Document Version:** 1.0
**Last Updated:** ${now}
**Status:** ACTIVE
**Auto-Generated:** This file is auto-generated by \`scripts/audit/generate-results-index.js\`
<!-- prettier-ignore-end -->

This index provides a comprehensive overview of all audit results in this repository.

## Results Table

`;

  if (results.length === 0) {
    content += "_No audit results found._\n";
  } else {
    // Generate table
    content += "| Date | Type | Category | Path |\n";
    content += "|------|------|----------|------|\n";

    for (const result of results) {
      const link = `[${result.path}](./${result.path}/)`;
      content += `| ${result.date} | ${result.type} | ${result.category} | ${link} |\n`;
    }
  }

  content += `\n---\n\n_Last generated: ${new Date().toISOString()}_\n`;

  return content;
}

/**
 * Guard against symlinks on a path. Exits the process if a symlink is detected.
 * @param {string} targetPath - path to check
 * @param {string} label - human-readable label for error messages
 */
function guardSymlink(targetPath, label) {
  try {
    const stat = fs.lstatSync(targetPath);
    if (stat.isSymbolicLink()) {
      console.error(`Error: ${label} is a symlink — refusing to write`);
      process.exit(2);
    }
  } catch (err) {
    const code = err && typeof err === "object" ? err.code : null;
    if (code === "ENOENT" || code === "ENOTDIR") return;
    const msg = err instanceof Error ? err.message : String(err);
    console.error(`Error: Unable to verify ${label} is not a symlink: ${msg}`);
    process.exit(2);
  }
}

/**
 * Atomically write content to outputFile via tmp+rename.
 * Uses exclusive-create flag ("wx") on tmp to prevent TOCTOU/symlink races.
 * @param {string} content - file content to write
 */
function atomicWrite(content) {
  const outputDir = path.dirname(outputFile);

  // Verify output resolves within repo root (catches ancestor symlinks)
  try {
    const realOutputDir = fs.realpathSync(outputDir);
    const realRepoRoot = fs.realpathSync(repoRoot);
    const rel = path.relative(realRepoRoot, realOutputDir);
    if (/^\.\.(?:[\\/]|$)/.test(rel) || path.isAbsolute(rel)) {
      console.error(`Error: Output directory resolves outside repo root: ${realOutputDir}`);
      process.exit(2);
    }
  } catch {
    // outputDir may not exist yet — mkdirSync in main() handles creation
  }

  guardSymlink(outputDir, outputDir);
  guardSymlink(outputFile, outputFile);

  const tmpFile = path.join(outputDir, `.RESULTS_INDEX.md.tmp-${process.pid}-${Date.now()}`);
  try {
    // Exclusive-create the tmp file to prevent TOCTOU/symlink races
    fs.writeFileSync(tmpFile, content, { encoding: "utf8", flag: "wx" });
    try {
      fs.renameSync(tmpFile, outputFile);
    } catch {
      // Cross-platform fallback: rename may fail on Windows if destination exists
      guardSymlink(outputFile, outputFile);
      try {
        fs.rmSync(outputFile, { force: true });
      } catch {
        /* best-effort */
      }
      fs.renameSync(tmpFile, outputFile);
    }
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    console.error(`Error: Failed to write results index: ${msg}`);
    try {
      if (fs.existsSync(tmpFile)) fs.unlinkSync(tmpFile);
    } catch {
      /* cleanup best-effort */
    }
    process.exit(2);
  }
}

/**
 * Main execution
 */
function main() {
  console.log("Generating audit results index...");
  console.log(`Repository root: ${repoRoot}`);
  console.log(`Audits directory: ${auditsDir}`);

  // Ensure audits directory exists
  if (!fs.existsSync(auditsDir)) {
    console.warn(`Warning: Audits directory does not exist: ${auditsDir}`);
    fs.mkdirSync(auditsDir, { recursive: true });
  }

  // Collect results
  const results = collectAuditResults();
  console.log(`Found ${results.length} audit results`);

  // Generate markdown and write atomically
  const markdown = generateMarkdown(results);
  atomicWrite(markdown);

  console.log(`✓ Generated: ${outputFile}`);
  console.log(`  - Single-Session: ${results.filter((r) => r.type === "Single-Session").length}`);
  console.log(`  - Comprehensive: ${results.filter((r) => r.type === "Comprehensive").length}`);
  console.log(`  - Multi-AI: ${results.filter((r) => r.type === "Multi-AI").length}`);

  process.exit(0);
}

// Run the script
main();
