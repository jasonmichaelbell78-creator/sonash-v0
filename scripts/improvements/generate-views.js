#!/usr/bin/env node
/* global __dirname */
/**
 * Generate IMS Views and Final Output
 *
 * Reads: docs/improvements/raw/deduped.jsonl (or MASTER_IMPROVEMENTS.jsonl as fallback)
 * Outputs:
 *   - docs/improvements/MASTER_IMPROVEMENTS.jsonl (final canonical with ENH-XXXX IDs)
 *   - docs/improvements/INDEX.md (human-readable index)
 *   - docs/improvements/views/by-impact.md
 *   - docs/improvements/views/by-category.md
 *   - docs/improvements/views/by-status.md
 *   - docs/improvements/views/review-queue.md
 */

const fs = require("node:fs");
const path = require("node:path");

const BASE_DIR = path.join(__dirname, "../../docs/improvements");
const DEDUPED_FILE = path.join(BASE_DIR, "raw/deduped.jsonl");
const MASTER_FALLBACK = path.join(BASE_DIR, "MASTER_IMPROVEMENTS.jsonl");
// Prefer deduped output; fall back to canonical MASTER file for standalone use
const INPUT_FILE = fs.existsSync(DEDUPED_FILE) ? DEDUPED_FILE : MASTER_FALLBACK;
const MASTER_FILE = path.join(BASE_DIR, "MASTER_IMPROVEMENTS.jsonl");
const INDEX_FILE = path.join(BASE_DIR, "INDEX.md");
const VIEWS_DIR = path.join(BASE_DIR, "views");

// Symlink guard: refuse to write through symlinks (Review #290 R8)
function assertNotSymlink(filePath) {
  try {
    if (fs.lstatSync(filePath).isSymbolicLink()) {
      throw new Error(`Refusing to write to symlink: ${filePath}`);
    }
  } catch (err) {
    if (err instanceof Error) {
      if (err.code === "ENOENT") return; // File doesn't exist yet â€” safe
      // Fail closed on permission errors (Review #291 R9)
      if (err.code === "EACCES" || err.code === "EPERM") {
        throw new Error(`Refusing to write when symlink check is blocked: ${filePath}`);
      }
      if (err.message.includes("Refusing to write")) throw err;
    }
    // Fail closed: rethrow any unexpected errors (Review #292 R10)
    throw err;
  }
}

// Format date
function formatDate(date) {
  return date.toISOString().split("T")[0];
}

// Generate ENH-XXXX ID
function generateEnhId(index) {
  return `ENH-${String(index).padStart(4, "0")}`;
}

// Truncate text with ellipsis
function truncate(text, maxLen) {
  if (!text) return "";
  if (text.length <= maxLen) return text;
  return text.substring(0, maxLen - 3) + "...";
}

// Escape markdown special chars in table cells (Review #293 R11: strip HTML to prevent injection)
function escapeMarkdown(text) {
  if (!text) return "";
  return text
    .replace(/<[^>]*>/g, "") // Strip HTML tags
    .replace(/\|/g, "\\|")
    .replace(/\n/g, " ");
}

// Sort by impact (I0 first)
function impactSort(a, b) {
  const order = { I0: 0, I1: 1, I2: 2, I3: 3 };
  // Use ?? instead of || so I0 (value 0) sorts correctly (Review #287 R5)
  return (order[a.impact] ?? 4) - (order[b.impact] ?? 4);
}

// Impact level display names
const IMPACT_NAMES = {
  I0: "Transformative",
  I1: "Significant",
  I2: "Moderate",
  I3: "Minor",
};

// Valid status values
const STATUS_ORDER = ["PROPOSED", "ACCEPTED", "DECLINED", "DEFERRED", "IMPLEMENTED", "STALE"];

// Generate document header
function generateHeader(title, today) {
  return `# ${title}

<!-- prettier-ignore-start -->
**Document Version:** 1.0
**Last Updated:** ${today}
**Status:** ACTIVE
**Auto-Generated:** This file is auto-generated by \`scripts/improvements/generate-views.js\`
<!-- prettier-ignore-end -->

---

`;
}

// Fields preserved from existing MASTER items during regeneration
const PRESERVED_FIELDS = ["status", "decided_date", "decision_notes", "dependencies"];

// Load existing items to preserve their IDs and status/decision fields
function loadExistingItems() {
  const idMap = new Map(); // content_hash/source_id/fingerprint -> existing ENH-XXXX
  const itemMap = new Map(); // ENH-XXXX -> existing item (for preserving status etc.)
  let maxId = 0;

  if (fs.existsSync(MASTER_FILE)) {
    try {
      const content = fs.readFileSync(MASTER_FILE, "utf8");
      const lines = content.split("\n").filter((line) => line.trim());
      for (const line of lines) {
        try {
          const item = JSON.parse(line);
          if (item.id) {
            const match = item.id.match(/ENH-(\d+)/);
            if (match) {
              const num = Number.parseInt(match[1], 10);
              if (num > maxId) maxId = num;
            }
            // Store full item for field preservation (only for valid ENH-XXXX IDs)
            if (typeof item.id === "string" && /^ENH-\d+$/.test(item.id)) {
              itemMap.set(item.id, item);
            }
            // Map by content_hash, source_id, AND fingerprint for stable ID lookup
            if (item.content_hash) idMap.set(`hash:${item.content_hash}`, item.id);
            if (item.source_id) idMap.set(`source:${item.source_id}`, item.id);
            if (item.fingerprint) idMap.set(`fp:${item.fingerprint}`, item.id);
            // Also map merged source IDs so dedup merges preserve the original ID
            if (Array.isArray(item.merged_from)) {
              for (const srcId of item.merged_from) {
                if (typeof srcId !== "string") continue;
                idMap.set(`source:${srcId}`, item.id);
                // Strip @line: suffix to prevent ID drift after merges (Review #287 R5)
                const baseSrcId = srcId.replace(/@line:\d+$/, "");
                idMap.set(`source:${baseSrcId}`, item.id);
              }
            }
          }
        } catch {
          // Skip invalid lines
        }
      }
    } catch {
      // File doesn't exist or can't be read - start fresh
    }
  }

  return { idMap, itemMap, maxId };
}

// Strip dangerous prototype pollution keys from parsed JSONL objects (Review #291 R9)
const DANGEROUS_KEYS = new Set(["__proto__", "constructor", "prototype"]);
function safeCloneObject(obj, depth = 0) {
  if (obj === null || typeof obj !== "object") return obj;
  if (depth > 200) return Array.isArray(obj) ? [] : Object.create(null);
  if (Array.isArray(obj)) return obj.map((v) => safeCloneObject(v, depth + 1));
  const result = Object.create(null);
  for (const key of Object.keys(obj)) {
    if (!DANGEROUS_KEYS.has(key)) {
      result[key] = safeCloneObject(obj[key], depth + 1);
    }
  }
  return result;
}

// Read and parse deduped items, assigning stable ENH-XXXX IDs
function readAndAssignIds() {
  if (!fs.existsSync(INPUT_FILE)) {
    console.error(`Input file not found: ${DEDUPED_FILE} or ${MASTER_FALLBACK}`);
    console.error(
      "   Run intake or dedup pipeline first, or create an empty MASTER_IMPROVEMENTS.jsonl."
    );
    process.exit(1);
  }

  const { idMap, itemMap, maxId } = loadExistingItems();
  let nextId = maxId + 1;
  let preservedCount = 0;
  let newCount = 0;

  let content;
  try {
    content = fs.readFileSync(INPUT_FILE, "utf8");
  } catch (err) {
    const errMsg = err instanceof Error ? err.message : String(err);
    console.error(`Cannot read input file: ${errMsg}`);
    process.exit(1);
  }
  const lines = content.split("\n").filter((line) => line.trim());

  const usedIds = new Set();
  const items = [];
  const parseErrors = [];

  for (let i = 0; i < lines.length; i++) {
    let item;
    try {
      const raw = JSON.parse(lines[i]);
      item = safeCloneObject(raw);
    } catch (err) {
      parseErrors.push({ line: i + 1, message: err instanceof Error ? err.message : String(err) });
      continue;
    }

    // Skip non-object JSONL records (null, arrays, primitives) (Review #288 R6)
    if (!item || typeof item !== "object" || Array.isArray(item)) {
      parseErrors.push({
        line: i + 1,
        message: `Invalid item type (expected JSON object): ${String(item).substring(0, 80)}`,
      });
      continue;
    }

    const assignResult = assignStableId(item, idMap, usedIds, nextId);
    item.id = assignResult.id;
    usedIds.add(item.id);
    if (assignResult.isNew) {
      nextId++;
      newCount++;
    } else {
      preservedCount++;
    }

    ensureDefaults(item);
    preserveExistingFields(item, itemMap);
    items.push(item);
  }

  reportParseErrors(parseErrors);
  console.log(`  Processing ${items.length} items`);
  console.log(`     Preserved IDs: ${preservedCount}, New IDs: ${newCount}\n`);

  return { items, preservedCount, newCount };
}

// Try to find an existing stable ID for an item
function assignStableId(item, idMap, usedIds, nextId) {
  let existingId = null;
  if (item.fingerprint) {
    existingId = idMap.get(`fp:${item.fingerprint}`);
  }
  if (!existingId && item.content_hash) {
    existingId = idMap.get(`hash:${item.content_hash}`);
  }
  if (!existingId && item.source_id) {
    existingId = idMap.get(`source:${item.source_id}`);
  }
  if (!existingId && Array.isArray(item.merged_from)) {
    for (const srcId of item.merged_from) {
      existingId = idMap.get(`source:${srcId}`);
      if (existingId) break;
    }
  }

  if (existingId && !usedIds.has(existingId)) {
    return { id: existingId, isNew: false };
  }
  return { id: generateEnhId(nextId), isNew: true };
}

// Ensure required fields have defaults
function ensureDefaults(item) {
  if (!item.source_id) {
    item.source_id = item.fingerprint ? `intake:${item.fingerprint}` : `intake:${item.id}`;
  }
  if (!item.status) {
    item.status = "PROPOSED";
  }
}

// Preserve fields from existing MASTER items during regeneration
function preserveExistingFields(item, itemMap) {
  const existing = itemMap.get(item.id);
  if (!existing) return;

  for (const field of PRESERVED_FIELDS) {
    const hasExisting = existing[field] !== undefined && existing[field] !== null;
    const newIsUnset = item[field] === undefined || item[field] === null;
    const newIsDefaultStatus = field === "status" && item.status === "PROPOSED";
    if (hasExisting && (newIsUnset || newIsDefaultStatus)) {
      item[field] = existing[field];
    }
  }
}

// Report JSON parse errors
function reportParseErrors(parseErrors) {
  if (parseErrors.length === 0) return;
  console.error(`Warning: ${parseErrors.length} invalid JSON line(s) in input file`);
  for (const e of parseErrors.slice(0, 5)) {
    console.error(`   Line ${e.line}: ${e.message}`);
  }
  if (parseErrors.length > 5) {
    console.error(`   ... and ${parseErrors.length - 5} more`);
  }
  console.log();
}

// Write MASTER_IMPROVEMENTS.jsonl sorted by stable ID order
function writeMasterFile(items) {
  const idSorted = [...items].sort((a, b) => {
    const aNum = Number.parseInt((a.id || "").replaceAll("ENH-", ""), 10) || 0;
    const bNum = Number.parseInt((b.id || "").replaceAll("ENH-", ""), 10) || 0;
    return aNum - bNum;
  });
  assertNotSymlink(MASTER_FILE);

  const tmpMaster = MASTER_FILE + `.tmp.${process.pid}`;
  assertNotSymlink(tmpMaster);
  try {
    fs.writeFileSync(tmpMaster, idSorted.map((item) => JSON.stringify(item)).join("\n") + "\n", {
      encoding: "utf8",
      flag: "wx",
    });
    fs.renameSync(tmpMaster, MASTER_FILE);
  } finally {
    if (fs.existsSync(tmpMaster)) {
      try {
        fs.unlinkSync(tmpMaster);
      } catch {
        /* ignore cleanup errors */
      }
    }
  }

  console.log(`  Written: ${MASTER_FILE}`);
}

// Group items by impact, category, and status
function groupItems(items) {
  const byImpact = { I0: [], I1: [], I2: [], I3: [] };
  const byCategory = {};
  const byStatus = {};

  for (const item of items) {
    byImpact[item.impact] = byImpact[item.impact] || [];
    byImpact[item.impact].push(item);

    byCategory[item.category] = byCategory[item.category] || [];
    byCategory[item.category].push(item);

    byStatus[item.status] = byStatus[item.status] || [];
    byStatus[item.status].push(item);
  }

  return { byImpact, byCategory, byStatus };
}

// Generate and write all markdown view files
function generateViewFiles(items, byImpact, byCategory, byStatus) {
  const today = formatDate(new Date());

  if (!fs.existsSync(VIEWS_DIR)) {
    fs.mkdirSync(VIEWS_DIR, { recursive: true });
  }

  generateIndexFile(items, byImpact, byCategory, byStatus, today);
  generateImpactView(byImpact, today);
  generateCategoryView(byCategory, today);
  generateStatusView(byStatus, today);
  generateReviewQueue(byStatus, today);
}

// Generate INDEX.md
function generateIndexFile(items, byImpact, byCategory, byStatus, today) {
  let indexMd = generateHeader("Improvements Index", today);
  indexMd += `**Total Items:** ${items.length}

## Quick Stats

| Impact | Count |
|--------|-------|
| I0 (${IMPACT_NAMES.I0}) | ${byImpact.I0?.length || 0} |
| I1 (${IMPACT_NAMES.I1}) | ${byImpact.I1?.length || 0} |
| I2 (${IMPACT_NAMES.I2}) | ${byImpact.I2?.length || 0} |
| I3 (${IMPACT_NAMES.I3}) | ${byImpact.I3?.length || 0} |

| Category | Count |
|----------|-------|
${Object.entries(byCategory)
  .sort((a, b) => b[1].length - a[1].length)
  .map(([cat, catItems]) => `| ${cat} | ${catItems.length} |`)
  .join("\n")}

| Status | Count |
|--------|-------|
${Object.entries(byStatus)
  .map(([status, statusItems]) => `| ${status} | ${statusItems.length} |`)
  .join("\n")}

## Views

- [By Impact](./views/by-impact.md)
- [By Category](./views/by-category.md)
- [By Status](./views/by-status.md)
- [Review Queue](./views/review-queue.md)

## Transformative Items (I0)

${
  byImpact.I0?.length > 0
    ? byImpact.I0.map(
        (item) =>
          `- **${item.id}**: ${escapeMarkdown(truncate(item.title, 80))} (${item.category || "N/A"})`
      ).join("\n")
    : "_No I0 items_"
}

## Significant Items (I1)

${
  byImpact.I1?.length > 0
    ? byImpact.I1.slice(0, 20)
        .map(
          (item) =>
            `- **${item.id}**: ${escapeMarkdown(truncate(item.title, 80))} (${item.category || "N/A"})`
        )
        .join("\n") +
      (byImpact.I1.length > 20
        ? `\n\n_...and ${byImpact.I1.length - 20} more. See [by-impact.md](./views/by-impact.md)_`
        : "")
    : "_No I1 items_"
}

---

**Canonical Source:** \`MASTER_IMPROVEMENTS.jsonl\`
`;

  assertNotSymlink(INDEX_FILE);
  fs.writeFileSync(INDEX_FILE, indexMd);
  console.log(`  Written: ${INDEX_FILE}`);
}

// Generate views/by-impact.md
function generateImpactView(byImpact, today) {
  let impactMd = generateHeader("Improvements by Impact", today);

  for (const level of ["I0", "I1", "I2", "I3"]) {
    const levelItems = byImpact[level] || [];
    impactMd += `## ${level} - ${IMPACT_NAMES[level]} (${levelItems.length})\n\n`;

    if (levelItems.length === 0) {
      impactMd += "_No items_\n\n";
    } else {
      impactMd += "| ID | Title | Category | Status | Dependencies |\n|---|---|---|---|---|\n";
      for (const item of levelItems) {
        const deps = Array.isArray(item.dependencies)
          ? item.dependencies.join(", ")
          : item.dependencies || "";
        impactMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.category || "N/A"} | ${item.status} | ${escapeMarkdown(truncate(deps, 40))} |\n`;
      }
      impactMd += "\n";
    }
  }

  assertNotSymlink(path.join(VIEWS_DIR, "by-impact.md"));
  fs.writeFileSync(path.join(VIEWS_DIR, "by-impact.md"), impactMd);
  console.log(`  Written: ${path.join(VIEWS_DIR, "by-impact.md")}`);
}

// Generate views/by-category.md
function generateCategoryView(byCategory, today) {
  let categoryMd = generateHeader("Improvements by Category", today);

  for (const cat of Object.keys(byCategory).sort()) {
    const catItems = byCategory[cat];
    categoryMd += `## ${cat} (${catItems.length})\n\n`;
    categoryMd += "| ID | Title | Impact | Status |\n|---|---|---|---|\n";
    for (const item of catItems.sort(impactSort)) {
      categoryMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.impact} | ${item.status} |\n`;
    }
    categoryMd += "\n";
  }

  assertNotSymlink(path.join(VIEWS_DIR, "by-category.md"));
  fs.writeFileSync(path.join(VIEWS_DIR, "by-category.md"), categoryMd);
  console.log(`  Written: ${path.join(VIEWS_DIR, "by-category.md")}`);
}

// Generate views/by-status.md
function generateStatusView(byStatus, today) {
  let statusMd = generateHeader("Improvements by Status", today);

  for (const status of STATUS_ORDER) {
    const statusItems = byStatus[status] || [];
    statusMd += `## ${status} (${statusItems.length})\n\n`;

    if (statusItems.length === 0) {
      statusMd += "_No items_\n\n";
    } else {
      statusMd += "| ID | Title | Impact | Category |\n|---|---|---|---|\n";
      for (const item of statusItems.sort(impactSort)) {
        statusMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.impact} | ${item.category || "N/A"} |\n`;
      }
      statusMd += "\n";
    }
  }

  assertNotSymlink(path.join(VIEWS_DIR, "by-status.md"));
  fs.writeFileSync(path.join(VIEWS_DIR, "by-status.md"), statusMd);
  console.log(`  Written: ${path.join(VIEWS_DIR, "by-status.md")}`);
}

// Generate views/review-queue.md
function generateReviewQueue(byStatus, today) {
  const proposedItems = byStatus.PROPOSED || [];
  let reviewMd = generateHeader("Review Queue", today);
  reviewMd += `**Items Needing Review:** ${proposedItems.length}

This queue contains items with status=PROPOSED that require review.
Review each item and update its status to ACCEPTED, DECLINED, or DEFERRED.

`;

  if (proposedItems.length === 0) {
    reviewMd += "_Queue empty - all items reviewed!_\n";
  } else {
    reviewMd += "| ID | Title | Impact | Category | Dependencies |\n|---|---|---|---|---|\n";
    for (const item of proposedItems.sort(impactSort)) {
      const deps = Array.isArray(item.dependencies)
        ? item.dependencies.join(", ")
        : item.dependencies || "";
      reviewMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.impact} | ${item.category || "N/A"} | ${escapeMarkdown(truncate(deps, 40))} |\n`;
    }
  }

  assertNotSymlink(path.join(VIEWS_DIR, "review-queue.md"));
  fs.writeFileSync(path.join(VIEWS_DIR, "review-queue.md"), reviewMd);
  console.log(`  Written: ${path.join(VIEWS_DIR, "review-queue.md")}`);
}

function main() {
  console.log("Generating IMS views and final output...\n");

  const { items, newCount, preservedCount } = readAndAssignIds();

  writeMasterFile(items);

  // Warn if many new IDs were assigned (potential instability)
  if (newCount > 0 && preservedCount > 0 && newCount > 10) {
    const newPct = ((newCount / items.length) * 100).toFixed(1);
    console.log(`  Warning: ${newCount} new IDs assigned (${newPct}%) - check for ID drift`);
  }

  items.sort(impactSort);

  // Group and generate views
  const { byImpact, byCategory, byStatus } = groupItems(items);
  generateViewFiles(items, byImpact, byCategory, byStatus);

  console.log(`\nAll views generated successfully!`);
  console.log(`\nFinal Summary:`);
  console.log(`   Total: ${items.length} items`);
  console.log(
    `   I0: ${byImpact.I0?.length || 0}, I1: ${byImpact.I1?.length || 0}, I2: ${byImpact.I2?.length || 0}, I3: ${byImpact.I3?.length || 0}`
  );
}

main();
