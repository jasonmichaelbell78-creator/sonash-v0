#!/usr/bin/env node
/* global __dirname */
/**
 * Generate TDMS Views and Final Output
 *
 * Reads: docs/technical-debt/raw/deduped.jsonl
 * Outputs:
 *   - docs/technical-debt/MASTER_DEBT.jsonl (final canonical with DEBT-XXXX IDs)
 *   - docs/technical-debt/INDEX.md (human-readable index)
 *   - docs/technical-debt/views/by-severity.md
 *   - docs/technical-debt/views/by-category.md
 *   - docs/technical-debt/views/by-status.md
 *   - docs/technical-debt/views/verification-queue.md
 *   - docs/technical-debt/LEGACY_ID_MAPPING.json
 */

const fs = require("fs");
const path = require("path");

const INPUT_FILE = path.join(__dirname, "../../docs/technical-debt/raw/deduped.jsonl");
const BASE_DIR = path.join(__dirname, "../../docs/technical-debt");
const MASTER_FILE = path.join(BASE_DIR, "MASTER_DEBT.jsonl");
const INDEX_FILE = path.join(BASE_DIR, "INDEX.md");
const VIEWS_DIR = path.join(BASE_DIR, "views");
const LEGACY_MAP_FILE = path.join(BASE_DIR, "LEGACY_ID_MAPPING.json");

// Format date
function formatDate(date) {
  return date.toISOString().split("T")[0];
}

// Generate DEBT-XXXX ID
function generateDebtId(index) {
  return `DEBT-${String(index).padStart(4, "0")}`;
}

// Truncate text with ellipsis
function truncate(text, maxLen) {
  if (!text) return "";
  if (text.length <= maxLen) return text;
  return text.substring(0, maxLen - 3) + "...";
}

// Escape markdown special chars in table cells
function escapeMarkdown(text) {
  if (!text) return "";
  return text.replace(/\|/g, "\\|").replace(/\n/g, " ");
}

// Sort by severity (S0 first)
function severitySort(a, b) {
  const order = { S0: 0, S1: 1, S2: 2, S3: 3 };
  return (order[a.severity] || 4) - (order[b.severity] || 4);
}

// Generate document header
function generateHeader(title, today) {
  return `# ${title}

<!-- prettier-ignore-start -->
**Document Version:** 1.0
**Last Updated:** ${today}
**Status:** ACTIVE
**Auto-Generated:** This file is auto-generated by \`scripts/debt/generate-views.js\`
<!-- prettier-ignore-end -->

---

`;
}

// Fields preserved from existing MASTER items during regeneration
const PRESERVED_FIELDS = [
  "status",
  "resolution",
  "verified_date",
  "verification_reason",
  "roadmap_ref",
  "milestone",
  "roadmap_phase",
];

// Load existing items to preserve their IDs and status/resolution fields
function loadExistingItems() {
  const idMap = new Map(); // content_hash/source_id/fingerprint -> existing DEBT-XXXX
  const itemMap = new Map(); // DEBT-XXXX -> existing item (for preserving status etc.)
  let maxId = 0;

  if (fs.existsSync(MASTER_FILE)) {
    try {
      const content = fs.readFileSync(MASTER_FILE, "utf8");
      const lines = content.split("\n").filter((line) => line.trim());
      for (const line of lines) {
        try {
          const item = JSON.parse(line);
          if (item.id) {
            const match = item.id.match(/DEBT-(\d+)/);
            if (match) {
              const num = parseInt(match[1], 10);
              if (num > maxId) maxId = num;
            }
            // Store full item for field preservation
            itemMap.set(item.id, item);
            // Map by content_hash, source_id, AND fingerprint for stable ID lookup
            if (item.content_hash) idMap.set(`hash:${item.content_hash}`, item.id);
            if (item.source_id) idMap.set(`source:${item.source_id}`, item.id);
            if (item.fingerprint) idMap.set(`fp:${item.fingerprint}`, item.id);
            // Also map merged source IDs so dedup merges preserve the original ID
            if (Array.isArray(item.merged_from)) {
              for (const srcId of item.merged_from) {
                idMap.set(`source:${srcId}`, item.id);
              }
            }
          }
        } catch {
          // Skip invalid lines
        }
      }
    } catch {
      // File doesn't exist or can't be read - start fresh
    }
  }

  return { idMap, itemMap, maxId };
}

function main() {
  console.log("ðŸ“ Generating TDMS views and final output...\n");

  if (!fs.existsSync(INPUT_FILE)) {
    console.error(`âŒ Input file not found: ${INPUT_FILE}`);
    console.error("   Run dedup-multi-pass.js first.");
    process.exit(1);
  }

  // Load existing items to preserve IDs and status/resolution fields
  const { idMap, itemMap, maxId } = loadExistingItems();
  let nextId = maxId + 1;
  let preservedCount = 0;
  let newCount = 0;

  // Read deduped items with safe JSON parsing
  let content;
  try {
    content = fs.readFileSync(INPUT_FILE, "utf8");
  } catch (err) {
    const errMsg = err instanceof Error ? err.message : String(err);
    console.error(`âŒ Cannot read input file: ${errMsg}`);
    process.exit(1);
  }
  const lines = content.split("\n").filter((line) => line.trim());

  // Track used IDs to prevent duplicates in current run
  const usedIds = new Set();

  const items = [];
  const parseErrors = [];

  for (let i = 0; i < lines.length; i++) {
    let item;
    try {
      item = JSON.parse(lines[i]);
    } catch (err) {
      parseErrors.push({ line: i + 1, message: err instanceof Error ? err.message : String(err) });
      continue;
    }

    // Try to find existing ID (preserve stable IDs)
    // Priority: fingerprint > content_hash > source_id (fingerprint is most stable)
    let existingId = null;
    if (item.fingerprint) {
      existingId = idMap.get(`fp:${item.fingerprint}`);
    }
    if (!existingId && item.content_hash) {
      existingId = idMap.get(`hash:${item.content_hash}`);
    }
    if (!existingId && item.source_id) {
      existingId = idMap.get(`source:${item.source_id}`);
    }
    // Also check merged_from source IDs as fallback
    if (!existingId && Array.isArray(item.merged_from)) {
      for (const srcId of item.merged_from) {
        existingId = idMap.get(`source:${srcId}`);
        if (existingId) break;
      }
    }

    // Check if existingId is already used in this run to prevent duplicates
    if (existingId && !usedIds.has(existingId)) {
      item.id = existingId;
      usedIds.add(existingId);
      preservedCount++;
    } else {
      // Assign new ID if no stable ID exists OR the stable ID is already used
      item.id = generateDebtId(nextId);
      usedIds.add(item.id);
      nextId++;
      newCount++;
    }

    // Ensure required fields have defaults (intake items may lack source_id/status)
    if (!item.source_id) {
      item.source_id = item.fingerprint ? `intake:${item.fingerprint}` : `intake:${item.id}`;
    }
    if (!item.status) {
      item.status = "NEW";
    }

    // Preserve status/resolution/verification fields from existing MASTER items
    // This ensures verification results survive view regeneration
    const existing = itemMap.get(item.id);
    if (existing) {
      for (const field of PRESERVED_FIELDS) {
        if (existing[field] !== undefined && existing[field] !== null) {
          item[field] = existing[field];
        }
      }
    }

    items.push(item);
  }

  // Report parse errors
  if (parseErrors.length > 0) {
    console.error(`âš ï¸ Warning: ${parseErrors.length} invalid JSON line(s) in input file`);
    for (const e of parseErrors.slice(0, 5)) {
      console.error(`   Line ${e.line}: ${e.message}`);
    }
    if (parseErrors.length > 5) {
      console.error(`   ... and ${parseErrors.length - 5} more`);
    }
    console.log();
  }

  console.log(`  ðŸ“Š Processing ${items.length} items`);
  console.log(`     Preserved IDs: ${preservedCount}, New IDs: ${newCount}\n`);

  // Write MASTER_DEBT.jsonl in stable ID order (prevents gratuitous diffs)
  const idSorted = [...items].sort((a, b) => {
    const aNum = parseInt((a.id || "").replace("DEBT-", ""), 10) || 0;
    const bNum = parseInt((b.id || "").replace("DEBT-", ""), 10) || 0;
    return aNum - bNum;
  });
  const masterLines = idSorted.map((item) => JSON.stringify(item));
  fs.writeFileSync(MASTER_FILE, masterLines.join("\n") + "\n");
  console.log(`  âœ… ${MASTER_FILE}`);

  // Warn if many new IDs were assigned (potential instability)
  if (newCount > 0 && preservedCount > 0) {
    const newPct = ((newCount / items.length) * 100).toFixed(1);
    if (newCount > 10) {
      console.log(`  âš ï¸  ${newCount} new IDs assigned (${newPct}%) - check for ID drift`);
    }
  }

  // Sort by severity for view file ordering
  items.sort(severitySort);

  // Ensure directories exist
  if (!fs.existsSync(VIEWS_DIR)) {
    fs.mkdirSync(VIEWS_DIR, { recursive: true });
  }

  // Build legacy ID mapping
  const legacyMapping = {};
  for (const item of items) {
    if (item.original_id) {
      legacyMapping[item.original_id] = item.id;
    }
    if (item.source_id) {
      legacyMapping[item.source_id] = item.id;
    }
  }

  // Write LEGACY_ID_MAPPING.json
  fs.writeFileSync(LEGACY_MAP_FILE, JSON.stringify(legacyMapping, null, 2));
  console.log(`  âœ… ${LEGACY_MAP_FILE}`);

  // Generate INDEX.md
  const today = formatDate(new Date());
  const bySeverity = { S0: [], S1: [], S2: [], S3: [] };
  const byCategory = {};
  const byStatus = {};

  for (const item of items) {
    bySeverity[item.severity] = bySeverity[item.severity] || [];
    bySeverity[item.severity].push(item);

    byCategory[item.category] = byCategory[item.category] || [];
    byCategory[item.category].push(item);

    byStatus[item.status] = byStatus[item.status] || [];
    byStatus[item.status].push(item);
  }

  let indexMd = generateHeader("Technical Debt Index", today);
  indexMd += `**Total Items:** ${items.length}

## Quick Stats

| Severity | Count |
|----------|-------|
| S0 (Critical) | ${bySeverity.S0?.length || 0} |
| S1 (High) | ${bySeverity.S1?.length || 0} |
| S2 (Medium) | ${bySeverity.S2?.length || 0} |
| S3 (Low) | ${bySeverity.S3?.length || 0} |

| Category | Count |
|----------|-------|
${Object.entries(byCategory)
  .sort((a, b) => b[1].length - a[1].length)
  .map(([cat, items]) => `| ${cat} | ${items.length} |`)
  .join("\n")}

| Status | Count |
|--------|-------|
${Object.entries(byStatus)
  .map(([status, items]) => `| ${status} | ${items.length} |`)
  .join("\n")}

## Views

- [By Severity](./views/by-severity.md)
- [By Category](./views/by-category.md)
- [By Status](./views/by-status.md)
- [Verification Queue](./views/verification-queue.md)

## Critical Items (S0)

${
  bySeverity.S0?.length > 0
    ? bySeverity.S0.map(
        (item) =>
          `- **${item.id}**: ${escapeMarkdown(truncate(item.title, 80))} (${item.file || "N/A"}:${item.line})`
      ).join("\n")
    : "_No S0 items_"
}

## High Priority Items (S1)

${
  bySeverity.S1?.length > 0
    ? bySeverity.S1.slice(0, 20)
        .map(
          (item) =>
            `- **${item.id}**: ${escapeMarkdown(truncate(item.title, 80))} (${item.file || "N/A"}:${item.line})`
        )
        .join("\n") +
      (bySeverity.S1.length > 20
        ? `\n\n_...and ${bySeverity.S1.length - 20} more. See [by-severity.md](./views/by-severity.md)_`
        : "")
    : "_No S1 items_"
}

---

**Canonical Source:** \`MASTER_DEBT.jsonl\`

**Legacy ID Mapping:** See \`LEGACY_ID_MAPPING.json\` for CANON-*, DEDUP-*, MASTER-* â†’ DEBT-XXXX mapping.
`;

  fs.writeFileSync(INDEX_FILE, indexMd);
  console.log(`  âœ… ${INDEX_FILE}`);

  // Generate views/by-severity.md
  let severityMd = generateHeader("Technical Debt by Severity", today);

  for (const sev of ["S0", "S1", "S2", "S3"]) {
    const sevItems = bySeverity[sev] || [];
    const sevNames = { S0: "Critical", S1: "High", S2: "Medium", S3: "Low" };

    severityMd += `## ${sev} - ${sevNames[sev]} (${sevItems.length})\n\n`;

    if (sevItems.length === 0) {
      severityMd += "_No items_\n\n";
    } else {
      severityMd += "| ID | Title | File | Line | Category | Effort |\n|---|---|---|---|---|---|\n";
      for (const item of sevItems) {
        severityMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.file || "N/A"} | ${item.line} | ${item.category} | ${item.effort} |\n`;
      }
      severityMd += "\n";
    }
  }

  fs.writeFileSync(path.join(VIEWS_DIR, "by-severity.md"), severityMd);
  console.log(`  âœ… ${path.join(VIEWS_DIR, "by-severity.md")}`);

  // Generate views/by-category.md
  let categoryMd = generateHeader("Technical Debt by Category", today);

  for (const cat of Object.keys(byCategory).sort()) {
    const catItems = byCategory[cat];
    categoryMd += `## ${cat} (${catItems.length})\n\n`;
    categoryMd += "| ID | Title | Severity | File | Line |\n|---|---|---|---|---|\n";
    for (const item of catItems.sort(severitySort)) {
      categoryMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.severity} | ${item.file || "N/A"} | ${item.line} |\n`;
    }
    categoryMd += "\n";
  }

  fs.writeFileSync(path.join(VIEWS_DIR, "by-category.md"), categoryMd);
  console.log(`  âœ… ${path.join(VIEWS_DIR, "by-category.md")}`);

  // Generate views/by-status.md
  let statusMd = generateHeader("Technical Debt by Status", today);

  for (const status of ["NEW", "VERIFIED", "IN_PROGRESS", "RESOLVED", "FALSE_POSITIVE"]) {
    const statusItems = byStatus[status] || [];
    statusMd += `## ${status} (${statusItems.length})\n\n`;

    if (statusItems.length === 0) {
      statusMd += "_No items_\n\n";
    } else {
      statusMd += "| ID | Title | Severity | Category |\n|---|---|---|---|\n";
      for (const item of statusItems.sort(severitySort)) {
        statusMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.severity} | ${item.category} |\n`;
      }
      statusMd += "\n";
    }
  }

  fs.writeFileSync(path.join(VIEWS_DIR, "by-status.md"), statusMd);
  console.log(`  âœ… ${path.join(VIEWS_DIR, "by-status.md")}`);

  // Generate views/verification-queue.md
  const newItems = byStatus.NEW || [];
  let verifyMd = generateHeader("Verification Queue", today);
  verifyMd += `**Items Needing Verification:** ${newItems.length}

This queue contains items with status=NEW that require verification.
Run \`verify-technical-debt\` skill to process this queue.

`;

  if (newItems.length === 0) {
    verifyMd += "_Queue empty - all items verified!_\n";
  } else {
    verifyMd += "| ID | Title | Severity | File | Line |\n|---|---|---|---|---|\n";
    for (const item of newItems.sort(severitySort)) {
      verifyMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.severity} | ${item.file || "N/A"} | ${item.line} |\n`;
    }
  }

  fs.writeFileSync(path.join(VIEWS_DIR, "verification-queue.md"), verifyMd);
  console.log(`  âœ… ${path.join(VIEWS_DIR, "verification-queue.md")}`);

  console.log(`\nâœ… All views generated successfully!`);
  console.log(`\nðŸ“Š Final Summary:`);
  console.log(`   Total: ${items.length} items`);
  console.log(
    `   S0: ${bySeverity.S0?.length || 0}, S1: ${bySeverity.S1?.length || 0}, S2: ${bySeverity.S2?.length || 0}, S3: ${bySeverity.S3?.length || 0}`
  );
}

main();
