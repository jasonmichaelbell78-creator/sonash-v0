#!/usr/bin/env node
/* global __dirname */
/**
 * Generate TDMS Views
 *
 * Default mode: Reads MASTER_DEBT.jsonl and generates markdown views (read-only).
 * --ingest mode: Also processes deduped.jsonl, assigns DEBT IDs to new items,
 *                and appends them to MASTER_DEBT.jsonl before generating views.
 *
 * Reads: docs/technical-debt/MASTER_DEBT.jsonl (always)
 *        docs/technical-debt/raw/deduped.jsonl (only with --ingest)
 * Outputs:
 *   - docs/technical-debt/INDEX.md (human-readable index)
 *   - docs/technical-debt/views/by-severity.md
 *   - docs/technical-debt/views/by-category.md
 *   - docs/technical-debt/views/by-status.md
 *   - docs/technical-debt/views/verification-queue.md
 *   - docs/technical-debt/LEGACY_ID_MAPPING.json
 *   - docs/technical-debt/MASTER_DEBT.jsonl (only with --ingest, append-only)
 */

const fs = require("node:fs");
const path = require("node:path");

const INPUT_FILE = path.join(__dirname, "../../docs/technical-debt/raw/deduped.jsonl");
const BASE_DIR = path.join(__dirname, "../../docs/technical-debt");
const MASTER_FILE = path.join(BASE_DIR, "MASTER_DEBT.jsonl");
const DEDUPED_FILE = INPUT_FILE;
const INDEX_FILE = path.join(BASE_DIR, "INDEX.md");
const VIEWS_DIR = path.join(BASE_DIR, "views");
const LEGACY_MAP_FILE = path.join(BASE_DIR, "LEGACY_ID_MAPPING.json");

// Sync safety guard moved into main() ‚Äî see syncBeforeRead()

// Format date
function formatDate(date) {
  return date.toISOString().split("T")[0];
}

// Generate DEBT-XXXX ID
function generateDebtId(index) {
  return `DEBT-${String(index).padStart(4, "0")}`;
}

// Truncate text with ellipsis
function truncate(text, maxLen) {
  if (!text) return "";
  if (text.length <= maxLen) return text;
  return text.substring(0, maxLen - 3) + "...";
}

// Escape markdown special chars in table cells
function escapeMarkdown(text) {
  if (!text) return "";
  return text.replace(/\|/g, "\\|").replace(/\n/g, " ");
}

// Sort by severity (S0 first)
function severitySort(a, b) {
  const order = { S0: 0, S1: 1, S2: 2, S3: 3 };
  return (order[a.severity] || 4) - (order[b.severity] || 4);
}

// Generate document header
function generateHeader(title, today) {
  return `# ${title}

<!-- prettier-ignore-start -->
**Document Version:** 1.0
**Last Updated:** ${today}
**Status:** ACTIVE
**Auto-Generated:** This file is auto-generated by \`scripts/debt/generate-views.js\`
<!-- prettier-ignore-end -->

---

`;
}

// Fields preserved from existing MASTER items during regeneration
const PRESERVED_FIELDS = [
  "status",
  "resolution",
  "verified_date",
  "verification_reason",
  "roadmap_ref",
  "milestone",
  "roadmap_phase",
  "source",
  "source_id",
  "source_file",
];

// Load existing items to preserve their IDs and status/resolution fields
function loadExistingItems() {
  const idMap = new Map(); // content_hash/source_id/fingerprint -> existing DEBT-XXXX
  const itemMap = new Map(); // DEBT-XXXX -> existing item (for preserving status etc.)
  let maxId = 0;

  if (fs.existsSync(MASTER_FILE)) {
    try {
      const content = fs.readFileSync(MASTER_FILE, "utf8");
      const lines = content.split("\n").filter((line) => line.trim());
      for (const line of lines) {
        try {
          const item = JSON.parse(line);
          if (item.id) {
            const match = item.id.match(/DEBT-(\d+)/);
            if (match) {
              const num = Number.parseInt(match[1], 10);
              if (num > maxId) maxId = num;
            }
            // Store full item for field preservation (only for valid DEBT-XXXX IDs)
            if (typeof item.id === "string" && /^DEBT-\d+$/.test(item.id)) {
              itemMap.set(item.id, item);
            }
            // Map by content_hash, source_id, AND fingerprint for stable ID lookup
            if (item.content_hash) idMap.set(`hash:${item.content_hash}`, item.id);
            if (item.source_id) idMap.set(`source:${item.source_id}`, item.id);
            if (item.fingerprint) idMap.set(`fp:${item.fingerprint}`, item.id);
            // Also map merged source IDs so dedup merges preserve the original ID
            if (Array.isArray(item.merged_from)) {
              for (const srcId of item.merged_from) {
                idMap.set(`source:${srcId}`, item.id);
              }
            }
          }
        } catch {
          // Skip invalid lines
        }
      }
    } catch {
      // File doesn't exist or can't be read - start fresh
    }
  }

  return { idMap, itemMap, maxId };
}

// Read and parse deduped items, assigning stable DEBT-XXXX IDs
function readAndAssignIds() {
  if (!fs.existsSync(INPUT_FILE)) {
    console.error(`‚ùå Input file not found: ${INPUT_FILE}`);
    console.error("   Run dedup-multi-pass.js first.");
    process.exit(1);
  }

  const { idMap, itemMap, maxId } = loadExistingItems();
  let nextId = maxId + 1;
  let preservedCount = 0;
  let newCount = 0;

  let content;
  try {
    content = fs.readFileSync(INPUT_FILE, "utf8");
  } catch (err) {
    const errMsg = err instanceof Error ? err.message : String(err);
    console.error(`‚ùå Cannot read input file: ${errMsg}`);
    process.exit(1);
  }
  const lines = content.split("\n").filter((line) => line.trim());

  const usedIds = new Set();
  const items = [];
  const parseErrors = [];

  for (let i = 0; i < lines.length; i++) {
    let item;
    try {
      item = JSON.parse(lines[i]);
    } catch (err) {
      parseErrors.push({ line: i + 1, message: err instanceof Error ? err.message : String(err) });
      continue;
    }

    const assignResult = assignStableId(item, idMap, usedIds, nextId);
    item.id = assignResult.id;
    usedIds.add(item.id);
    if (assignResult.isNew) {
      nextId++;
      newCount++;
    } else {
      preservedCount++;
    }

    ensureDefaults(item);
    preserveExistingFields(item, itemMap);
    items.push(item);
  }

  reportParseErrors(parseErrors);
  console.log(`  üìä Processing ${items.length} items`);
  console.log(`     Preserved IDs: ${preservedCount}, New IDs: ${newCount}\n`);

  return { items, preservedCount, newCount };
}

// Try to find an existing stable ID for an item
function assignStableId(item, idMap, usedIds, nextId) {
  let existingId = null;
  if (item.fingerprint) {
    existingId = idMap.get(`fp:${item.fingerprint}`);
  }
  if (!existingId && item.content_hash) {
    existingId = idMap.get(`hash:${item.content_hash}`);
  }
  if (!existingId && item.source_id) {
    existingId = idMap.get(`source:${item.source_id}`);
  }
  if (!existingId && Array.isArray(item.merged_from)) {
    for (const srcId of item.merged_from) {
      existingId = idMap.get(`source:${srcId}`);
      if (existingId) break;
    }
  }

  if (existingId && !usedIds.has(existingId)) {
    return { id: existingId, isNew: false };
  }
  return { id: generateDebtId(nextId), isNew: true };
}

// Normalize file paths: strip absolute repo prefix if present
function normalizeFilePath(filePath) {
  if (typeof filePath !== "string") return filePath;
  const repoRootAbs = path.resolve(__dirname, "../..");
  const repoRoot = repoRootAbs + path.sep;
  const hadTrailingSlash = filePath.endsWith("/") || filePath.endsWith(path.sep);
  const resolved = path.resolve(repoRootAbs, filePath);
  if (resolved.startsWith(repoRoot)) {
    const relative = resolved.slice(repoRoot.length).split(path.sep).join("/");
    return hadTrailingSlash ? relative + "/" : relative;
  }
  return filePath;
}

// Ensure required fields have defaults
function ensureDefaults(item) {
  if (!item.source_id) {
    item.source_id = item.fingerprint ? `intake:${item.fingerprint}` : `intake:${item.id}`;
  }
  // Derive source from source_id prefix if not set (e.g. "intake:xxx" -> "intake")
  if (!item.source && item.source_id && item.source_id.includes(":")) {
    item.source = item.source_id.split(":")[0];
  }
  if (!item.status) {
    item.status = "NEW";
  }
  // Trim category to prevent whitespace-induced duplicate groups
  if (typeof item.category === "string") item.category = item.category.trim();
  // Normalize absolute paths to repo-relative
  item.file = normalizeFilePath(item.file);
  if (Array.isArray(item.evidence)) {
    for (const e of item.evidence) {
      if (e && typeof e === "object") {
        e.file = normalizeFilePath(e.file);
      }
    }
  }
}

// Preserve fields from existing MASTER items during regeneration
function preserveExistingFields(item, itemMap) {
  const existing = itemMap.get(item.id);
  if (!existing) return;

  for (const field of PRESERVED_FIELDS) {
    const hasExisting = existing[field] !== undefined && existing[field] !== null;
    const newIsUnset = item[field] === undefined || item[field] === null;
    const newIsDefaultStatus = field === "status" && item.status === "NEW";
    if (hasExisting && (newIsUnset || newIsDefaultStatus)) {
      item[field] = existing[field];
    }
  }
}

// Report JSON parse errors
function reportParseErrors(parseErrors) {
  if (parseErrors.length === 0) return;
  console.error(`‚ö†Ô∏è Warning: ${parseErrors.length} invalid JSON line(s) in input file`);
  for (const e of parseErrors.slice(0, 5)) {
    console.error(`   Line ${e.line}: ${e.message}`);
  }
  if (parseErrors.length > 5) {
    console.error(`   ... and ${parseErrors.length - 5} more`);
  }
  console.log();
}

// Write MASTER_DEBT.jsonl sorted by stable ID order
function writeMasterFile(items) {
  const idSorted = [...items].sort((a, b) => {
    const aNum = Number.parseInt((a.id || "").replaceAll("DEBT-", ""), 10) || 0;
    const bNum = Number.parseInt((b.id || "").replaceAll("DEBT-", ""), 10) || 0;
    return aNum - bNum;
  });
  fs.writeFileSync(MASTER_FILE, idSorted.map((item) => JSON.stringify(item)).join("\n") + "\n");
  console.log(`  ‚úÖ ${MASTER_FILE}`);
}

// Group items by severity, category, and status
function groupItems(items) {
  const bySeverity = { S0: [], S1: [], S2: [], S3: [] };
  const byCategory = {};
  const byStatus = {};

  for (const item of items) {
    bySeverity[item.severity] = bySeverity[item.severity] || [];
    bySeverity[item.severity].push(item);

    byCategory[item.category] = byCategory[item.category] || [];
    byCategory[item.category].push(item);

    byStatus[item.status] = byStatus[item.status] || [];
    byStatus[item.status].push(item);
  }

  return { bySeverity, byCategory, byStatus };
}

// Generate and write all markdown view files
function generateViewFiles(items, bySeverity, byCategory, byStatus) {
  const today = formatDate(new Date());

  if (!fs.existsSync(VIEWS_DIR)) {
    fs.mkdirSync(VIEWS_DIR, { recursive: true });
  }

  generateIndexFile(items, bySeverity, byCategory, byStatus, today);
  generateSeverityView(bySeverity, today);
  generateCategoryView(byCategory, today);
  generateStatusView(byStatus, today);
  generateVerificationQueue(byStatus, today);
}

// Generate INDEX.md
function generateIndexFile(items, bySeverity, byCategory, byStatus, today) {
  let indexMd = generateHeader("Technical Debt Index", today);
  indexMd += `**Total Items:** ${items.length}

## Quick Stats

| Severity | Count |
|----------|-------|
| S0 (Critical) | ${bySeverity.S0?.length ?? 0} |
| S1 (High) | ${bySeverity.S1?.length ?? 0} |
| S2 (Medium) | ${bySeverity.S2?.length ?? 0} |
| S3 (Low) | ${bySeverity.S3?.length ?? 0} |

| Category | Count |
|----------|-------|
${Object.entries(byCategory)
  .sort((a, b) => b[1].length - a[1].length)
  .map(([cat, catItems]) => `| ${cat} | ${catItems.length} |`)
  .join("\n")}

| Status | Count |
|--------|-------|
${Object.entries(byStatus)
  .map(([status, statusItems]) => `| ${status} | ${statusItems.length} |`)
  .join("\n")}

## Views

- [By Severity](./views/by-severity.md)
- [By Category](./views/by-category.md)
- [By Status](./views/by-status.md)
- [Verification Queue](./views/verification-queue.md)

## Critical Items (S0)

${
  bySeverity.S0?.length > 0
    ? bySeverity.S0.map(
        (item) =>
          `- **${item.id}**: ${escapeMarkdown(truncate(item.title, 80))} (${item.file || "N/A"}:${item.line})`
      ).join("\n")
    : "_No S0 items_"
}

## High Priority Items (S1)

${
  bySeverity.S1?.length > 0
    ? bySeverity.S1.slice(0, 20)
        .map(
          (item) =>
            `- **${item.id}**: ${escapeMarkdown(truncate(item.title, 80))} (${item.file || "N/A"}:${item.line})`
        )
        .join("\n") +
      (bySeverity.S1.length > 20
        ? `\n\n_...and ${bySeverity.S1.length - 20} more. See [by-severity.md](./views/by-severity.md)_`
        : "")
    : "_No S1 items_"
}

---

**Canonical Source:** \`MASTER_DEBT.jsonl\`

**Legacy ID Mapping:** See \`LEGACY_ID_MAPPING.json\` for CANON-*, DEDUP-*, MASTER-* ‚Üí DEBT-XXXX mapping.
`;

  fs.writeFileSync(INDEX_FILE, indexMd);
  console.log(`  ‚úÖ ${INDEX_FILE}`);
}

// Generate views/by-severity.md
function generateSeverityView(bySeverity, today) {
  let severityMd = generateHeader("Technical Debt by Severity", today);
  const sevNames = { S0: "Critical", S1: "High", S2: "Medium", S3: "Low" };

  for (const sev of ["S0", "S1", "S2", "S3"]) {
    const sevItems = bySeverity[sev] || [];
    severityMd += `## ${sev} - ${sevNames[sev]} (${sevItems.length})\n\n`;

    if (sevItems.length === 0) {
      severityMd += "_No items_\n\n";
    } else {
      severityMd += "| ID | Title | File | Line | Category | Effort |\n|---|---|---|---|---|---|\n";
      for (const item of sevItems) {
        severityMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.file || "N/A"} | ${item.line} | ${item.category} | ${item.effort} |\n`;
      }
      severityMd += "\n";
    }
  }

  fs.writeFileSync(path.join(VIEWS_DIR, "by-severity.md"), severityMd);
  console.log(`  ‚úÖ ${path.join(VIEWS_DIR, "by-severity.md")}`);
}

// Generate views/by-category.md
function generateCategoryView(byCategory, today) {
  let categoryMd = generateHeader("Technical Debt by Category", today);

  for (const cat of Object.keys(byCategory).sort()) {
    const catItems = byCategory[cat];
    categoryMd += `## ${cat} (${catItems.length})\n\n`;
    categoryMd += "| ID | Title | Severity | File | Line |\n|---|---|---|---|---|\n";
    for (const item of catItems.sort(severitySort)) {
      categoryMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.severity} | ${item.file || "N/A"} | ${item.line} |\n`;
    }
    categoryMd += "\n";
  }

  fs.writeFileSync(path.join(VIEWS_DIR, "by-category.md"), categoryMd);
  console.log(`  ‚úÖ ${path.join(VIEWS_DIR, "by-category.md")}`);
}

// Generate views/by-status.md
function generateStatusView(byStatus, today) {
  let statusMd = generateHeader("Technical Debt by Status", today);

  for (const status of ["NEW", "VERIFIED", "IN_PROGRESS", "RESOLVED", "FALSE_POSITIVE"]) {
    const statusItems = byStatus[status] || [];
    statusMd += `## ${status} (${statusItems.length})\n\n`;

    if (statusItems.length === 0) {
      statusMd += "_No items_\n\n";
    } else {
      statusMd += "| ID | Title | Severity | Category |\n|---|---|---|---|\n";
      for (const item of statusItems.sort(severitySort)) {
        statusMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.severity} | ${item.category} |\n`;
      }
      statusMd += "\n";
    }
  }

  fs.writeFileSync(path.join(VIEWS_DIR, "by-status.md"), statusMd);
  console.log(`  ‚úÖ ${path.join(VIEWS_DIR, "by-status.md")}`);
}

// Generate views/verification-queue.md
function generateVerificationQueue(byStatus, today) {
  const newItems = byStatus.NEW || [];
  let verifyMd = generateHeader("Verification Queue", today);
  verifyMd += `**Items Needing Verification:** ${newItems.length}

This queue contains items with status=NEW that require verification.
Run \`verify-technical-debt\` skill to process this queue.

`;

  if (newItems.length === 0) {
    verifyMd += "_Queue empty - all items verified!_\n";
  } else {
    verifyMd += "| ID | Title | Severity | File | Line |\n|---|---|---|---|---|\n";
    for (const item of newItems.sort(severitySort)) {
      verifyMd += `| ${item.id} | ${escapeMarkdown(truncate(item.title, 60))} | ${item.severity} | ${item.file || "N/A"} | ${item.line} |\n`;
    }
  }

  fs.writeFileSync(path.join(VIEWS_DIR, "verification-queue.md"), verifyMd);
  console.log(`  ‚úÖ ${path.join(VIEWS_DIR, "verification-queue.md")}`);
}

// Preserve manually-added items from MASTER_DEBT.jsonl not in deduped input.
// Items added directly to MASTER_DEBT.jsonl (e.g. orphaned ROADMAP refs)
// would be lost on regeneration since readAndAssignIds reads from deduped.jsonl.
function mergeManualItems(items) {
  const { itemMap } = loadExistingItems();
  const assignedIds = new Set(
    items.map((item) => item && item.id).filter((id) => typeof id === "string" && id.length > 0)
  );
  let mergedCount = 0;

  for (const [id, existing] of itemMap) {
    if (!assignedIds.has(id)) {
      ensureDefaults(existing);
      items.push(existing);
      assignedIds.add(id);
      mergedCount++;
    }
  }

  if (mergedCount > 0) {
    console.log(`  üîó Preserved ${mergedCount} manually-added item(s) from MASTER_DEBT.jsonl`);
  }

  return mergedCount;
}

// Read all items from MASTER_DEBT.jsonl (source of truth)
function loadMasterItems() {
  if (!fs.existsSync(MASTER_FILE)) {
    console.error(`‚ùå MASTER_DEBT.jsonl not found: ${MASTER_FILE}`);
    process.exit(1);
  }
  let content;
  try {
    content = fs.readFileSync(MASTER_FILE, "utf8");
  } catch (err) {
    const errMsg = err instanceof Error ? err.message : String(err);
    console.error(`‚ùå Cannot read MASTER_DEBT.jsonl: ${errMsg}`);
    process.exit(1);
  }
  const lines = content.split("\n").filter((line) => line.trim());
  const items = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    try {
      items.push(JSON.parse(line));
    } catch {
      console.warn(`  Warning: invalid JSON at line ${i + 1} ‚Äî skipping`);
    }
  }
  console.log(`  Loaded ${items.length} items from MASTER_DEBT.jsonl`);
  return items;
}

function appendNewItems(newItems, masterItems) {
  let appendData = newItems.map((item) => JSON.stringify(item)).join("\n") + "\n";
  try {
    // Ensure we don't merge the last existing JSONL line with the first appended line
    const stat = fs.statSync(MASTER_FILE);
    if (stat.size > 0) {
      const fd = fs.openSync(MASTER_FILE, "r");
      try {
        const buf = Buffer.alloc(1);
        fs.readSync(fd, buf, 0, 1, stat.size - 1);
        if (buf.toString("utf8") !== "\n") {
          appendData = "\n" + appendData;
        }
      } finally {
        fs.closeSync(fd);
      }
    }
    fs.appendFileSync(MASTER_FILE, appendData);
  } catch (err) {
    const errMsg = err instanceof Error ? err.message : String(err);
    console.error(`‚ùå Failed to append to MASTER_DEBT.jsonl: ${errMsg}`);
    process.exit(1);
  }
  masterItems.push(...newItems);
  console.log(`  üì• Ingested ${newItems.length} new item(s) from deduped.jsonl`);
}

/** Compute the highest DEBT-NNNN numeric suffix from master items */
function getMaxDebtId(masterItems) {
  return masterItems.reduce((max, item) => {
    const id = typeof item.id === "string" ? item.id : "";
    const m = /^DEBT-(\d+)$/.exec(id);
    if (!m) return max;
    const n = Number(m[1]);
    return Number.isFinite(n) ? Math.max(max, n) : max;
  }, 0);
}

/** Parse a single JSONL line, returning the item or null on failure */
function parseJsonlLine(line, lineNum) {
  try {
    return JSON.parse(line.trim());
  } catch {
    console.warn(`  ‚ö†Ô∏è Invalid JSON in deduped.jsonl at line ${lineNum} ‚Äî skipping`);
    return null;
  }
}

/** Read deduped.jsonl lines, returning null if file missing/unreadable */
function readDedupedLines() {
  if (!fs.existsSync(INPUT_FILE)) {
    console.log("  ‚è≠Ô∏è No deduped.jsonl found ‚Äî skipping ingest");
    return null;
  }
  try {
    const content = fs.readFileSync(INPUT_FILE, "utf8");
    return content.split("\n").filter((line) => line.trim());
  } catch (err) {
    const errMsg = err instanceof Error ? err.message : String(err);
    console.warn(`  ‚ö†Ô∏è Cannot read deduped.jsonl (${errMsg}) ‚Äî skipping ingest`);
    return null;
  }
}

// Ingest new items from deduped.jsonl into MASTER (append-only)
function ingestFromDeduped(masterItems) {
  const lines = readDedupedLines();
  if (!lines) return 0;

  const { idMap } = loadExistingItems();
  let nextId = getMaxDebtId(masterItems) + 1;
  const masterIds = new Set(masterItems.map((i) => i.id).filter(Boolean));
  const masterHashes = new Set(masterItems.map((i) => i.content_hash).filter(Boolean));
  const newItems = [];

  for (let i = 0; i < lines.length; i++) {
    const item = parseJsonlLine(lines[i], i + 1);
    if (!item) continue;

    if (item.content_hash && masterHashes.has(item.content_hash)) continue;
    const assignResult = assignStableId(item, idMap, masterIds, nextId);
    if (!assignResult.isNew) continue;

    item.id = assignResult.id;
    masterIds.add(item.id);
    if (item.content_hash) masterHashes.add(item.content_hash);
    nextId++;
    ensureDefaults(item);
    newItems.push(item);
  }

  if (newItems.length > 0) {
    appendNewItems(newItems, masterItems);
  } else {
    console.log("  ‚úÖ No new items in deduped.jsonl");
  }

  return newItems.length;
}

function main() {
  const ingestMode = process.argv.includes("--ingest");

  console.log("üìù Generating TDMS views and final output...\n");

  const items = loadMasterItems();

  // Ensure MASTER items have required defaults for view generation
  for (const item of items) ensureDefaults(item);

  // --ingest: also process deduped.jsonl for new items (used by consolidate-all.js)
  if (ingestMode) {
    ingestFromDeduped(items);
  }

  items.sort(severitySort);

  // Build and write legacy ID mapping
  const legacyMapping = {};
  for (const item of items) {
    if (item.original_id) legacyMapping[item.original_id] = item.id;
    if (item.source_id) legacyMapping[item.source_id] = item.id;
  }
  fs.writeFileSync(LEGACY_MAP_FILE, JSON.stringify(legacyMapping, null, 2));
  console.log(`  ‚úÖ ${LEGACY_MAP_FILE}`);

  // Group and generate views
  const { bySeverity, byCategory, byStatus } = groupItems(items);
  generateViewFiles(items, bySeverity, byCategory, byStatus);

  console.log(`\n‚úÖ All views generated successfully!`);
  console.log(`\nüìä Final Summary:`);
  console.log(`   Total: ${items.length} items`);
  console.log(
    `   S0: ${bySeverity.S0?.length ?? 0}, S1: ${bySeverity.S1?.length ?? 0}, S2: ${bySeverity.S2?.length ?? 0}, S3: ${bySeverity.S3?.length ?? 0}`
  );
}

main();
