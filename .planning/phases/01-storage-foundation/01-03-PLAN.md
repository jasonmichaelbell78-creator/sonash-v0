<!-- prettier-ignore-start -->
**Document Version:** 1.0
**Last Updated:** 2026-02-28
**Status:** ACTIVE
<!-- prettier-ignore-end -->

---

phase: 01-storage-foundation plan: 03 type: execute wave: 3 depends_on:
["01-02"] files_modified:

- test/fixtures/ecosystem-v2/review-full.json
- test/fixtures/ecosystem-v2/review-partial.json
- test/fixtures/ecosystem-v2/review-stub.json
- test/fixtures/ecosystem-v2/retro-full.json
- test/fixtures/ecosystem-v2/retro-partial.json
- test/fixtures/ecosystem-v2/retro-stub.json
- test/fixtures/ecosystem-v2/deferred-item-full.json
- test/fixtures/ecosystem-v2/deferred-item-partial.json
- test/fixtures/ecosystem-v2/deferred-item-stub.json
- test/fixtures/ecosystem-v2/invocation-full.json
- test/fixtures/ecosystem-v2/warning-full.json
- tests/scripts/ecosystem-v2/contracts/review-write.contract.test.ts
- tests/scripts/ecosystem-v2/contracts/deferred-write.contract.test.ts
- tests/scripts/ecosystem-v2/contracts/promotion-input.contract.test.ts
- tests/scripts/ecosystem-v2/contracts/promotion-output.contract.test.ts
- tests/scripts/ecosystem-v2/contracts/effectiveness-input.contract.test.ts
- tests/scripts/ecosystem-v2/contracts/enforcement-generation.contract.test.ts
- tests/scripts/ecosystem-v2/contracts/markdown-render.contract.test.ts
  autonomous: true

must*haves: truths: - "Test fixtures exist for all 3 completeness tiers across
reviews, retros, and deferred-items" - "Every fixture passes its corresponding
Zod schema validation" - "7 contract tests cover all v2 data handoff points (the
original 10 pre-v2 handoffs were reduced to 7 by JSONL-first architecture, which
eliminated markdown-to-JSONL sync, archive-to-JSONL parse, and
archive-to-markdown render)" - "Contract tests pass with full, partial, and stub
fixture data without throwing" artifacts: - path:
"test/fixtures/ecosystem-v2/review-full.json" provides: "Full-tier review
fixture with all fields populated" - path:
"test/fixtures/ecosystem-v2/review-partial.json" provides: "Partial-tier review
fixture with completeness_missing listing absent fields" - path:
"test/fixtures/ecosystem-v2/review-stub.json" provides: "Stub-tier review
fixture with minimal required fields only" - path:
"tests/scripts/ecosystem-v2/contracts/review-write.contract.test.ts" provides:
"Contract: review skill output is valid ReviewRecord" - path:
"tests/scripts/ecosystem-v2/contracts/deferred-write.contract.test.ts" provides:
"Contract: deferred item auto-creation output is valid DeferredItemRecord" -
path: "tests/scripts/ecosystem-v2/contracts/promotion-input.contract.test.ts"
provides: "Contract: promotion script can parse ReviewRecord data" - path:
"tests/scripts/ecosystem-v2/contracts/promotion-output.contract.test.ts"
provides: "Contract: promotion output is valid for enforcement consumption" -
path:
"tests/scripts/ecosystem-v2/contracts/effectiveness-input.contract.test.ts"
provides: "Contract: effectiveness analyzer can parse review + deferred data" -
path:
"tests/scripts/ecosystem-v2/contracts/enforcement-generation.contract.test.ts"
provides: "Contract: auto-generated rules have required structure" - path:
"tests/scripts/ecosystem-v2/contracts/markdown-render.contract.test.ts"
provides: "Contract: JSONL review record can be rendered to markdown"
key_links: - from: "tests/scripts/ecosystem-v2/contracts/*.contract.test.ts" to:
"test/fixtures/ecosystem-v2/\_.json" via: "require() to load fixture data"
pattern: "require.*fixtures.*ecosystem-v2" - from:
"tests/scripts/ecosystem-v2/contracts/\*.contract.test.ts" to:
"scripts/reviews/lib/schemas/index.ts" via: "import schemas for validation"
pattern: "schema\\.parse|safeParse"

---

<objective>
Create test fixtures for all 3 completeness tiers and implement the 7 contract tests that verify data handoff points across the pipeline. The contracts validate data shape compatibility -- even though consuming scripts don't exist until later phases, the contracts prove the data format is correct.

Purpose: STOR-09 (test fixtures for all 3 tiers), TEST-01 (contract tests for
data handoff points), TEST-06 (pipeline functions tested against all fixture
types). This is the safety net that prevents schema drift as later phases build
on top. Output: 11 fixture files + 7 contract test files, all passing.
</objective>

<execution_context> @~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md </execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-storage-foundation/01-RESEARCH.md
@.planning/phases/01-storage-foundation/01-01-SUMMARY.md
@.planning/phases/01-storage-foundation/01-02-SUMMARY.md

Key files: @scripts/reviews/lib/schemas/index.ts (all schemas)
@scripts/reviews/lib/write-jsonl.ts (write utility)
@scripts/reviews/lib/read-jsonl.ts (read utility)
@scripts/reviews/lib/completeness.ts (hasField helper) </context>

<tasks>

<task type="auto">
  <name>Task 1: Create test fixtures for all completeness tiers</name>
  <files>
    test/fixtures/ecosystem-v2/review-full.json
    test/fixtures/ecosystem-v2/review-partial.json
    test/fixtures/ecosystem-v2/review-stub.json
    test/fixtures/ecosystem-v2/retro-full.json
    test/fixtures/ecosystem-v2/retro-partial.json
    test/fixtures/ecosystem-v2/retro-stub.json
    test/fixtures/ecosystem-v2/deferred-item-full.json
    test/fixtures/ecosystem-v2/deferred-item-partial.json
    test/fixtures/ecosystem-v2/deferred-item-stub.json
    test/fixtures/ecosystem-v2/invocation-full.json
    test/fixtures/ecosystem-v2/warning-full.json
  </files>
  <action>
Create directory `test/fixtures/ecosystem-v2/`.

Create 11 fixture JSON files. Each must pass its Zod schema validation. Use
realistic data that mirrors actual PR review ecosystem records.

**Fixture design rules:**

- `full` tier: ALL fields populated, completeness_missing is `[]`, completeness
  is `"full"`
- `partial` tier: Required + standard fields, some nullable fields set to null,
  completeness_missing lists the null fields, completeness is `"partial"`
- `stub` tier: ONLY required BaseRecord fields + entity-specific required
  fields, all optional fields omitted, completeness_missing lists ALL missing
  field names, completeness is `"stub"`
- schema_version: `1` for all fixtures
- Use realistic dates (2025 range), realistic PR numbers, realistic review
  content

**review-full.json example shape:**

```json
{
  "id": "rev-2025-0312-pr389",
  "date": "2025-03-12",
  "schema_version": 1,
  "completeness": "full",
  "completeness_missing": [],
  "origin": {
    "type": "pr-review",
    "pr": 389,
    "round": 1,
    "session": "session-142"
  },
  "title": "Firebase Auth Migration Review",
  "pr": 389,
  "source": "archive-12.md",
  "total": 8,
  "fixed": 5,
  "deferred": 2,
  "rejected": 1,
  "patterns": ["error-sanitization", "missing-try-catch"],
  "learnings": ["Always wrap auth calls in try-catch"],
  "severity_breakdown": { "critical": 1, "major": 3, "minor": 3, "trivial": 1 },
  "per_round_detail": [],
  "rejection_analysis": [],
  "ping_pong_chains": []
}
```

**review-partial.json:** Same structure but severity_breakdown,
per_round_detail, rejection_analysis, ping_pong_chains set to null.
completeness_missing:
`["severity_breakdown", "per_round_detail", "rejection_analysis", "ping_pong_chains"]`,
completeness: `"partial"`.

**review-stub.json:** Only BaseRecord fields + no optional fields at all.
completeness_missing lists ALL optional field names. completeness: `"stub"`.

Apply same pattern for retro and deferred-item fixtures. Invocation and warning
only need full-tier fixtures (they have simpler schemas).

Validate: After creating all fixtures, write a quick verification that each
fixture passes its corresponding schema's parse(). </action> <verify> Run a Node
script or test that loads each fixture and runs schema.parse() on it -- all 11
must pass. All fixture files are valid JSON (no trailing commas, no comments).
</verify> <done>11 fixture files exist covering all 3 completeness tiers for
reviews, retros, deferred-items, plus full-tier for invocations and warnings.
All pass Zod validation.</done> </task>

<task type="auto">
  <name>Task 2: Create 7 contract tests for data handoff points</name>
  <files>
    tests/scripts/ecosystem-v2/contracts/review-write.contract.test.ts
    tests/scripts/ecosystem-v2/contracts/deferred-write.contract.test.ts
    tests/scripts/ecosystem-v2/contracts/promotion-input.contract.test.ts
    tests/scripts/ecosystem-v2/contracts/promotion-output.contract.test.ts
    tests/scripts/ecosystem-v2/contracts/effectiveness-input.contract.test.ts
    tests/scripts/ecosystem-v2/contracts/enforcement-generation.contract.test.ts
    tests/scripts/ecosystem-v2/contracts/markdown-render.contract.test.ts
  </files>
  <action>
Create directory `tests/scripts/ecosystem-v2/contracts/`.

Each contract test verifies a data handoff point: "the data produced by stage N
is consumable by stage N+1". Since consuming scripts don't exist yet (Phase 3+),
contracts test the DATA SHAPE using schemas and fixtures.

Pattern for every contract test:

- Load fixture data from `test/fixtures/ecosystem-v2/`
- Parse through the producer schema
- Assert the output has the fields the consumer needs
- Test with full, partial, and stub fixtures -- NONE should throw
- Use hasField() to demonstrate correct consumer behavior with partial/stub data

**1. review-write.contract.test.ts** (Skill -> JSONL):

- Producer: pr-review skill, Consumer: reviews.jsonl
- Test: full/partial/stub review fixtures pass ReviewRecord.parse()
- Test: written record round-trips through JSON.stringify/parse
- Test: origin.type is always a valid enum value (not free-text)

**2. deferred-write.contract.test.ts** (Review -> Deferred):

- Producer: auto-deferred creation, Consumer: deferred-items.jsonl
- Test: full/partial/stub deferred fixtures pass DeferredItemRecord.parse()
- Test: deferred record has review_id linking back to source review
- Test: status defaults to "open" when not specified

**3. promotion-input.contract.test.ts** (JSONL -> Promotion Script):

- Consumer: promotion script reads reviews.jsonl
- Test: readValidatedJsonl with review fixtures returns valid records
- Test: full records have patterns array accessible for recurrence detection
- Test: partial records with hasField("patterns") returns false when patterns in
  completeness_missing
- Test: stub records don't crash promotion logic (graceful skip)

**4. promotion-output.contract.test.ts** (Promotion -> CODE_PATTERNS):

- Producer: promotion script
- Test: Define a PromotionResult shape inline (pattern_name, recurrence_count,
  source_reviews, rule_type)
- Test: A valid PromotionResult can be constructed from review fixture data
- Test: PromotionResult with missing optional fields still valid

**5. effectiveness-input.contract.test.ts** (JSONL -> Effectiveness):

- Consumer: effectiveness analyzer reads reviews + deferred-items
- Test: review fixtures have total/fixed/deferred fields for computation
- Test: deferred fixtures have severity and status for tracking
- Test: hasField() correctly identifies which records have computable metrics
- Test: partial/stub records don't produce NaN when metrics are missing
  (consumer must check hasField)

**6. enforcement-generation.contract.test.ts** (Promotion -> Rules):

- Producer: auto-rule generator
- Test: Define an EnforcementRule shape inline (pattern_id, rule_type:
  "semgrep"|"eslint"|"regex", rule_content, auto_generated: boolean)
- Test: Valid rule can be constructed
- Test: rule_type enum is one of the valid mechanisms

**7. markdown-render.contract.test.ts** (JSONL -> Markdown):

- Consumer: markdown renderer reads reviews.jsonl
- Test: full review fixture has all fields needed for complete markdown render
- Test: partial review fixture can produce markdown with "[data not available]"
  placeholders where hasField returns false
- Test: stub review fixture produces minimal valid markdown (just date + id)

IMPORTANT:

- These are CONTRACT tests, not unit tests. They verify data shape compatibility
  between pipeline stages.
- Use `describe('Contract: X -> Y', ...)` naming convention
- Each contract tests all 3 tiers (full/partial/stub) where applicable
- Inline any shapes that don't have formal schemas yet (PromotionResult,
  EnforcementRule) -- these schemas will be formalized in later phases </action>
  <verify> Run: `npx tsc -p tsconfig.test.json` -- exits 0. Run:
  `node --test dist-tests/tests/scripts/ecosystem-v2/contracts/*.contract.test.js`
  -- all pass. Count: At least 35 test cases across the 7 contract test files.
  </verify> <done>7 contract test files pass with all 3 completeness tiers. Data
  handoff points are validated -- full records carry all data, partial records
  degrade gracefully, stub records don't crash consumers. TEST-01 and TEST-06
  satisfied for Phase 1 scope.</done> </task>

</tasks>

<verification>
1. `npx tsc -p tsconfig.test.json` exits 0
2. `node --test dist-tests/tests/scripts/ecosystem-v2/contracts/*.contract.test.js` -- all pass
3. `node --test dist-tests/tests/scripts/ecosystem-v2/*.test.js` -- Plan 02 tests still pass
4. All 11 fixture files are valid JSON
5. No fixture has completeness: "full" with non-empty completeness_missing
6. No fixture has completeness: "stub" with empty completeness_missing
7. At least 35 contract test cases total
</verification>

<success_criteria>

- 11 fixture files cover all 3 completeness tiers (STOR-09)
- 7 contract tests cover 7 of 10 handoff points (TEST-01 partial -- 3 handoffs
  eliminated by v2 JSONL-first architecture: markdown-to-JSONL sync,
  archive-to-JSONL parse, archive-to-markdown render)
- All tests pass with full/partial/stub data without throwing (TEST-06)
- Contracts define the data shape contract for Phase 2+ consumers
- Total test count for Phase 1: 60+ tests across 11 test files
  </success_criteria>

<output>
After completion, create `.planning/phases/01-storage-foundation/01-03-SUMMARY.md`
</output>
