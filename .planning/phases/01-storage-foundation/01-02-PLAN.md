<!-- prettier-ignore-start -->
**Document Version:** 1.0
**Last Updated:** 2026-02-28
**Status:** ACTIVE
<!-- prettier-ignore-end -->

---

phase: 01-storage-foundation plan: 02 type: execute wave: 2 depends_on:
["01-01"] files_modified:

- scripts/reviews/lib/write-jsonl.ts
- scripts/reviews/lib/read-jsonl.ts
- scripts/reviews/lib/completeness.ts
- tests/scripts/ecosystem-v2/write-jsonl.test.ts
- tests/scripts/ecosystem-v2/read-jsonl.test.ts
- tests/scripts/ecosystem-v2/completeness.test.ts
- tests/scripts/ecosystem-v2/schemas.test.ts autonomous: true

must_haves: truths: - "appendRecord() validates against Zod schema and rejects
invalid records with ZodError" - "appendRecord() uses safe-fs.js withLock and
symlink guards for actual file writes" - "readValidatedJsonl() returns {valid,
warnings} and never throws on malformed records" - "hasField() returns false
when field is in completeness_missing, true otherwise" - "All utilities have
passing tests" artifacts: - path: "scripts/reviews/lib/write-jsonl.ts" provides:
"appendRecord() validated write utility" exports: ["appendRecord"] - path:
"scripts/reviews/lib/read-jsonl.ts" provides: "readValidatedJsonl() graceful
reader" exports: ["readValidatedJsonl"] - path:
"scripts/reviews/lib/completeness.ts" provides: "hasField() helper and tier
validation" exports: ["hasField", "validateCompleteness"] - path:
"tests/scripts/ecosystem-v2/schemas.test.ts" provides: "Schema validation tests
for all 5 entity types" - path: "tests/scripts/ecosystem-v2/write-jsonl.test.ts"
provides: "Write utility tests" - path:
"tests/scripts/ecosystem-v2/read-jsonl.test.ts" provides: "Read utility tests" -
path: "tests/scripts/ecosystem-v2/completeness.test.ts" provides: "Completeness
helper tests" key_links: - from: "scripts/reviews/lib/write-jsonl.ts" to:
"scripts/lib/safe-fs.js" via: "require() for withLock, safeAppendFileSync,
isSafeToWrite" pattern: "require.*safe-fs" - from:
"scripts/reviews/lib/write-jsonl.ts" to: "scripts/reviews/lib/schemas/index.ts"
via: "import schema for validation" pattern: "schema\\.parse" - from:
"scripts/reviews/lib/read-jsonl.ts" to: "scripts/lib/read-jsonl.js" via:
"require() for raw JSONL reading" pattern: "require.*read-jsonl" - from:
"scripts/reviews/lib/read-jsonl.ts" to: "scripts/reviews/lib/schemas/index.ts"
via: "safeParse for validation" pattern: "schema\\.safeParse"

---

<objective>
Build the write utility, read utility, and completeness helper that form the data access layer for all JSONL operations. Then write comprehensive tests for all schemas and utilities.

Purpose: STOR-07 (single write utility), STOR-06 (read-time validation), STOR-08
(hasField helper). These utilities enforce data integrity -- no JSONL write
happens without schema validation, no read crashes on bad data. Output: 3
utility modules + 4 test files, all passing. </objective>

<execution_context> @~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md </execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-storage-foundation/01-RESEARCH.md
@.planning/phases/01-storage-foundation/01-01-SUMMARY.md

Key existing files: @scripts/lib/safe-fs.js (compose on top of -- withLock,
safeAppendFileSync, isSafeToWrite) @scripts/lib/read-jsonl.js (wrap with Zod
validation) @scripts/reviews/lib/schemas/index.ts (schemas from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create write-jsonl, read-jsonl, and completeness utilities</name>
  <files>
    scripts/reviews/lib/write-jsonl.ts
    scripts/reviews/lib/read-jsonl.ts
    scripts/reviews/lib/completeness.ts
  </files>
  <action>
1. Create `scripts/reviews/lib/write-jsonl.ts`:
   - Import `z` from `"zod"`
   - Import `path` and `fs` from node
   - Use `require()` to load `safe-fs.js` (it's a JS module): `const { withLock, isSafeToWrite } = require(path.resolve(__dirname, '../../lib/safe-fs.js'))`
   - Export `appendRecord<T>(filePath: string, record: T, schema: z.ZodType<T>): void`
     - Step 1: Check `isSafeToWrite(filePath)` -- throw Error if false (symlink guard)
     - Step 2: `schema.parse(record)` -- throws ZodError if invalid (this IS the rejection mechanism)
     - Step 3: `const line = JSON.stringify(validated) + '\n'`
     - Step 4: `withLock(filePath, () => { fs.appendFileSync(filePath, line, 'utf8') })`
     - Ensure parent directory exists before writing: `fs.mkdirSync(path.dirname(filePath), { recursive: true })`
   - Do NOT wrap in try/catch -- let ZodError propagate to caller (callers decide how to handle)
   - Do NOT handle MASTER_DEBT.jsonl -- this utility is ONLY for the 5 ecosystem JSONL files

2. Create `scripts/reviews/lib/read-jsonl.ts`:
   - Import `z` from `"zod"`
   - Use `require()` to load `read-jsonl.js`:
     `const { readJsonl } = require(path.resolve(__dirname, '../../lib/read-jsonl.js'))`
   - Export interface `ReadResult<T> = { valid: T[]; warnings: string[] }`
   - Export
     `readValidatedJsonl<T>(filePath: string, schema: z.ZodType<T>, options?: { quiet?: boolean }): ReadResult<T>`
     - Call `readJsonl(filePath, { safe: true })` to get raw records (returns []
       if file missing)
     - For each raw record, call `schema.safeParse(record)`
     - Success: push to `valid` array
     - Failure: push formatted warning to `warnings` array (include record id if
       available, and Zod error message)
     - If `!options?.quiet`, log each warning with `console.warn()`
     - NEVER throw -- always return results even if all records are malformed
   - Return `{ valid, warnings }`

3. Create `scripts/reviews/lib/completeness.ts`:
   - Export
     `hasField(record: { completeness_missing?: string[] }, field: string): boolean`
     - If `record.completeness_missing` includes `field`, return `false`
     - Otherwise return `true`
     - This correctly handles: field present (true), field null but not in
       missing (true -- null is a valid value), field in completeness_missing
       (false -- data was never captured)
   - Export
     `validateCompleteness(record: { completeness: string; completeness_missing?: string[] }, requiredForTier: Record<string, string[]>): string[]` -
     Given a record and a mapping of tier -> required field names, check that
     the record's tier requirements are met - Return array of violation messages
     (empty = valid) - Example: a "full" record with fields in
     completeness_missing is a violation </action> <verify> Run:
     `npx tsc -p scripts/reviews/tsconfig.json --noEmit` -- exits 0. </verify>
     <done>Three utility modules compile and export the correct functions.
     write-jsonl composes on safe-fs.js, read-jsonl wraps read-jsonl.js with Zod
     safeParse, completeness provides hasField().</done> </task>

<task type="auto">
  <name>Task 2: Create tests for schemas, write-jsonl, read-jsonl, and completeness</name>
  <files>
    tests/scripts/ecosystem-v2/schemas.test.ts
    tests/scripts/ecosystem-v2/write-jsonl.test.ts
    tests/scripts/ecosystem-v2/read-jsonl.test.ts
    tests/scripts/ecosystem-v2/completeness.test.ts
  </files>
  <action>
Create directory `tests/scripts/ecosystem-v2/`.

Follow the existing test pattern from `tests/scripts/safe-fs.test.ts`:

- Use `import assert from 'node:assert/strict'`
- Use `import { test, describe, beforeEach, afterEach } from 'node:test'`
- Use `require()` to load compiled JS modules from dist-tests

For all test files, use a shared PROJECT_ROOT resolution pattern.

1. `schemas.test.ts` -- Test all 5 schemas:
   - For each schema (ReviewRecord, RetroRecord, DeferredItemRecord,
     InvocationRecord, WarningRecord):
     - Test: valid full record passes parse()
     - Test: missing required field (id, date, schema_version, completeness,
       origin) throws ZodError
     - Test: invalid date format throws ZodError
     - Test: invalid completeness tier throws ZodError
     - Test: invalid origin.type throws ZodError
   - Test: BaseRecord.parse() works independently
   - Test: SCHEMA_MAP has exactly 5 entries with correct keys
   - Use inline fixture data (no external fixture files yet -- those come in
     Plan 03)

2. `write-jsonl.test.ts` -- Test write utility:
   - Use `os.tmpdir()` + `path.join()` for temp files, clean up in afterEach
   - Test: appendRecord with valid record writes JSON line to file
   - Test: appendRecord with invalid record throws ZodError and does NOT write
     to file
   - Test: appendRecord creates parent directory if missing
   - Test: multiple appendRecord calls produce multiple lines
   - Test: written JSON can be parsed back and matches original (round-trip)

3. `read-jsonl.test.ts` -- Test read utility:
   - Use temp files with pre-written content
   - Test: readValidatedJsonl with all valid records returns all in `valid`,
     empty `warnings`
   - Test: readValidatedJsonl with one malformed record returns it in
     `warnings`, others in `valid`
   - Test: readValidatedJsonl with missing file returns
     `{ valid: [], warnings: [] }`
   - Test: readValidatedJsonl with quiet option suppresses console.warn (use
     mock or spy)
   - Test: readValidatedJsonl NEVER throws, even with completely garbage input

4. `completeness.test.ts` -- Test completeness helper:
   - Test: hasField returns true when field NOT in completeness_missing
   - Test: hasField returns true when completeness_missing is undefined
   - Test: hasField returns true when completeness_missing is empty array
   - Test: hasField returns false when field IS in completeness_missing
   - Test: hasField returns true for field with null value that is NOT in
     completeness_missing (null is valid data)
   - Test: validateCompleteness returns violations for full-tier record with
     missing fields

IMPORTANT:

- Compile before running: `npx tsc -p tsconfig.test.json`
- Run tests: `node --test dist-tests/tests/scripts/ecosystem-v2/*.test.js`
- Each test file should be self-contained -- no shared test helpers needed yet
- Clean up temp files in afterEach blocks </action> <verify> Run:
  `npx tsc -p tsconfig.test.json` -- exits 0. Run:
  `node --test dist-tests/tests/scripts/ecosystem-v2/*.test.js` -- all tests
  pass. Count: At least 25 test cases across the 4 files. </verify> <done>All 4
  test files compile and pass. Schema validation rejects bad data (STOR-01).
  Write utility rejects invalid records (STOR-07). Read utility never throws
  (STOR-06). hasField() distinguishes null from missing (STOR-08).</done>
  </task>

</tasks>

<verification>
1. `npx tsc -p scripts/reviews/tsconfig.json --noEmit` exits 0
2. `npx tsc -p tsconfig.test.json` exits 0
3. `node --test dist-tests/tests/scripts/ecosystem-v2/*.test.js` -- all pass
4. write-jsonl.ts imports from safe-fs.js (grep confirms)
5. read-jsonl.ts uses safeParse (grep confirms)
6. No direct fs.appendFile calls targeting .jsonl files outside write-jsonl.ts:
   Run: `grep -rn 'fs\.appendFile\|fs\.appendFileSync' scripts/reviews/ --include='*.ts' | grep -v write-jsonl.ts`
   -- must return empty (exit code 1). If any matches found, direct JSONL writes are bypassing the validated write utility.
</verification>

<success_criteria>

- appendRecord() validates via Zod and rejects invalid records (STOR-07)
- readValidatedJsonl() logs warnings for malformed records and continues
  (STOR-06)
- hasField() correctly handles null vs completeness_missing (STOR-08)
- 25+ test cases pass covering schemas, write, read, and completeness (TEST-05)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-storage-foundation/01-02-SUMMARY.md`
</output>
