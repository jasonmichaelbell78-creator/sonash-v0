---
phase: 02-backfill-data-migration
plan: 02
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - scripts/reviews/backfill-reviews.ts
  - scripts/reviews/__tests__/backfill-reviews.test.ts
  - data/ecosystem-v2/reviews.jsonl
  - data/ecosystem-v2/retros.jsonl
autonomous: true

must_haves:
  truths:
    - "reviews.jsonl contains entries for all 406 reviews (minus 64
      known-skipped), each passing Zod validation"
    - "The 3 archive overlaps produce no duplicate records (overlaps resolved by
      content richness, KNOWN_DUPLICATE_IDS get disambiguated IDs)"
    - "Known-skipped IDs generate no records, not even stubs"
    - "Running the script twice produces identical output (idempotent)"
    - "Retro sections in archives produce RetroRecord entries in retros.jsonl"
    - "Migration of v1 .claude/state/reviews.jsonl records into v2 format
      succeeds with zero validation errors"
  artifacts:
    - path: "scripts/reviews/backfill-reviews.ts"
      provides:
        "Idempotent backfill orchestrator reading all 13 archives + active log"
      min_lines: 80
    - path: "scripts/reviews/__tests__/backfill-reviews.test.ts"
      provides: "Integration tests for backfill orchestrator"
      min_lines: 60
    - path: "data/ecosystem-v2/reviews.jsonl"
      provides: "All 406 reviews as validated v2 JSONL records"
    - path: "data/ecosystem-v2/retros.jsonl"
      provides: "Retro records extracted from archives"
  key_links:
    - from: "scripts/reviews/backfill-reviews.ts"
      to: "scripts/reviews/lib/parse-review.ts"
      via: "imports parser functions"
      pattern: "import.*parseArchiveFile|parseTableArchive|toV2ReviewRecord.*from.*parse-review"
    - from: "scripts/reviews/backfill-reviews.ts"
      to: "scripts/reviews/lib/write-jsonl.ts"
      via: "uses appendRecord for validated JSONL writes"
      pattern: "import.*appendRecord.*from.*write-jsonl"
    - from: "scripts/reviews/backfill-reviews.ts"
      to: "docs/archive/REVIEWS_*.md"
      via: "reads all 13 archive files as input"
      pattern: "REVIEWS_.*\\.md"
    - from: "scripts/reviews/backfill-reviews.ts"
      to: "scripts/reviews/lib/schemas/retro.ts"
      via: "imports RetroRecord schema for retro extraction and validation"
      pattern: "import.*RetroRecord.*from.*schemas"
---

<!-- prettier-ignore-start -->
**Document Version:** 1.1
**Last Updated:** 2026-02-28
**Status:** ACTIVE
<!-- prettier-ignore-end -->

<objective>
Build the idempotent backfill orchestrator that reads all 13 archives + active log, resolves overlaps and gaps, and writes validated v2 JSONL.

Purpose: This is the core data migration -- transforms 2 months of
inconsistently formatted markdown review history into a clean, schema-validated
JSONL dataset that becomes the foundation for all subsequent pipeline work.
Output: `backfill-reviews.ts` script, integration tests, and populated
`data/ecosystem-v2/reviews.jsonl` + `retros.jsonl`. </objective>

<execution_context> @~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md </execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backfill-data-migration/02-RESEARCH.md
@.planning/phases/02-backfill-data-migration/02-01-SUMMARY.md
@scripts/reviews/lib/schemas/review.ts
@scripts/reviews/lib/schemas/shared.ts
@scripts/reviews/lib/schemas/retro.ts
@scripts/reviews/lib/write-jsonl.ts
@scripts/reviews/lib/read-jsonl.ts
@scripts/sync-reviews-to-jsonl.js
@scripts/check-review-archive.js
@docs/AI_REVIEW_LEARNINGS_LOG.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backfill-reviews.ts core orchestrator with overlap resolution and output</name>
  <files>scripts/reviews/backfill-reviews.ts</files>
  <action>
Create `scripts/reviews/backfill-reviews.ts` as an idempotent backfill script.

**Input sources (ordered by ID range):**

```
docs/archive/REVIEWS_1-40.md       (heading format)
docs/archive/REVIEWS_42-60.md      (heading format)
docs/archive/REVIEWS_61-100.md     (heading format)
docs/archive/REVIEWS_101-136.md    (TABLE format -- use parseTableArchive)
docs/archive/REVIEWS_137-179.md    (heading format)
docs/archive/REVIEWS_180-201.md    (heading format)
docs/archive/REVIEWS_202-212.md    (heading format)
docs/archive/REVIEWS_213-284.md    (heading format)
docs/archive/REVIEWS_285-346.md    (heading format)
docs/archive/REVIEWS_347-369.md    (heading format)
docs/archive/REVIEWS_354-357.md    (heading format)
docs/archive/REVIEWS_358-388.md    (heading format + retro sections)
docs/archive/REVIEWS_385-393.md    (heading format)
docs/AI_REVIEW_LEARNINGS_LOG.md    (active log, heading format)
```

**Core algorithm (steps 1-8):**

1. Read all 14 source files, parse each with appropriate parser (heading vs
   table)
2. Collect all ParsedEntry objects into `Map<number, ParsedEntry[]>` keyed by
   reviewNumber
3. **Overlap resolution:**
   - For KNOWN_DUPLICATE_IDS (366-369): keep BOTH copies, assign IDs `rev-{N}-a`
     (from earlier archive) and `rev-{N}-b` (from later archive). Set
     origin.session to identify which archive each came from.
   - For IDs 92-100 (appear in both REVIEWS_61-100 heading format AND
     REVIEWS_101-136 table format): prefer heading format (richer content)
   - For other duplicates: keep the entry with most rawLines (richest content)
4. **Gap handling:**
   - Filter out KNOWN_SKIPPED_IDS -- these produce NO records
   - For IDs that are genuinely missing (not in any archive, not in skip list):
     DO NOT create stub records. Just log them.
5. **Convert each resolved ParsedEntry to v2 ReviewRecord** via
   toV2ReviewRecord()
6. **Retro extraction:** Scan archives for `### PR #N Retrospective` sections.
   Parse into RetroRecord objects (importing RetroRecord schema from
   schemas/retro.ts). Only create records for explicit retro sections, not
   fabricated ones.
7. **V1 migration:** Read `.claude/state/reviews.jsonl` (50 v1 records with
   numeric IDs). Convert each to v2 format. For any review ID already captured
   from archives, prefer the archive version (more complete). Only add v1
   records that cover review IDs not found in archives (likely recent reviews
   #394+).
8. **Write output:**
   - Create `data/ecosystem-v2/` directory if not exists
   - Write `data/ecosystem-v2/reviews.jsonl` -- one JSON line per record, sorted
     by reviewNumber ascending
   - Write `data/ecosystem-v2/retros.jsonl` -- retro records sorted by date
   - Do NOT use appendRecord for bulk write (that's for single-record appends).
     Write the entire file atomically: build array of records, JSON.stringify
     each line, join with newlines, write file.
   - After writing: validate every record by reading back and parsing through
     Zod schema
   - Print summary: Total records, by completeness tier, overlaps resolved,
     retros found, v1 records migrated, validation errors (should be 0)

**Important:**

- Use `findProjectRoot()` walk-up pattern for reliable path resolution (per
  01-02 decision)
- Wrap ALL file reads in try/catch (per CLAUDE.md anti-pattern: file reads must
  be wrapped)
- The script must be runnable via:
  `cd scripts/reviews && npx tsc && node dist/backfill-reviews.js`
- Make it idempotent: running twice overwrites output file with identical
  content </action> <verify> Run: `cd scripts/reviews && npx tsc --noEmit` --
  compiles cleanly. Run:
  `cd scripts/reviews && npx tsc && node dist/backfill-reviews.js` -- produces
  output with summary. Check: `wc -l data/ecosystem-v2/reviews.jsonl` -- should
  have 340+ lines (406 reviews minus 64 skipped, plus a few disambiguated
  duplicates). Check: each line of reviews.jsonl is valid JSON and passes
  ReviewRecord schema. </verify> <done> backfill-reviews.ts reads all 13
  archives + active log + v1 state, resolves overlaps, writes validated
  reviews.jsonl and retros.jsonl. Running twice produces identical output. Zero
  Zod validation errors on output. </done> </task>

<task type="auto">
  <name>Task 2: Add BKFL-04/05/06 data corrections to backfill script</name>
  <files>scripts/reviews/backfill-reviews.ts</files>
  <action>
Add three data correction concerns to `backfill-reviews.ts` as a post-processing
step after the core backfill (Task 1) but before final file write:

**BKFL-04 (retro arithmetic tagging):** When creating RetroRecord objects,
compute:

- `metrics.total_findings` from the associated review's total count
- `metrics.fix_rate` from fixed/total
- `metrics.pattern_recurrence` = 0 (set to 0 for backfill; real recurrence
  computed in Phase 3)

This requires looking up the associated ReviewRecord by PR number to get the
total/fixed counts. If the associated review is not found, set metrics to null
and log a warning.

**BKFL-05 (consolidation counter fix):** Read `scripts/consolidation.json` (or
wherever consolidation state lives). Verify the "number" field matches actual
review count. If mismatch, log a warning with correct count. Do not auto-fix --
just report. This is a verification step that runs after all records are
collected but before write.

**BKFL-06 (pattern corrections):** In post-processing, check for patterns #5 and
#13 content errors referenced in requirements. If the specific errors are
identifiable in the parsed records (e.g., wrong pattern text, misattributed
findings), apply corrections to the affected ReviewRecord objects. If not
identifiable without more context, log them as items to investigate and move on.

**Print additional summary lines** for each BKFL concern:

- BKFL-04: "Retro metrics computed for N retro records (M missing associated
  review)"
- BKFL-05: "Consolidation counter: expected=N, actual=M" (or "match" if correct)
- BKFL-06: "Pattern corrections: N applied, M flagged for investigation"
  </action> <verify> Run:
  `cd scripts/reviews && npx tsc && node dist/backfill-reviews.js` -- summary
  output includes BKFL-04/05/06 status lines. Verify retros.jsonl entries have
  metrics fields populated where associated reviews exist. Verify consolidation
  counter check runs without error. </verify> <done> BKFL-04: RetroRecord
  objects have computed metrics (total_findings, fix_rate, pattern_recurrence).
  BKFL-05: Consolidation counter is checked and mismatch warning logged if
  applicable. BKFL-06: Known pattern errors are corrected or flagged. All three
  concerns are addressed and reported in script summary output. </done> </task>

<task type="auto">
  <name>Task 3: Create backfill integration tests</name>
  <files>scripts/reviews/__tests__/backfill-reviews.test.ts</files>
  <action>
Create `scripts/reviews/__tests__/backfill-reviews.test.ts` with integration tests:

1. **Overlap resolution test:** Create mock entries where same reviewNumber
   appears from two different sources. Verify only one record emitted (the
   richer one). For KNOWN_DUPLICATE_IDS, verify both are emitted with `-a` and
   `-b` suffixes.

2. **Known-skipped exclusion test:** Feed entries including IDs from
   KNOWN_SKIPPED_IDS set. Verify they produce no output records.

3. **Completeness tier distribution test:** Parse a mix of heading entries
   (should be full/partial) and table entries (should be stub). Verify tier
   assignment.

4. **V1 migration merge test:** Create mock v1 records (numeric IDs) and mock
   archive entries. Verify archive entries take precedence for overlapping IDs,
   v1-only records (recent reviews) are included.

5. **Retro extraction test:** Create mock archive content with
   `### PR #N Retrospective` section. Verify RetroRecord is created with correct
   PR linkage and metrics computation (BKFL-04 -- metrics.total_findings and
   metrics.fix_rate populated from associated review data).

6. **Idempotency test:** Run the resolution logic twice on same input. Verify
   output is identical (compare JSON-serialized arrays).

7. **BKFL-05 consolidation counter test:** Mock consolidation.json with a
   mismatched count. Verify warning is logged with expected vs actual values.

8. **BKFL-06 pattern correction test:** Create mock record with known pattern
   error. Verify correction is applied (or flagged if not auto-correctable).

**Testing approach:** Extract the core logic (overlap resolution, v1 merge,
retro extraction, data corrections) into testable functions exported from
backfill-reviews.ts (or a separate lib file). Tests call these functions
directly with mock data rather than reading real archive files (keeps tests fast
and deterministic).

Follow project patterns: compile with tsc, run with `node --test` from
dist-tests. </action> <verify> Run:
`cd scripts/reviews && npx tsc && node --test dist-tests/__tests__/backfill-reviews.test.js`
-- all tests pass. </verify> <done> Integration tests cover overlap resolution,
skip-list exclusion, completeness tiers, v1 migration merge, retro extraction
with BKFL-04 metrics, BKFL-05 consolidation counter check, BKFL-06 pattern
corrections, and idempotency. All pass. </done> </task>

</tasks>

<verification>
1. `cd scripts/reviews && npx tsc --noEmit` passes
2. `cd scripts/reviews && npx tsc && node dist/backfill-reviews.js` runs successfully with summary output
3. Summary output includes BKFL-04 retro metrics status, BKFL-05 consolidation counter check, BKFL-06 pattern correction report
4. `data/ecosystem-v2/reviews.jsonl` exists with 340+ records, all passing Zod validation
5. `data/ecosystem-v2/retros.jsonl` exists with retro records containing computed metrics
6. No duplicate review IDs in reviews.jsonl (except disambiguated 366-369 with -a/-b suffixes)
7. `node --test dist-tests/__tests__/backfill-reviews.test.js` passes all tests including BKFL-04/05/06 coverage
8. Running backfill twice produces identical output files
</verification>

<success_criteria> reviews.jsonl contains entries for all 406 reviews (minus 64
known-skipped IDs), each passing Zod validation. The 3 archive overlaps produce
no unintended duplicates. KNOWN_DUPLICATE_IDS (366-369) are disambiguated. v1
state records are migrated. retros.jsonl contains explicitly found retrospective
records with computed metrics (BKFL-04). Consolidation counter is verified
(BKFL-05). Known pattern errors are corrected or flagged (BKFL-06). Migration
script produces zero Zod validation errors on output. Requirements BKFL-01,
BKFL-02, BKFL-04, BKFL-05, BKFL-06, BKFL-07 satisfied. </success_criteria>

<output>
After completion, create `.planning/phases/02-backfill-data-migration/02-02-SUMMARY.md`
</output>
