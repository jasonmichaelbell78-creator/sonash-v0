name: Auto-Label Review Tier

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  assign-tier:
    runs-on: ubuntu-latest
    name: Assign Review Tier Label

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v46
        with:
          files: |
            **/*.ts
            **/*.tsx
            **/*.js
            **/*.jsx
            **/*.json
            **/*.md
            **/*.yml
            **/*.yaml
            **/*.rules
          # Use newline separator for robust filename handling (supports spaces)
          separator: "\n"

      - name: Run tier assignment script
        id: assign-tier
        run: |
          # Get list of changed files (newline-separated from action)
          FILES="${{ steps.changed-files.outputs.all_changed_files }}"

          # Run tier assignment (will be implemented in Phase 1)
          # For now, output a placeholder result
          echo "Changed files:"
          printf '%s\n' "$FILES"

          # TODO: Uncomment when script is ready (preserves spaces/newlines)
          # RESULT=$(printf '%s\n' "$FILES" | node scripts/assign-review-tier.js --stdin)
          # echo "tier=$RESULT" >> "$GITHUB_OUTPUT"

          # TEMPORARY PLACEHOLDER: Remove when scripts/assign-review-tier.js is integrated
          # This logic duplicates TIER_RULES in assign-review-tier.js
          # Use printf to safely pipe newline-separated files to grep ^ anchors
          if printf '%s\n' "$FILES" | grep -qE '^(\.github/workflows/|firebase\.json$|package\.json$)'; then
            TIER=4
          elif printf '%s\n' "$FILES" | grep -qE '(firestore\.rules$|functions/src/auth/|middleware/)'; then
            TIER=3
          elif printf '%s\n' "$FILES" | grep -qE '^(app/|components/|lib/|hooks/)'; then
            TIER=2
          elif printf '%s\n' "$FILES" | grep -qE '(\.test\.(ts|tsx)$|^docs/.*\.md$)'; then
            TIER=1
          else
            TIER=0
          fi

          echo "tier=$TIER" >> "$GITHUB_OUTPUT"
          echo "Assigned tier: $TIER"

      - name: Remove existing tier labels
        uses: actions/github-script@v7
        with:
          script: |
            const labels = ['tier-0', 'tier-1', 'tier-2', 'tier-3', 'tier-4'];
            const currentLabels = context.payload.pull_request.labels.map(l => l.name);

            for (const label of labels) {
              if (!currentLabels.includes(label)) continue;

              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  name: label
                });
              } catch (e) {
                // Avoid failing the job if the label is already gone / not removable
                const status = e?.status;
                if (status !== 404 && status !== 422) throw e;
              }
            }

      - name: Add tier label
        uses: actions/github-script@v7
        with:
          script: |
            const tierRaw = '${{ steps.assign-tier.outputs.tier }}';
            const tier = Number.parseInt(tierRaw, 10);

            // Validate tier output is a valid number 0-4
            if (!Number.isFinite(tier) || tier < 0 || tier > 4) {
              core.setFailed(`Invalid tier output: "${tierRaw}". Expected 0-4.`);
              return;
            }

            const labelName = `tier-${tier}`;

            // Add tier label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: [labelName]
            });

            // Add comment explaining tier
            const tierDescriptions = {
              0: 'Tier 0 (Exempt): Auto-merge eligible. No human review required.',
              1: 'Tier 1 (Light): AI review only. Human review optional.',
              2: 'Tier 2 (Standard): AI + 1 human review required.',
              3: 'Tier 3 (Heavy): AI + 2 human reviews + security checklist required.',
              4: 'Tier 4 (Critical): RFC + Multi-AI + all codebase owners required.'
            };

            const tierInfo = tierDescriptions[tier] || 'Unknown tier';

            // Tier-specific details (avoids complex inline conditionals in template)
            const tierDetails = {
              0: '- This PR is eligible for auto-merge after CI passes\n- Estimated merge time: 4 hours',
              1: '- AI review will run automatically\n- Human review is optional\n- Estimated merge time: 1-2 days',
              2: '- AI review will run automatically\n- 1 human approval required\n- Estimated merge time: 2 days',
              3: '- Exhaustive AI review will run\n- 2 human approvals required (1 must be codebase owner)\n- Security checklist must be completed\n- Estimated merge time: 3-5 days',
              4: '- RFC document required\n- Multi-AI review (CodeRabbit + Qodo + custom)\n- All codebase owners must approve\n- Staging deployment + testing required\n- Estimated merge time: 1-2 weeks'
            };

            const comment = [
              `## üè∑Ô∏è Review Tier Assigned: **Tier ${tier}**`,
              '',
              tierInfo,
              '',
              '**What this means:**',
              tierDetails[tier] || '',
              '',
              '**Review Policy:** See [REVIEW_POLICY_ARCHITECTURE.md](docs/REVIEW_POLICY_ARCHITECTURE.md) for details.',
              '',
              '**Need tier adjustment?** Comment below with justification and tag a codeowner.'
            ].join('\n');

            // Only post comment on PR open/reopen to avoid spamming on every push
            if (context.payload.action === 'opened' || context.payload.action === 'reopened') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: comment
              });
            }

      - name: Check for security violations
        if: steps.assign-tier.outputs.tier == 4
        run: |
          echo "::warning::This PR modifies critical infrastructure files (Tier 4)"
          echo "::warning::RFC document required before implementation review"
          echo "::warning::All codebase owners must approve before merge"
