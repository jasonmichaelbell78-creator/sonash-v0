name: Auto-Label Review Tier

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  assign-tier:
    runs-on: ubuntu-latest
    name: Assign Review Tier Label

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: "22"

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v46
        with:
          files: |
            **/*.ts
            **/*.tsx
            **/*.js
            **/*.jsx
            **/*.json
            **/*.md
            **/*.yml
            **/*.yaml
            **/*.rules
          # Use newline separator for robust filename handling (supports spaces)
          separator: "\n"

      - name: Run tier assignment script
        id: assign-tier
        run: |
          # Get list of changed files (newline-separated from action)
          FILES="${{ steps.changed-files.outputs.all_changed_files }}"

          echo "Changed files:"
          printf '%s\n' "$FILES"

          # Convert newline-separated file list to arguments for the script
          # Uses mapfile to safely handle filenames with spaces
          mapfile -t FILE_ARRAY <<< "$FILES"

          # Run the tier assignment script with changed files as arguments
          # Use || true to capture exit code even if script fails (blocked PRs exit 1)
          RESULT=$(node scripts/assign-review-tier.js "${FILE_ARRAY[@]}") || EXIT_CODE=$?
          EXIT_CODE=${EXIT_CODE:-0}

          echo "Script output:"
          echo "$RESULT"

          # Extract tier from JSON output
          TIER=$(echo "$RESULT" | node -e "process.stdin.setEncoding('utf-8'); let d=''; process.stdin.on('data',c=>d+=c); process.stdin.on('end',()=>console.log(JSON.parse(d).tier))")

          # If script exited non-zero (blocked), still assign the tier but warn
          if [ "$EXIT_CODE" -ne 0 ]; then
            echo "::warning::Tier assignment script flagged violations (exit code $EXIT_CODE)"
          fi

          echo "tier=$TIER" >> "$GITHUB_OUTPUT"
          echo "Assigned tier: $TIER"

      - name: Remove existing tier labels
        uses: actions/github-script@v7
        with:
          script: |
            const labels = ['tier-0', 'tier-1', 'tier-2', 'tier-3', 'tier-4'];
            const currentLabels = context.payload.pull_request.labels.map(l => l.name);

            for (const label of labels) {
              if (!currentLabels.includes(label)) continue;

              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  name: label
                });
              } catch (e) {
                // Avoid failing the job if the label is already gone / not removable
                const status = e?.status;
                if (status !== 404 && status !== 422) throw e;
              }
            }

      - name: Add tier label
        uses: actions/github-script@v7
        with:
          script: |
            const tierRaw = '${{ steps.assign-tier.outputs.tier }}';
            const tier = Number.parseInt(tierRaw, 10);

            // Validate tier output is a valid number 0-4
            if (!Number.isFinite(tier) || tier < 0 || tier > 4) {
              core.setFailed(`Invalid tier output: "${tierRaw}". Expected 0-4.`);
              return;
            }

            const labelName = `tier-${tier}`;

            // Tier label colors (consistent visual cues)
            const tierColors = {
              'tier-0': '0E8A16', // green
              'tier-1': '7057FF', // purple
              'tier-2': 'FBCA04', // yellow
              'tier-3': 'F9A825', // orange
              'tier-4': 'D93F0B'  // red
            };

            // Ensure tier label exists (avoid failing on fresh repos/forks)
            try {
              await github.rest.issues.getLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: labelName
              });
            } catch (e) {
              if (e?.status !== 404) throw e;
              // Create missing label with tier-specific color
              await github.rest.issues.createLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: labelName,
                color: tierColors[labelName] || '0E8A16',
                description: `Review tier ${tier} - auto-assigned by workflow`
              });
            }

            // Add tier label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: [labelName]
            });

            // Add comment explaining tier
            const tierDescriptions = {
              0: 'Tier 0 (Exempt): Auto-merge eligible. No human review required.',
              1: 'Tier 1 (Light): AI review only. Human review optional.',
              2: 'Tier 2 (Standard): AI + 1 human review required.',
              3: 'Tier 3 (Heavy): AI + 2 human reviews + security checklist required.',
              4: 'Tier 4 (Critical): RFC + Multi-AI + all codebase owners required.'
            };

            const tierInfo = tierDescriptions[tier] || 'Unknown tier';

            // Tier-specific details (avoids complex inline conditionals in template)
            const tierDetails = {
              0: '- This PR is eligible for auto-merge after CI passes\n- Estimated merge time: 4 hours',
              1: '- AI review will run automatically\n- Human review is optional\n- Estimated merge time: 1-2 days',
              2: '- AI review will run automatically\n- 1 human approval required\n- Estimated merge time: 2 days',
              3: '- Exhaustive AI review will run\n- 2 human approvals required (1 must be codebase owner)\n- Security checklist must be completed\n- Estimated merge time: 3-5 days',
              4: '- RFC document required\n- Multi-AI review (CodeRabbit + Qodo + custom)\n- All codebase owners must approve\n- Staging deployment + testing required\n- Estimated merge time: 1-2 weeks'
            };

            const comment = [
              `## üè∑Ô∏è Review Tier Assigned: **Tier ${tier}**`,
              '',
              tierInfo,
              '',
              '**What this means:**',
              tierDetails[tier] || '',
              '',
              '**Review Policy:** See [REVIEW_POLICY_ARCHITECTURE.md](docs/REVIEW_POLICY_ARCHITECTURE.md) for details.',
              '',
              '**Need tier adjustment?** Comment below with justification and tag a codeowner.'
            ].join('\n');

            // Only post comment on PR open/reopen to avoid spamming on every push
            if (context.payload.action === 'opened' || context.payload.action === 'reopened') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: comment
              });
            }

      - name: Tier 4 informational warnings
        if: ${{ steps.assign-tier.outputs.tier == '4' }}
        run: |
          echo "::warning::This PR modifies critical infrastructure files (Tier 4)"
          echo "::warning::RFC document required before implementation review"
          echo "::warning::All codebase owners must approve before merge"
