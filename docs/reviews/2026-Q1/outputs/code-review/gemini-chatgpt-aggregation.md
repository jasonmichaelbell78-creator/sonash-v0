# Audit Aggregation: Gemini + ChatGPT

**Created:** 2026-01-05 **Last Updated:** 2026-01-05

---

## Purpose

This document contains aggregated findings from a multi-AI code audit combining
results from Gemini and ChatGPT. It includes:

- Parse errors from the aggregation process
- Deduplicated findings in JSONL format
- Canonical IDs (CANON-NNNN) for cross-referencing issues
- Verification status and consensus scores for each finding

This is a generated output file from the multi-AI review coordinator.

## Quick Start

1. Review aggregated findings
2. Check consensus scores
3. Prioritize high-consensus items

## AI Instructions

When using aggregated findings:

- Higher consensus = higher confidence
- Cross-reference with source outputs
- Update status when resolved

---

## Version History

| Version | Date       | Changes                    |
| ------- | ---------- | -------------------------- |
| 1.0     | 2026-01-05 | Initial aggregation output |

---

## Audit Output

### PARSE_ERRORS_JSON

```json
{
  "parse_errors": [],
  "dropped_count": 0
}
```

### DEDUPED_FINDINGS_JSONL

```jsonl
{"canonical_id":"CANON-0001","category":"Security","title":"Inconsistent Write Security for Notebook Entries","severity":"S1","effort":"E2","status":"CONFIRMED","final_confidence":85,"consensus_score":2,"sources":["Gemini","Copilot"],"confirmations":2,"suspects":0,"tool_confirmed_sources":0,"verification_status":"VERIFIED","verification_notes":"saveNotebookJournalEntry uses addDoc while other writes use httpsCallable Cloud Functions with validation and rate limiting","files":["lib/firestore-service.ts","functions/src/index.ts"],"symbols":["saveNotebookJournalEntry","saveJournalEntry","saveDailyLog","saveInventoryEntry"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Mixed direct Firestore writes and Cloud Function backed writes in FirestoreService","instances":[{"file":"lib/firestore-service.ts","symbol":"saveNotebookJournalEntry"},{"file":"lib/firestore-service.ts","symbol":"saveJournalEntry"},{"file":"lib/firestore-service.ts","symbol":"saveDailyLog"},{"file":"lib/firestore-service.ts","symbol":"saveInventoryEntry"}]},"why_it_matters":"Direct client writes bypass the server-side validation and rate limiting used elsewhere, creating inconsistent security guarantees.","suggested_fix":"Route notebook journal writes through the existing saveJournalEntry Cloud Function or apply equivalent server-side checks for all write paths.","acceptance_tests":["Verify notebook journal writes are processed via Cloud Function","Rate limiting still applies to notebook entries"],"pr_bucket_suggestion":"security-hardening","dependencies":[],"evidence_summary":["saveDailyLog/saveInventoryEntry use httpsCallable","saveNotebookJournalEntry currently uses addDoc directly"]}
{"canonical_id":"CANON-0002","category":"Security","title":"App Check disabled on key Cloud Functions","severity":"S1","effort":"E1","status":"CONFIRMED","final_confidence":92,"consensus_score":2,"sources":["Copilot","Claude"],"confirmations":2,"suspects":0,"tool_confirmed_sources":1,"verification_status":"VERIFIED","verification_notes":"functions/src/index.ts explicitly sets requireAppCheck: false for saveDailyLog and saveInventoryEntry","files":["functions/src/index.ts"],"symbols":["saveDailyLog","saveInventoryEntry","requireAppCheck"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Disabling App Check allows untrusted callers to hit production Cloud Functions directly, bypassing bot protections.","suggested_fix":"Enable App Check enforcement on affected functions; use debug tokens for local development instead of disabling in production.","acceptance_tests":["Calling functions without App Check token fails with 403","Debug token works in local/dev"],"pr_bucket_suggestion":"security-hardening","dependencies":[],"evidence_summary":["requireAppCheck set to false with TEMPORARY comment"]}
{"canonical_id":"CANON-0003","category":"Security","title":"Firestore rules may not rate limit journal writes (suspected)","severity":"S1","effort":"E2","status":"SUSPECTED","final_confidence":40,"consensus_score":1,"sources":["Copilot"],"confirmations":0,"suspects":1,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Rules content not yet reviewed for journal rate limiting","files":["firestore.rules"],"symbols":["match /users/{userId}/journal/{entryId}"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"If journal writes bypass Cloud Functions and rules lack throttling, clients could write unlimited entries.","suggested_fix":"Review and update Firestore rules to ensure journal writes are properly constrained or enforced via callable functions.","acceptance_tests":["Firestore Rules Simulator shows journal write limits"],"pr_bucket_suggestion":"security-hardening","dependencies":["CANON-0001"],"evidence_summary":["Rules file exists; rate limiting not confirmed"]}
{"canonical_id":"CANON-0004","category":"Types/Correctness","title":"Unsafe Firestore data casting without validation","severity":"S1","effort":"E1","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["Gemini"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"VERIFIED","verification_notes":"Multiple modules cast Firestore data with `as` without schema checks","files":["lib/firestore-service.ts","lib/db/meetings.ts","components/admin/admin-crud-table.tsx"],"symbols":["getTodayLog","getMeetingsByDay","fetchItems"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Repeated direct casts of Firestore snapshots","instances":[{"file":"lib/firestore-service.ts","symbol":"docSnap.data() as DailyLog"},{"file":"lib/db/meetings.ts","symbol":"d.data() as Meeting"},{"file":"components/admin/admin-crud-table.tsx","symbol":"d.data() as T"}]},"why_it_matters":"Schema drift or malformed documents can crash the UI or corrupt data because results are trusted blindly.","suggested_fix":"Add runtime validation (e.g., Zod) or converter utilities before casting Firestore documents.","acceptance_tests":["Malformed Firestore data is rejected gracefully"],"pr_bucket_suggestion":"types-domain","dependencies":[],"evidence_summary":["Direct casts present in FirestoreService, meetings service, and admin CRUD table"]}
{"canonical_id":"CANON-0005","category":"Hygiene/Duplication","title":"Fragmented Firestore access patterns","severity":"S2","effort":"E2","status":"CONFIRMED","final_confidence":90,"consensus_score":5,"sources":["Gemini","Codex","Jules","ChatGPT"],"confirmations":4,"suspects":0,"tool_confirmed_sources":1,"verification_status":"VERIFIED","verification_notes":"FirestoreService, FirestoreAdapter, MeetingsService, AdminCrudTable, user profile helpers, and UI widgets access Firestore differently","files":["lib/firestore-service.ts","lib/database/firestore-adapter.ts","lib/db/meetings.ts","lib/db/users.ts","components/admin/admin-crud-table.tsx","components/growth/DailySloganWidget.tsx","components/notebook/pages/today-page.tsx","lib/db/slogans.ts"],"symbols":["FirestoreService","FirestoreAdapter","MeetingsService","getUserProfile","AdminCrudTable","collection","getDocs"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Service, adapter, and direct SDK usage coexist across services, helpers, and components","instances":[{"file":"lib/firestore-service.ts","symbol":"FirestoreService"},{"file":"lib/database/firestore-adapter.ts","symbol":"FirestoreAdapter"},{"file":"lib/db/meetings.ts","symbol":"MeetingsService"},{"file":"lib/db/users.ts","symbol":"getUserProfile"},{"file":"components/admin/admin-crud-table.tsx","symbol":"AdminCrudTable"},{"file":"components/growth/DailySloganWidget.tsx","symbol":"collection/getDocs"},{"file":"components/notebook/pages/today-page.tsx","symbol":"collection db daily_logs"},{"file":"lib/db/slogans.ts","symbol":"collection(db, COLLECTION_NAME)"}]},"why_it_matters":"Divergent access paths hinder caching, validation, and security reviews and risk bypassing shared rate limiting.","suggested_fix":"Standardize on a single Firestore access abstraction and eliminate direct SDK usage in feature code or route via FirestoreService-created adapters.","acceptance_tests":["All Firestore calls go through the chosen service/adapter"],"pr_bucket_suggestion":"firebase-access","dependencies":[],"evidence_summary":["Adapter wraps service while other modules call Firestore directly, including UI components and slogan service"]}
{"canonical_id":"CANON-0006","category":"Hygiene/Duplication","title":"Client-side dual writes for gratitude entries","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":75,"consensus_score":1,"sources":["Gemini"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"VERIFIED","verification_notes":"GratitudeCard issues two awaited writes for the same data","files":["components/growth/GratitudeCard.tsx"],"symbols":["handleSave","saveInventoryEntry","saveNotebookJournalEntry"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"If one write fails, data becomes inconsistent across collections.","suggested_fix":"Move denormalization to a server-side trigger or use Firestore batch/transaction for atomicity.","acceptance_tests":["Data remains consistent when one write fails"],"pr_bucket_suggestion":"firebase-access","dependencies":["CANON-0001"],"evidence_summary":["handleSave performs two sequential writes"]}
{"canonical_id":"CANON-0007","category":"Hygiene/Duplication","title":"Duplicate Firebase Admin SDK initialization across scripts","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["Copilot"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"VERIFIED","verification_notes":"Multiple migration/seed scripts repeat the same initializeApp/getFirestore pattern","files":["scripts/migrate-to-journal.ts","scripts/migrate-addresses.ts","scripts/sync-geocache.ts","scripts/enrich-addresses.ts","scripts/retry-failures.ts","scripts/seed-real-data.ts","scripts/import-nashville-links.ts","scripts/seed-meetings.ts"],"symbols":["initializeApp","getFirestore","cert","getApps"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"8+ scripts implement identical admin initialization","instances":[{"file":"scripts/migrate-to-journal.ts","symbol":"initializeApp"},{"file":"scripts/migrate-addresses.ts","symbol":"initializeApp"},{"file":"scripts/sync-geocache.ts","symbol":"initializeApp"},{"file":"scripts/enrich-addresses.ts","symbol":"initializeApp"},{"file":"scripts/retry-failures.ts","symbol":"initializeApp"},{"file":"scripts/seed-real-data.ts","symbol":"initializeApp"},{"file":"scripts/import-nashville-links.ts","symbol":"initializeApp"},{"file":"scripts/seed-meetings.ts","symbol":"initializeApp"}]},"why_it_matters":"Shared bugs or configuration tweaks must be fixed in many places; paths to service account JSON differ across scripts.","suggested_fix":"Create a shared scripts/lib/admin-init module that handles idempotent initialization and consistent credential loading.","acceptance_tests":["All scripts run via shared admin init","grep for initializeApp in scripts/ shows single implementation"],"pr_bucket_suggestion":"firebase-access","dependencies":[],"evidence_summary":["Repeated getApps()/initializeApp patterns across scripts"]}
{"canonical_id":"CANON-0008","category":"Types/Correctness","title":"Conflicting journal entry type definitions","severity":"S2","effort":"E2","status":"CONFIRMED","final_confidence":85,"consensus_score":3,"sources":["Gemini","Copilot","Claude"],"confirmations":3,"suspects":0,"tool_confirmed_sources":0,"verification_status":"VERIFIED","verification_notes":"DailyLog/DailyLogEntry defined in both types/journal.ts and lib/types/daily-log.ts with differing fields; Cloud Function schemas and inline unions add more variants","files":["types/journal.ts","lib/types/daily-log.ts","lib/firestore-service.ts","functions/src/schemas.ts","functions/src/index.ts"],"symbols":["JournalEntryType","DailyLog","DailyLogEntry","dailyLogSchema"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Multiple overlapping definitions of journal entry shapes","instances":[{"file":"types/journal.ts","symbol":"DailyLogEntry"},{"file":"lib/types/daily-log.ts","symbol":"DailyLog"},{"file":"functions/src/schemas.ts","symbol":"dailyLogSchema"},{"file":"lib/firestore-service.ts","symbol":"inline JournalEntryType union"}]},"why_it_matters":"Divergent type definitions risk runtime mismatches and confusion about the canonical data contract.","suggested_fix":"Select a single journal type module and align client and Cloud Function schemas; deprecate duplicate interfaces and inline unions.","acceptance_tests":["Type checking passes with a single DailyLog definition","Imports of DailyLog come from one location"],"pr_bucket_suggestion":"types-domain","dependencies":[],"evidence_summary":["DailyLogEntry vs DailyLog fields differ (dateLabel vs date)","firestore-service redefines JournalEntryType inline"]}
{"canonical_id":"CANON-0009","category":"Types/Correctness","title":"Nullable handling inconsistent for journal fields","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":70,"consensus_score":1,"sources":["Copilot"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"PARTIALLY_VERIFIED","verification_notes":"cravings/used sometimes optional boolean, sometimes boolean|null across types and functions","files":["types/journal.ts","lib/types/daily-log.ts","functions/src/index.ts","lib/firestore-service.ts"],"symbols":["DailyLogEntry","DailyLog","DailyLogData","saveDailyLog"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Inconsistent nullability leads to undefined vs null discrepancies and potential schema drift when saving logs.","suggested_fix":"Standardize tri-state fields as boolean | null and normalize undefined to null with validation before writes.","acceptance_tests":["tsc --noEmit passes with unified types","Logs saved with missing values store null consistently"],"pr_bucket_suggestion":"types-domain","dependencies":["CANON-0008"],"evidence_summary":["types/journal.ts marks cravings optional; lib/types/daily-log.ts requires boolean|null; FirestoreService deletes undefined fields"]}
{"canonical_id":"CANON-0010","category":"Types/Correctness","title":"Any/unknown error handling without type guards","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":70,"consensus_score":1,"sources":["Copilot"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"PARTIALLY_VERIFIED","verification_notes":"Catch blocks cast unknown to Error or custom type without narrowing","files":["lib/firestore-service.ts","functions/src/index.ts","lib/db/users.ts"],"symbols":["CloudFunctionError","isFirebaseError"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Non-Error values from Firebase can cause runtime failures when properties are accessed without guards.","suggested_fix":"Add error type guard utilities (e.g., isFirebaseError) and use them before accessing message/code on unknown errors.","acceptance_tests":["Unit tests cover non-Error throws without crashing"],"pr_bucket_suggestion":"types-domain","dependencies":[],"evidence_summary":["error cast to CloudFunctionError without runtime guard"]}
{"canonical_id":"CANON-0011","category":"Next/React Boundaries","title":"Direct localStorage access in useState initializer","severity":"S2","effort":"E0","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["Copilot"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"VERIFIED","verification_notes":"useSmartPrompts useState initializer touches localStorage without window guard","files":["components/notebook/hooks/use-smart-prompts.ts"],"symbols":["useSmartPrompts","localStorage.getItem"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Next.js app router can run initializers during SSR/prerender; direct localStorage access will throw and break hydration.","suggested_fix":"Guard localStorage access with window checks or move to useEffect to ensure client-only execution.","acceptance_tests":["npm run build succeeds","Page renders without SSR errors"],"pr_bucket_suggestion":"types-domain","dependencies":[],"evidence_summary":["useState lazy initializer reads localStorage"]}
{"canonical_id":"CANON-0012","category":"Testing","title":"Missing tests for security-critical write paths","severity":"S2","effort":"E2","status":"CONFIRMED","final_confidence":70,"consensus_score":1,"sources":["Copilot"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"PARTIALLY_VERIFIED","verification_notes":"saveDailyLog/saveNotebookJournalEntry not covered by firestore-service tests","files":["tests/firestore-service.test.ts","tests/security/firestore-validation.test.ts"],"symbols":["createFirestoreService","saveNotebookJournalEntry"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Critical write paths lack automated coverage, reducing confidence in rate limiting and validation behavior.","suggested_fix":"Add tests for Cloud Function-backed writes and notebook journal writes using DI helpers.","acceptance_tests":["Coverage includes saveDailyLog and saveNotebookJournalEntry paths"],"pr_bucket_suggestion":"tests-hardening","dependencies":["CANON-0001"],"evidence_summary":["Existing tests focus on read paths only"]}
{"canonical_id":"CANON-0013","category":"Hygiene/Duplication","title":"Rate limiter defined both client and server side","severity":"S3","effort":"E2","status":"CONFIRMED","final_confidence":65,"consensus_score":1,"sources":["Copilot"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"PARTIALLY_VERIFIED","verification_notes":"Client-side in-memory limiter and server Firestore limiter implement similar thresholds","files":["lib/utils/rate-limiter.ts","functions/src/firestore-rate-limiter.ts","lib/constants.ts"],"symbols":["RateLimiter","FirestoreRateLimiter","RATE_LIMITS"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Client and server duplicate rate limit values","instances":[{"file":"lib/utils/rate-limiter.ts","symbol":"RateLimiter"},{"file":"functions/src/firestore-rate-limiter.ts","symbol":"FirestoreRateLimiter"},{"file":"lib/constants.ts","symbol":"RATE_LIMITS"}]},"why_it_matters":"Values can drift between client and server, causing misleading UX and bypassable client enforcement.","suggested_fix":"Server should be source of truth; keep client logic UX-only or share constants across environments.","acceptance_tests":["Server rate limiting still works; client handles server errors gracefully"],"pr_bucket_suggestion":"misc","dependencies":[],"evidence_summary":["Rate limits set to 10 req/min in multiple places"]}
{"canonical_id":"CANON-0014","category":"Hygiene/Duplication","title":"Scattered localStorage keys without central registry","severity":"S3","effort":"E1","status":"CONFIRMED","final_confidence":65,"consensus_score":1,"sources":["Copilot"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"PARTIALLY_VERIFIED","verification_notes":"Multiple modules hardcode storage key strings beyond STORAGE_KEYS","files":["lib/constants.ts","lib/utils/anonymous-backup.ts","components/notebook/hooks/use-smart-prompts.ts","components/notebook/pages/today-page.tsx","components/notebook/notebook-shell.tsx"],"symbols":["STORAGE_KEYS","BACKUP_KEY","dismissed-prompts-","made-it-through-","sonash_journal_temp"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"localStorage key strings scattered across modules","instances":[{"file":"lib/constants.ts","symbol":"STORAGE_KEYS"},{"file":"lib/utils/anonymous-backup.ts","symbol":"BACKUP_KEY"},{"file":"components/notebook/hooks/use-smart-prompts.ts","symbol":"dismissed-prompts-"},{"file":"components/notebook/pages/today-page.tsx","symbol":"made-it-through-"},{"file":"components/notebook/notebook-shell.tsx","symbol":"sonash_journal_temp"}]},"why_it_matters":"Scattered keys hinder auditing, increase collision risk, and complicate clear-all-data flows.","suggested_fix":"Centralize all localStorage keys in constants with helpers for dynamic keys; update usages to import from there.","acceptance_tests":["Search shows localStorage keys sourced from constants module"],"pr_bucket_suggestion":"misc","dependencies":[],"evidence_summary":["Various modules define their own storage key strings"]}
{"canonical_id":"CANON-0015","category":"Hygiene/Duplication","title":"Potential duplicate skeleton/loading components (suspected)","severity":"S3","effort":"E1","status":"SUSPECTED","final_confidence":35,"consensus_score":1,"sources":["Copilot"],"confirmations":0,"suspects":1,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Needs audit of skeleton components across ui and page-level implementations","files":["components/ui/skeleton.tsx","components/notebook/pages/today-page.tsx"],"symbols":["Skeleton","TodayPageSkeleton","HistoryPageSkeleton"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Skeleton components may be duplicated across ui and pages","instances":[{"file":"components/ui/skeleton.tsx","symbol":"HistoryPageSkeleton"},{"file":"components/notebook/pages/today-page.tsx","symbol":"TodayPageSkeleton"}]},"why_it_matters":"Duplicate UI primitives increase maintenance and inconsistency risk.","suggested_fix":"Consolidate skeleton components under components/ui if duplicates exist.","acceptance_tests":["Skeleton usage references shared components"],"pr_bucket_suggestion":"ui-primitives","dependencies":[],"evidence_summary":["Suspected duplication noted; requires verification"]}
{"canonical_id":"CANON-0016","category":"Hygiene/Duplication","title":"Repeated onSnapshot subscription pattern (suspected)","severity":"S3","effort":"E1","status":"SUSPECTED","final_confidence":30,"consensus_score":1,"sources":["Copilot"],"confirmations":0,"suspects":1,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Possible repeated isMounted/onSnapshot cleanup pattern across components","files":["components/notebook/pages/today-page.tsx","lib/database/firestore-adapter.ts"],"symbols":["setupListener","subscribeToDailyLog","onSnapshot"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Real-time listeners may duplicate setup/cleanup logic","instances":[{"file":"components/notebook/pages/today-page.tsx","symbol":"setupListener"},{"file":"lib/database/firestore-adapter.ts","symbol":"subscribeToDailyLog"}]},"why_it_matters":"Inconsistent cleanup can cause memory leaks or stale listeners.","suggested_fix":"Extract a shared hook/util for Firestore subscriptions if duplication confirmed.","acceptance_tests":["Listener hook used consistently with proper cleanup"],"pr_bucket_suggestion":"hooks-standardization","dependencies":[],"evidence_summary":["Suspected repeating listener setup pattern"]}
{"canonical_id":"CANON-0017","category":"Types/Correctness","title":"Potential mismatch between client journal types and server schema (suspected)","severity":"S2","effort":"E1","status":"SUSPECTED","final_confidence":30,"consensus_score":1,"sources":["Copilot"],"confirmations":0,"suspects":1,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Needs comparison of journalEntrySchema vs client JournalEntry types","files":["types/journal.ts","functions/src/schemas.ts"],"symbols":["JournalEntry","journalEntrySchema"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Schema/type drift can reject valid data or allow invalid entries across client/server boundary.","suggested_fix":"Align client types with Zod schemas or generate types from schemas.","acceptance_tests":["Type checks succeed when using schema-inferred types"],"pr_bucket_suggestion":"types-domain","dependencies":["CANON-0008"],"evidence_summary":["Server schema vs client types alignment not yet verified"]}
{"canonical_id":"CANON-0018","category":"Hygiene/Duplication","title":"Duplicated growth card dialog/save flows","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":80,"consensus_score":2,"sources":["Codex","ChatGPT"],"confirmations":2,"suspects":0,"tool_confirmed_sources":1,"verification_status":"PARTIALLY_VERIFIED","verification_notes":"Growth cards share dialog, speech, and Firestore save patterns without shared primitive","files":["components/growth/SpotCheckCard.tsx","components/growth/GratitudeCard.tsx","components/growth/NightReviewCard.tsx","components/growth/Step1WorksheetCard.tsx"],"symbols":["SpotCheckCard","GratitudeCard","NightReviewCard","Step1WorksheetCard"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Multiple growth cards repeat wizard and save flows","instances":[{"file":"components/growth/SpotCheckCard.tsx","symbol":"SpotCheckCard"},{"file":"components/growth/GratitudeCard.tsx","symbol":"GratitudeCard"},{"file":"components/growth/NightReviewCard.tsx","symbol":"NightReviewCard"},{"file":"components/growth/Step1WorksheetCard.tsx","symbol":"Step1WorksheetCard"}]},"why_it_matters":"Duplicated dialog state and save logic risks drift in validation, telemetry, and UX behavior.","suggested_fix":"Extract a shared growth card wizard component handling dialog lifecycle, speech support, and FirestoreService saves.","acceptance_tests":["All growth cards function via shared primitive","npm run lint","npm test"],"pr_bucket_suggestion":"ui-primitives","dependencies":[],"evidence_summary":["Repeated dialog + save patterns across growth cards"]}
{"canonical_id":"CANON-0019","category":"Testing","title":"Low coverage for account linking flows","severity":"S1","effort":"E2","status":"CONFIRMED","final_confidence":85,"consensus_score":1,"sources":["Claude"],"confirmations":1,"suspects":0,"tool_confirmed_sources":1,"verification_status":"PARTIALLY_VERIFIED","verification_notes":"Coverage report shows lib/auth/account-linking.ts at 17.5% statements","files":["lib/auth/account-linking.ts"],"symbols":["linkAnonymousAccount","handleAccountLinkingError"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Anonymous-to-permanent account linking is security-sensitive; low coverage risks data loss or auth bypass bugs going unnoticed.","suggested_fix":"Add tests covering successful linking, conflicts, data migration, and error recovery paths with mocked Firebase Auth APIs.","acceptance_tests":["Coverage for account-linking.ts exceeds 70%","Tests cover happy path and multiple error scenarios"],"pr_bucket_suggestion":"tests-hardening","dependencies":[],"evidence_summary":["Coverage output highlights low statements/branches for account-linking.ts"]}
{"canonical_id":"CANON-0020","category":"Hygiene/Duplication","title":"Duplicate time-of-day rotation logic for quotes and slogans","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":90,"consensus_score":3,"sources":["Claude","ChatGPT"],"confirmations":2,"suspects":0,"tool_confirmed_sources":1,"verification_status":"VERIFIED","verification_notes":"QuotesService and SlogansService both define identical getTimeOfDay and similar rotation functions","files":["lib/db/quotes.ts","lib/db/slogans.ts"],"symbols":["getTimeOfDay","getQuoteForNow","getSloganForNow"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Shared time-of-day and rotation algorithms duplicated across services","instances":[{"file":"lib/db/quotes.ts","symbol":"getTimeOfDay"},{"file":"lib/db/quotes.ts","symbol":"getQuoteForNow"},{"file":"lib/db/slogans.ts","symbol":"getTimeOfDay"},{"file":"lib/db/slogans.ts","symbol":"getSloganForNow"}]},"why_it_matters":"Bug fixes or schedule tweaks must be duplicated, risking drift in user-facing content rotation.","suggested_fix":"Extract shared content rotation helpers (e.g., content-rotation.ts) used by both services.","acceptance_tests":["npm run lint","npm test","Verify quote and slogan rotation remain stable across refreshes within the same window"],"pr_bucket_suggestion":"hooks-standardization","dependencies":[],"evidence_summary":["Identical getTimeOfDay implementations and near-identical rotation logic"]}
{"canonical_id":"CANON-0021","category":"Hygiene/Duplication","title":"CRUD services duplicate boilerplate across DB modules","severity":"S2","effort":"E2","status":"CONFIRMED","final_confidence":78,"consensus_score":1,"sources":["Claude"],"confirmations":1,"suspects":0,"tool_confirmed_sources":1,"verification_status":"PARTIALLY_VERIFIED","verification_notes":"Quotes, slogans, glossary, and sober-living services implement similar get/add/update/delete patterns","files":["lib/db/quotes.ts","lib/db/slogans.ts","lib/db/glossary.ts","lib/db/sober-living.ts"],"symbols":["QuotesService","SlogansService","GlossaryService","SoberLivingService"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"CRUD boilerplate repeated with different collection names","instances":[{"file":"lib/db/quotes.ts","symbol":"QuotesService"},{"file":"lib/db/slogans.ts","symbol":"SlogansService"},{"file":"lib/db/glossary.ts","symbol":"GlossaryService"},{"file":"lib/db/sober-living.ts","symbol":"SoberLivingService"}]},"why_it_matters":"Cross-cutting changes (error handling, logging) require editing multiple files; risk inconsistent behavior across entities.","suggested_fix":"Introduce a generic createCrudService factory to centralize Firestore CRUD patterns per collection.","acceptance_tests":["Admin CRUD works for all entities after refactor","npm run lint","npm test"],"pr_bucket_suggestion":"firebase-access","dependencies":[],"evidence_summary":["Parallel CRUD methods across four DB services"]}
{"canonical_id":"CANON-0022","category":"Hygiene/Duplication","title":"Multiple quote widgets duplicate data fetching","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["Claude"],"confirmations":1,"suspects":0,"tool_confirmed_sources":1,"verification_status":"VERIFIED","verification_notes":"Three quote components fetch all quotes and select today's item independently","files":["components/widgets/daily-quote-card.tsx","components/widgets/compact-daily-quote.tsx","components/notebook/features/daily-quote-card.tsx"],"symbols":["DailyQuoteCard","CompactDailyQuote","DailyQuoteCard"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Duplicate quote-of-day fetching and selection logic across components","instances":[{"file":"components/widgets/daily-quote-card.tsx","symbol":"DailyQuoteCard"},{"file":"components/widgets/compact-daily-quote.tsx","symbol":"CompactDailyQuote"},{"file":"components/notebook/features/daily-quote-card.tsx","symbol":"DailyQuoteCard"}]},"why_it_matters":"Mounting multiple widgets triggers redundant Firestore reads and duplicated selection logic, wasting bandwidth and risking divergence.","suggested_fix":"Create a shared useQuoteOfTheDay hook or QuoteProvider to fetch/cache once and share across visual variants.","acceptance_tests":["Mounting multiple quote components issues a single fetch","Quotes render correctly in all variants"],"pr_bucket_suggestion":"hooks-standardization","dependencies":["CANON-0020"],"evidence_summary":["Each quote component fetches all quotes and picks today independently"]}
{"canonical_id":"CANON-0023","category":"Hygiene/Duplication","title":"Entity types use index signature escape hatches","severity":"S3","effort":"E1","status":"CONFIRMED","final_confidence":85,"consensus_score":2,"sources":["Claude","ChatGPT"],"confirmations":2,"suspects":0,"tool_confirmed_sources":1,"verification_status":"PARTIALLY_VERIFIED","verification_notes":"Six entity interfaces include [key: string]: unknown","files":["lib/db/quotes.ts","lib/db/slogans.ts","lib/db/glossary.ts","lib/db/sober-living.ts","lib/db/meetings.ts","components/admin/admin-crud-types.ts"],"symbols":["Quote","Slogan","GlossaryTerm","SoberLivingHome","Meeting","AdminCrudEntity"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Index signatures repeated across entity definitions","instances":[{"file":"lib/db/quotes.ts","symbol":"Quote"},{"file":"lib/db/slogans.ts","symbol":"Slogan"},{"file":"lib/db/glossary.ts","symbol":"GlossaryTerm"},{"file":"lib/db/sober-living.ts","symbol":"SoberLivingHome"},{"file":"lib/db/meetings.ts","symbol":"Meeting"},{"file":"components/admin/admin-crud-types.ts","symbol":"AdminCrudEntity"}]},"why_it_matters":"Index signatures defeat type safety by allowing arbitrary properties, hiding bugs that strict typings would surface.","suggested_fix":"Remove index signatures and, if needed, add explicit metadata fields or discriminated unions for flexible attributes.","acceptance_tests":["npm run lint","TypeScript errors resolved with stricter types"],"pr_bucket_suggestion":"types-domain","dependencies":[],"evidence_summary":["[key: string]: unknown present across six entity interfaces"]}
{"canonical_id":"CANON-0024","category":"Hygiene/Duplication","title":"Firestore collection names defined inconsistently","severity":"S3","effort":"E0","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["Claude"],"confirmations":1,"suspects":0,"tool_confirmed_sources":1,"verification_status":"VERIFIED","verification_notes":"Db modules declare local COLLECTION constants instead of shared FIRESTORE_COLLECTIONS","files":["lib/db/slogans.ts","lib/db/quotes.ts","lib/db/glossary.ts","lib/db/sober-living.ts","lib/constants.ts"],"symbols":["COLLECTION_NAME","COLLECTION","FIRESTORE_COLLECTIONS"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Collection names scattered across modules with inconsistent naming","instances":[{"file":"lib/db/slogans.ts","symbol":"COLLECTION_NAME"},{"file":"lib/db/quotes.ts","symbol":"COLLECTION"},{"file":"lib/db/glossary.ts","symbol":"COLLECTION"},{"file":"lib/db/sober-living.ts","symbol":"COLLECTION"},{"file":"lib/constants.ts","symbol":"FIRESTORE_COLLECTIONS"}]},"why_it_matters":"Hardcoded collection strings risk typos and complicate global path changes; shared constants exist but are unused.","suggested_fix":"Centralize collection names in FIRESTORE_COLLECTIONS and import in all db services, removing local constants.","acceptance_tests":["Grep for collection names shows constants usage only"],"pr_bucket_suggestion":"firebase-access","dependencies":[],"evidence_summary":["Local COLLECTION constants differ from shared FIRESTORE_COLLECTIONS"]}
{"canonical_id":"CANON-0025","category":"Hygiene/Duplication","title":"Toast notifications hardcoded across features","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":75,"consensus_score":1,"sources":["Claude"],"confirmations":1,"suspects":0,"tool_confirmed_sources":1,"verification_status":"PARTIALLY_VERIFIED","verification_notes":"21 files import toast from sonner with repeated success/error strings","files":["components/growth/SpotCheckCard.tsx","components/growth/NightReviewCard.tsx","components/growth/GratitudeCard.tsx","components/journal/entry-forms/mood-form.tsx","components/notebook/pages/today-page.tsx"],"symbols":["toast.success","toast.error"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Toast usage scattered with similar messages","instances":[{"file":"components/growth/SpotCheckCard.tsx","symbol":"toast.success/toast.error"},{"file":"components/growth/NightReviewCard.tsx","symbol":"toast.success/toast.error"},{"file":"components/growth/GratitudeCard.tsx","symbol":"toast.success/toast.error"},{"file":"components/journal/entry-forms/mood-form.tsx","symbol":"toast.error"},{"file":"components/notebook/pages/today-page.tsx","symbol":"toast.success/toast.error/toast.info"}]},"why_it_matters":"Hardcoded notifications make it hard to change copy, add analytics, or support i18n; inconsistent wording across flows.","suggested_fix":"Create a centralized notification helper (e.g., lib/notifications.ts) with shared message keys and analytics hooks.","acceptance_tests":["Notifications still display correctly","Reduced direct toast imports after refactor"],"pr_bucket_suggestion":"ui-primitives","dependencies":[],"evidence_summary":["Many files import toast with similar messages"]}
{"canonical_id":"CANON-0026","category":"Hygiene/Duplication","title":"Repeated Cloud Function rate limiter configuration","severity":"S3","effort":"E0","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["Claude"],"confirmations":1,"suspects":0,"tool_confirmed_sources":1,"verification_status":"VERIFIED","verification_notes":"Four rate limiter instances use near-identical configs in functions/src/index.ts","files":["functions/src/index.ts"],"symbols":["saveDailyLogLimiter","saveJournalEntryLimiter","saveInventoryEntryLimiter","migrateDataLimiter"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Rate limiter presets repeated inline","instances":[{"file":"functions/src/index.ts","symbol":"saveDailyLogLimiter"},{"file":"functions/src/index.ts","symbol":"saveJournalEntryLimiter"},{"file":"functions/src/index.ts","symbol":"saveInventoryEntryLimiter"},{"file":"functions/src/index.ts","symbol":"migrateDataLimiter"}]},"why_it_matters":"Config drift risk; changing default limits requires editing multiple blocks instead of a single preset.","suggested_fix":"Define shared RATE_LIMIT_PRESETS and instantiate limiters from the presets to keep policy centralized.","acceptance_tests":["Rate limiting still functions after refactor","Updating preset updates all limiters"],"pr_bucket_suggestion":"firebase-access","dependencies":["CANON-0002"],"evidence_summary":["Similar points/duration configs repeated four times"]}
{"canonical_id":"CANON-0027","category":"Testing","title":"No tests for DB service modules","severity":"S2","effort":"E2","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["Claude"],"confirmations":1,"suspects":0,"tool_confirmed_sources":1,"verification_status":"PARTIALLY_VERIFIED","verification_notes":"Coverage reports show db services lack dedicated tests; lib/db/users.ts at 33.64% coverage","files":["lib/db/quotes.ts","lib/db/slogans.ts","lib/db/glossary.ts","lib/db/sober-living.ts","lib/db/meetings.ts","lib/db/users.ts"],"symbols":["QuotesService","SlogansService","GlossaryService","SoberLivingService","MeetingsService","getUserProfile"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Critical CRUD modules operate without automated verification, reducing confidence in data integrity and regressions.","suggested_fix":"Add tests/db/* covering CRUD operations, error handling, and rotation logic; prioritize users.ts coverage gaps.","acceptance_tests":["npm test includes db service suites","Coverage for lib/db modules exceeds 70%"],"pr_bucket_suggestion":"tests-hardening","dependencies":["CANON-0021"],"evidence_summary":["Coverage output shows low or missing tests for db services"]}
{"canonical_id":"CANON-0028","category":"Next/React Boundaries","title":"DailySloganWidget bypasses SlogansService","severity":"S2","effort":"E0","status":"CONFIRMED","final_confidence":88,"consensus_score":2,"sources":["Claude","ChatGPT"],"confirmations":2,"suspects":0,"tool_confirmed_sources":1,"verification_status":"VERIFIED","verification_notes":"Component calls collection/getDocs directly instead of SlogansService.getAllSlogans","files":["components/growth/DailySloganWidget.tsx","lib/db/slogans.ts"],"symbols":["DailySloganWidget","fetchDailySlogan","SlogansService.getAllSlogans"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Widget reimplements slogan fetch/mapping instead of using service layer","instances":[{"file":"components/growth/DailySloganWidget.tsx","symbol":"DailySloganWidget"},{"file":"lib/db/slogans.ts","symbol":"SlogansService.getAllSlogans"}]},"why_it_matters":"Bypassing the service layer fragments Firestore access and complicates caching or middleware applied in the service.","suggested_fix":"Replace direct Firestore calls with SlogansService.getAllSlogans so data access stays centralized.","acceptance_tests":["Slogan widget renders correctly using service","No direct collection() calls remain in the component"],"pr_bucket_suggestion":"firebase-access","dependencies":["CANON-0005","CANON-0020"],"evidence_summary":["Component imports db and calls collection/getDocs directly while service already provides the same mapping"]}
{"canonical_id":"CANON-0029","category":"Hygiene/Duplication","title":"Meeting countdown widgets duplicate timer logic","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":70,"consensus_score":1,"sources":["Claude"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Not re-verified; compact widget implements full logic while meeting-countdown.tsx uses placeholder timing","files":["components/widgets/meeting-countdown.tsx","components/widgets/compact-meeting-countdown.tsx","lib/db/meetings.ts"],"symbols":["calculateNextMeeting","getCountdownString","parseMinutesSinceMidnight","timeToMinutes"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Meeting countdown logic and time parsing duplicated across two widgets and meetings helper","instances":[{"file":"components/widgets/meeting-countdown.tsx","symbol":"calculateNextMeeting"},{"file":"components/widgets/compact-meeting-countdown.tsx","symbol":"getCountdownString"},{"file":"lib/db/meetings.ts","symbol":"timeToMinutes"}]},"why_it_matters":"Placeholder logic can diverge from the real implementation and both widgets reimplement time parsing, increasing maintenance overhead.","suggested_fix":"Keep a single countdown widget or extract shared time parsing helpers (e.g., meeting-time utils) consumed by the active component.","acceptance_tests":["Only the consolidated widget is referenced","Time parsing comes from shared helper","npm test passes"],"pr_bucket_suggestion":"hooks-standardization","dependencies":[],"evidence_summary":["Two widgets implement similar countdown calculations with differing completeness"]}
{"canonical_id":"CANON-0030","category":"Hygiene/Duplication","title":"Cloud Function callsites lack shared wrapper","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":78,"consensus_score":1,"sources":["Claude"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Not re-verified; multiple files import getFunctions/httpsCallable directly","files":["lib/firestore-service.ts","hooks/use-journal.ts","components/admin/dashboard-tab.tsx","components/admin/errors-tab.tsx","components/admin/admin-crud-table.tsx","components/admin/users-tab.tsx","components/admin/jobs-tab.tsx","lib/auth/account-linking.ts"],"symbols":["getFunctions","httpsCallable","retryCloudFunction"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Cloud Function calls are instantiated inline across many modules without centralized error handling","instances":[{"file":"lib/firestore-service.ts","symbol":"getFunctions"},{"file":"hooks/use-journal.ts","symbol":"getFunctions"},{"file":"components/admin/dashboard-tab.tsx","symbol":"getFunctions"},{"file":"components/admin/errors-tab.tsx","symbol":"getFunctions"},{"file":"components/admin/admin-crud-table.tsx","symbol":"getFunctions"},{"file":"components/admin/users-tab.tsx","symbol":"getFunctions"},{"file":"components/admin/jobs-tab.tsx","symbol":"getFunctions"},{"file":"lib/auth/account-linking.ts","symbol":"getFunctions"}]},"why_it_matters":"Error handling and retry logic must be updated in many places; inconsistent telemetry and retry behavior increases failure risk.","suggested_fix":"Provide a shared callable factory in lib/firebase-functions.ts with built-in retry/logging and update consumers to use it.","acceptance_tests":["All Cloud Function calls flow through the shared wrapper","Retry/error handling is consistent"],"pr_bucket_suggestion":"firebase-access","dependencies":["CANON-0005"],"evidence_summary":["Inline getFunctions/httpsCallable usage spread across admin, hooks, and services"]}
{"canonical_id":"CANON-0031","category":"Hygiene/Duplication","title":"Static data files duplicate Firestore-backed content","severity":"S3","effort":"E0","status":"CONFIRMED","final_confidence":75,"consensus_score":1,"sources":["Claude"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Not re-verified; data/ arrays mirror Firestore services for quotes/slogans/glossary","files":["data/slogans.ts","data/recovery-quotes.ts","data/glossary.ts","lib/db/slogans.ts","lib/db/quotes.ts","lib/db/glossary.ts"],"symbols":["recoverySlogans","recoveryQuotes","recoveryGlossary","SlogansService","QuotesService","GlossaryService"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Static content arrays coexist with Firestore services for the same entities","instances":[{"file":"data/slogans.ts","symbol":"recoverySlogans"},{"file":"data/recovery-quotes.ts","symbol":"recoveryQuotes"},{"file":"data/glossary.ts","symbol":"recoveryGlossary"},{"file":"lib/db/slogans.ts","symbol":"SlogansService"},{"file":"lib/db/quotes.ts","symbol":"QuotesService"},{"file":"lib/db/glossary.ts","symbol":"GlossaryService"}]},"why_it_matters":"Unclear source of truth means admin updates in Firestore may not surface where static data is used, and maintaining parallel datasets increases drift risk.","suggested_fix":"Document Firestore as the canonical source, treat data/ as seed-only, and update consumers to use the service layer.","acceptance_tests":["Components no longer import runtime data from data/*","Seed documentation clarifies usage"],"pr_bucket_suggestion":"misc","dependencies":[],"evidence_summary":["Static arrays and Firestore services exist for the same content types"]}
{"canonical_id":"CANON-0032","category":"Hygiene/Duplication","title":"Loading state boilerplate repeated across data-fetching components","severity":"S3","effort":"E1","status":"CONFIRMED","final_confidence":75,"consensus_score":2,"sources":["Claude","Jules"],"confirmations":2,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Pattern reported across admin, widget, and notebook pages with repeated useState-based loading states","files":["components/admin/prayers-tab.tsx","components/admin/dashboard-tab.tsx","components/admin/errors-tab.tsx","components/admin/admin-crud-table.tsx","components/widgets/compact-meeting-countdown.tsx","components/widgets/daily-quote-card.tsx","components/notebook/features/daily-quote-card.tsx","components/notebook/pages/resources-page.tsx","components/notebook/pages/library-page.tsx","components/admin/jobs-tab.tsx"],"symbols":["loading","setLoading","Loader2"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Repeated loading state and spinner patterns across admin, widgets, and notebook components","instances":[{"file":"components/admin/prayers-tab.tsx","symbol":"loading state"},{"file":"components/admin/dashboard-tab.tsx","symbol":"loading state"},{"file":"components/admin/errors-tab.tsx","symbol":"loading state"},{"file":"components/admin/admin-crud-table.tsx","symbol":"loading state"},{"file":"components/widgets/compact-meeting-countdown.tsx","symbol":"loading state"},{"file":"components/notebook/pages/resources-page.tsx","symbol":"loading state"},{"file":"components/notebook/pages/library-page.tsx","symbol":"loading state"},{"file":"components/admin/jobs-tab.tsx","symbol":"loading state"}]},"why_it_matters":"Boilerplate obscures business logic and produces inconsistent error/loading UX across pages.","suggested_fix":"Introduce a shared useAsyncData hook or adopt a data fetching library to centralize loading/error handling.","acceptance_tests":["Components use the shared async helper","Loading/error UX is consistent"],"pr_bucket_suggestion":"hooks-standardization","dependencies":[],"evidence_summary":["Similar useState-based loading patterns across multiple components"]}
{"canonical_id":"CANON-0033","category":"Testing","title":"Cloud Functions lack automated tests","severity":"S1","effort":"E2","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["Claude"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"No functions/src test suite identified; coverage gaps for callable rate limiting/validation","files":["functions/src/index.ts","functions/src/admin.ts","functions/src/security-wrapper.ts"],"symbols":["saveDailyLog","saveJournalEntry","saveInventoryEntry","migrateAnonymousUserData","withSecurityChecks"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Security-critical Cloud Functions operate without automated validation, so regressions in auth, rate limiting, or validation may ship undetected.","suggested_fix":"Add firebase-functions-test-based suites covering happy paths, auth enforcement, validation failures, and rate-limit boundaries.","acceptance_tests":["functions/src/__tests__/index.test.ts exists and runs in CI","Rate limit and validation paths are exercised"],"pr_bucket_suggestion":"tests-hardening","dependencies":["CANON-0002"],"evidence_summary":["No existing tests for Cloud Functions despite security-critical logic"]}
{"canonical_id":"CANON-0034","category":"Hygiene/Duplication","title":"useJournal reimplements auth listener instead of using provider","severity":"S1","effort":"E1","status":"CONFIRMED","final_confidence":85,"consensus_score":2,"sources":["Claude","ChatGPT"],"confirmations":2,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Hook sets up its own onAuthStateChanged instead of relying on AuthProvider","files":["hooks/use-journal.ts","components/providers/auth-provider.tsx"],"symbols":["auth.currentUser","onAuthStateChanged","useAuth"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Parallel auth listeners exist in provider and hook","instances":[{"file":"components/providers/auth-provider.tsx","symbol":"useAuth"},{"file":"hooks/use-journal.ts","symbol":"useJournal"}]},"why_it_matters":"Parallel auth-state sources cause flicker, stale user data, and complicate future auth/App Check hardening.","suggested_fix":"Derive auth state from the shared provider or pass userId explicitly into useJournal; remove direct listeners in the hook.","acceptance_tests":["useJournal relies on AuthProvider state","No duplicate auth listeners registered","Journal pages load without auth flicker"],"pr_bucket_suggestion":"boundaries","dependencies":[],"evidence_summary":["useJournal manages its own auth listener rather than using shared context"]}

{"canonical_id":"CANON-0035","category":"Hygiene/Duplication","title":"Inline badge styles duplicated across pages","severity":"S3","effort":"E0","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["Jules"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Inline Tailwind badge styles repeated in celebration and meetings pages","files":["app/celebration-demo/page.tsx","app/meetings/all/page.tsx"],"symbols":["rounded-full","Badge"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Badge-like UI built with repeated className strings instead of shared component","instances":[{"file":"app/celebration-demo/page.tsx","symbol":"badge styles"},{"file":"app/meetings/all/page.tsx","symbol":"badge styles"}]},"why_it_matters":"Scattered badge styling increases maintenance and risks inconsistent visual language when tokens change.","suggested_fix":"Extract a reusable Badge component (or extend shadcn badge) and replace inline styles.","acceptance_tests":["Badge styles come from shared component","Visual snapshot remains correct"],"pr_bucket_suggestion":"ui-primitives","dependencies":[],"evidence_summary":["Repeated rounded-full badge class strings across pages"]}
{"canonical_id":"CANON-0036","category":"Types/Correctness","title":"Fragmented validation between manual checks and Zod schemas","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["Jules"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Validation logic split across firestore-validation.ts, lib/db, and functions schemas","files":["lib/security/firestore-validation.ts","lib/db/users.ts","functions/src/schemas.ts"],"symbols":["assertUserScope","z.object","isValidUserId"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Manual validators and Zod schemas exist for overlapping entities without shared source","instances":[{"file":"lib/security/firestore-validation.ts","symbol":"manual user checks"},{"file":"functions/src/schemas.ts","symbol":"dailyLogSchema"},{"file":"lib/db/users.ts","symbol":"z.object user schema"}]},"why_it_matters":"Divergent validation rules can accept data on one path and reject on another, creating confusing failures and data integrity gaps.","suggested_fix":"Centralize Zod schemas in a shared module consumed by client and Cloud Functions; deprecate manual regex checks.","acceptance_tests":["Shared schema module used by client and functions","Invalid IDs rejected consistently"],"pr_bucket_suggestion":"types-domain","dependencies":[],"evidence_summary":["Manual regex validation coexists with separate Zod schemas for similar entities"]}
{"canonical_id":"CANON-0037","category":"Next/React Boundaries","title":"Top-level pages marked use client unnecessarily","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":75,"consensus_score":1,"sources":["Jules"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"app/admin and meetings pages tagged use client instead of delegating to leaf client components","files":["app/admin/page.tsx","app/meetings/all/page.tsx","app/celebration-demo/page.tsx"],"symbols":["use client"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Marking entire routes as client components inflates bundle size and reduces SSR benefits across the subtree.","suggested_fix":"Keep page files server components and move interactive pieces into child client components.","acceptance_tests":["use client removed from top-level pages","Build succeeds and interactive sections still function"],"pr_bucket_suggestion":"boundaries","dependencies":[],"evidence_summary":["Multiple top-level pages start with use client"]}
{"canonical_id":"CANON-0038","category":"Types/Correctness","title":"Loose z.record usage leaves schemas overly permissive (suspected)","severity":"S2","effort":"E1","status":"SUSPECTED","final_confidence":50,"consensus_score":1,"sources":["Jules"],"confirmations":0,"suspects":1,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"functions/src/schemas.ts uses z.record(z.string(), z.unknown()) for data payloads","files":["functions/src/schemas.ts"],"symbols":["z.record","z.unknown"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Overly permissive schemas may allow invalid shapes and weaken type safety between client and server.","suggested_fix":"Tighten schemas with explicit unions for known entry types rather than arbitrary records.","acceptance_tests":["Schemas reject unexpected properties in data payloads"],"pr_bucket_suggestion":"types-domain","dependencies":["CANON-0036"],"evidence_summary":["data field defined as record of unknown"]}
{"canonical_id":"CANON-0039","category":"Hygiene/Duplication","title":"Repeated Firestore snapshot mapping without shared helper","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["ChatGPT"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Multiple services/components map snapshot.docs manually with casts","files":["components/admin/admin-crud-table.tsx","components/growth/DailySloganWidget.tsx","lib/db/meetings.ts","lib/db/slogans.ts"],"symbols":["AdminCrudTable","DailySloganWidget","MeetingsService.getAllMeetingsPaginated","SlogansService.getAllSlogans"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"snapshot.docs.map(d => ({id: d.id, ...d.data()}) as T) repeated across modules","instances":[{"file":"components/admin/admin-crud-table.tsx","symbol":"AdminCrudTable"},{"file":"components/growth/DailySloganWidget.tsx","symbol":"DailySloganWidget"},{"file":"lib/db/meetings.ts","symbol":"MeetingsService.getAllMeetingsPaginated"},{"file":"lib/db/slogans.ts","symbol":"SlogansService.getAllSlogans"}]},"why_it_matters":"Mapping logic and casts drift across call sites, hiding schema issues and complicating default handling.","suggested_fix":"Add a shared mapDocsWithId helper (or Firestore converters) and use it across services/admin tables.","acceptance_tests":["npm run lint","npm test","Admin tables and slogan/meeting fetches continue to work via shared helper"],"pr_bucket_suggestion":"firebase-access","dependencies":[]}
{"canonical_id":"CANON-0040","category":"Hygiene/Duplication","title":"Firestore path/constants drift between journal and journalEntries","severity":"S1","effort":"E1","status":"CONFIRMED","final_confidence":85,"consensus_score":1,"sources":["ChatGPT"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Code and rules use both journal and journalEntries while constants cover only one","files":["lib/constants.ts","lib/firestore-service.ts","hooks/use-journal.ts","firestore.rules"],"symbols":["FIRESTORE_COLLECTIONS","buildPath","saveJournalEntry","useJournal"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Mixed collection names across constants, services, hooks, and rules","instances":[{"file":"lib/constants.ts","symbol":"FIRESTORE_COLLECTIONS"},{"file":"lib/firestore-service.ts","symbol":"saveJournalEntry"},{"file":"hooks/use-journal.ts","symbol":"useJournal"},{"file":"firestore.rules","symbol":"match /users/{userId}/journal/{entryId}"}]},"why_it_matters":"String-literal paths drift easily, leading to inconsistent writes and rule gaps.","suggested_fix":"Codify both journal and journalEntries in FIRESTORE_COLLECTIONS/buildPath (or consolidate to one) and update all call sites accordingly.","acceptance_tests":["npm run lint","npm test","Constants tests cover journal path helpers"],"pr_bucket_suggestion":"firebase-access","dependencies":["CANON-0001"]}
{"canonical_id":"CANON-0041","category":"Hygiene/Duplication","title":"Rate limit presets defined but unused for journal/inventory writes","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["ChatGPT"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"RATE_LIMITS defines SAVE_JOURNAL/SAVE_INVENTORY but helpers export only daily log/auth/read limiters","files":["lib/constants.ts","lib/utils/rate-limiter.ts","lib/firestore-service.ts","hooks/use-journal.ts"],"symbols":["RATE_LIMITS","RateLimiter","saveNotebookJournalEntry","addEntry"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Rate limit config exists but is inconsistently applied across write paths","instances":[{"file":"lib/constants.ts","symbol":"RATE_LIMITS.SAVE_JOURNAL"},{"file":"lib/utils/rate-limiter.ts","symbol":"RateLimiter"},{"file":"lib/firestore-service.ts","symbol":"saveNotebookJournalEntry"},{"file":"hooks/use-journal.ts","symbol":"addEntry"}]},"why_it_matters":"Write paths use different or missing client-side throttles, creating inconsistent UX and enforcement assumptions.","suggested_fix":"Export saveJournalLimiter/saveInventoryLimiter using RATE_LIMITS and apply them to journal/inventory writes or route writes through unified services.","acceptance_tests":["npm run lint","npm test","rate-limiter tests cover journal/inventory presets"],"pr_bucket_suggestion":"security-hardening","dependencies":["CANON-0034"]}
{"canonical_id":"CANON-0042","category":"Types/Correctness","title":"useJournal timestamp fallback to Date.now can reorder history","severity":"S1","effort":"E1","status":"CONFIRMED","final_confidence":85,"consensus_score":1,"sources":["ChatGPT"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Missing createdAt/updatedAt defaults to Date.now during snapshot mapping","files":["hooks/use-journal.ts","types/journal.ts"],"symbols":["useJournal","JournalEntry"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Backfilled entries without timestamps get treated as new, reordering history and confusing users.","suggested_fix":"Preserve null/undefined timestamps or derive stable ordering from dateLabel/id instead of Date.now fallbacks.","acceptance_tests":["npm run lint","npm test","Unit test ensures missing timestamps dont become Date.now"],"pr_bucket_suggestion":"types-domain","dependencies":[]}
{"canonical_id":"CANON-0043","category":"Security","title":"Journal writes bypass shared validation and rate limiting","severity":"S1","effort":"E2","status":"CONFIRMED","final_confidence":85,"consensus_score":1,"sources":["ChatGPT"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"useJournal writes directly to Firestore without validation helpers or limiters","files":["hooks/use-journal.ts","lib/security/firestore-validation.ts","lib/firestore-service.ts"],"symbols":["addEntry","assertUserScope","validateUserDocumentPath","saveNotebookJournalEntry"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Multiple write paths to journal use different validation/rate-limit behaviors","instances":[{"file":"hooks/use-journal.ts","symbol":"addEntry"},{"file":"lib/firestore-service.ts","symbol":"saveNotebookJournalEntry"},{"file":"lib/security/firestore-validation.ts","symbol":"assertUserScope"}]},"why_it_matters":"Fragmented validation and throttling make it easier to introduce insecure or inconsistent journal writes.","suggested_fix":"Route all journal writes through FirestoreService/Cloud Functions or at minimum apply shared validation + limiters in useJournal.","acceptance_tests":["npm run lint","npm test","Manual save flows align on validation/limiting"],"pr_bucket_suggestion":"security-hardening","dependencies":["CANON-0034","CANON-0041"]}
{"canonical_id":"CANON-0044","category":"Security","title":"Firestore rules comments conflict with journal write permissions","severity":"S1","effort":"E0","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["ChatGPT"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"Rules comment says Cloud Functions only but allow create/update for owners and App Check commented out","files":["firestore.rules","lib/firestore-service.ts"],"symbols":["match /users/{userId}/journal/{entryId}","saveNotebookJournalEntry"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Mismatch between documented intent and enforcement can cause future hardening to be skipped or misapplied.","suggested_fix":"Align comments with actual policy or enforce Cloud Function-only writes with App Check and rate limiting.","acceptance_tests":["npm run lint","npm test","If enforcing, client writes to journal fail without Cloud Function"],"pr_bucket_suggestion":"security-hardening","dependencies":["CANON-0043"]}
{"canonical_id":"CANON-0045","category":"Testing","title":"No tests cover quote/slogan rotation determinism","severity":"S2","effort":"E1","status":"CONFIRMED","final_confidence":80,"consensus_score":1,"sources":["ChatGPT"],"confirmations":1,"suspects":0,"tool_confirmed_sources":0,"verification_status":"UNVERIFIED","verification_notes":"No unit tests found for getQuoteForToday/getSloganForNow","files":["lib/db/quotes.ts","lib/db/slogans.ts","tests/"],"symbols":["QuotesService.getQuoteForToday","SlogansService.getSloganForNow"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Rotation logic can silently drift with time zone/DST changes without tests.","suggested_fix":"Add frozen-time unit tests covering deterministic selection and boundary hours (12/17) or test shared rotation helper.","acceptance_tests":["npm test","npm run test:coverage"],"pr_bucket_suggestion":"tests-hardening","dependencies":["CANON-0020"]}
PR_PLAN_JSON
{
  "prs": [
    {
      "pr_id": "PR1",
      "title": "Lock down journal writes and enable App Check",
      "goal": "Standardize notebook writes through Cloud Functions, ensure App Check enforcement, and review rules for journal entries.",
      "bucket": "security-hardening",
      "included_canonical_ids": ["CANON-0001","CANON-0002","CANON-0003","CANON-0041","CANON-0043","CANON-0044"],
      "staging": [],
      "risk_level": "high",
      "estimated_effort": "E2",
      "acceptance_tests": ["npm run lint","npm run test"],
      "notes": "Route notebook writes via callable, re-enable App Check, and document rule updates for journal collection."
    },
    {
      "pr_id": "PR2",
      "title": "Unify Firestore access patterns and journal models",
      "goal": "Consolidate Firestore access and journal typing while removing duplicated client writes and admin init boilerplate.",
      "bucket": "firebase-access",
      "included_canonical_ids": ["CANON-0005","CANON-0006","CANON-0007","CANON-0008","CANON-0009","CANON-0024","CANON-0028","CANON-0030","CANON-0031","CANON-0039","CANON-0040"],
      "staging": [],
      "risk_level": "medium",
      "estimated_effort": "E2",
      "acceptance_tests": ["npm run lint","npm run test"],
      "notes": "Pick a single Firestore abstraction, batch/transaction gratitude writes, centralize admin initialization and collection constants, align journal types/nullability, and route slogan widget through services."
    },
    {
      "pr_id": "PR3",
      "title": "Strengthen typing and error boundaries",
      "goal": "Add error type guards, reduce any/unknown casting, and guard client-only APIs from SSR while tightening entity shapes.",
      "bucket": "types-domain",
      "included_canonical_ids": ["CANON-0010","CANON-0011","CANON-0017","CANON-0023","CANON-0036","CANON-0038","CANON-0042"],
      "staging": [],
      "risk_level": "medium",
      "estimated_effort": "E1",
      "acceptance_tests": ["npm run lint","npm run test"],
      "notes": "Introduce error guard utilities, fix localStorage SSR access, align journal schema types, centralize validation schemas, and remove index-signature escape hatches."
    },
    {
      "pr_id": "PR4",
      "title": "Harden rate limiting, storage keys, and listener utilities",
      "goal": "Reduce duplication for rate limiting, localStorage keys, listener patterns, and add missing coverage for write paths.",
      "bucket": "misc",
      "included_canonical_ids": ["CANON-0012","CANON-0013","CANON-0014","CANON-0015","CANON-0016","CANON-0026"],
      "staging": [],
      "risk_level": "medium",
      "estimated_effort": "E2",
      "acceptance_tests": ["npm run lint","npm run test"],
      "notes": "Add tests for critical writes, centralize storage keys, reconcile rate limiter presets and client/server duplication, and consolidate skeleton/listener utilities once verified."
    },
    {
      "pr_id": "PR5",
      "title": "Unify growth card dialogs, notifications, and quote widgets",
      "goal": "Extract shared primitives for growth cards and notifications while deduplicating quote fetching flows.",
      "bucket": "ui-primitives",
      "included_canonical_ids": ["CANON-0018","CANON-0022","CANON-0025","CANON-0035"],
      "staging": [],
      "risk_level": "medium",
      "estimated_effort": "E1",
      "acceptance_tests": ["npm run lint","npm run test"],
      "notes": "Refactor growth cards onto a shared wizard, centralize toast/notification handling, provide a shared quote-of-the-day hook/provider, and add a reusable Badge primitive."
    },
    {
      "pr_id": "PR6",
      "title": "Consolidate content rotation and CRUD factories",
      "goal": "Create shared utilities for time-based content rotation and Firestore CRUD boilerplate across DB services.",
      "bucket": "hooks-standardization",
      "included_canonical_ids": ["CANON-0020","CANON-0021","CANON-0029","CANON-0032","CANON-0045"],
      "staging": [],
      "risk_level": "medium",
      "estimated_effort": "E2",
      "acceptance_tests": ["npm run lint","npm run test"],
      "notes": "Extract rotation helpers for quotes/slogans and introduce a createCrudService factory to reduce duplicated DB boilerplate."
    },
    {
      "pr_id": "PR7",
      "title": "Increase coverage for auth and DB services",
      "goal": "Address critical coverage gaps for account linking and Firestore services.",
      "bucket": "tests-hardening",
      "included_canonical_ids": ["CANON-0019","CANON-0027","CANON-0033"],
      "staging": [],
      "risk_level": "medium",
      "estimated_effort": "E2",
      "acceptance_tests": ["npm run test"],
      "notes": "Add targeted suites for account-linking flows, CRUD services, and Cloud Functions to raise coverage and protect data integrity."
    },
    {
      "pr_id": "PR8",
      "title": "Align journal hook with shared auth state",
      "goal": "Ensure useJournal derives authentication context from the shared provider instead of direct SDK listeners.",
      "bucket": "boundaries",
      "included_canonical_ids": ["CANON-0034","CANON-0037"],
      "staging": [],
      "risk_level": "medium",
      "estimated_effort": "E1",
      "acceptance_tests": ["npm run lint","npm run test"],
      "notes": "Remove duplicate auth listeners in useJournal and drop unnecessary page-level use client directives by isolating interactive leaf components."
    }
  ]
}
```

### HUMAN_SUMMARY

- Top 10 quick wins: CANON-0002 (enable App Check), CANON-0011 (localStorage SSR
  guard), CANON-0007 (shared admin init), CANON-0014 (centralize storage keys),
  CANON-0006 (batch gratitude writes), CANON-0013/CANON-0026 (align rate
  limiters), CANON-0030 (centralize Cloud Function wrapper), CANON-0035 (badge
  primitive), CANON-0040 (journal path constants), CANON-0042 (remove Date.now
  fallback in useJournal).
- Top 5 high-risk/high-payoff refactors: CANON-0001 (journal writes via Cloud
  Function), CANON-0002 (App Check enforcement), CANON-0043 (journal write
  validation/limiting), CANON-0044 (rules/comment alignment for journal),
  CANON-0033 (Cloud Functions test coverage).
- Key duplication clusters to consolidate: Firestore access patterns
  (CANON-0005), admin SDK initialization (CANON-0007), rate limiter
  implementations/configs (CANON-0013, CANON-0026, CANON-0041), storage key
  scatter (CANON-0014), journal type definitions (CANON-0008), growth card
  wizard/save logic (CANON-0018), quote rotation/widgets (CANON-0020,
  CANON-0022, CANON-0045), CRUD boilerplate (CANON-0021), Cloud Function wrapper
  usage (CANON-0030), meeting countdown/widgets (CANON-0029), static data vs
  Firestore content (CANON-0031), loading-state boilerplate (CANON-0032),
  snapshot mapping helper (CANON-0039), journal path constants (CANON-0040),
  badge primitive reuse (CANON-0035), validation schema drift (CANON-0036).
- Items demoted as hallucinations/false positives: None; suspected items remain
  flagged (CANON-0003, CANON-0015, CANON-0016, CANON-0017, CANON-0038) pending
  verification.
- Recommended implementation order: 1) Address security posture (CANON-0001,
  CANON-0002, CANON-0041, CANON-0043, CANON-0044), 2) Remove client/server
  duplication and dual writes (CANON-0005, CANON-0006, CANON-0007, CANON-0024,
  CANON-0028, CANON-0030, CANON-0040), 3) Reconcile journal types/nullability
  and tighten typings (CANON-0008, CANON-0009, CANON-0010, CANON-0011,
  CANON-0023, CANON-0042), 4) Improve coverage and guardrails (CANON-0012,
  CANON-0019, CANON-0027, CANON-0033, CANON-0045), 5) Tackle remaining hygiene
  clusters (CANON-0013, CANON-0014, CANON-0015, CANON-0016, CANON-0017,
  CANON-0018, CANON-0020, CANON-0021, CANON-0022, CANON-0025, CANON-0026,
  CANON-0029, CANON-0031, CANON-0032, CANON-0034, CANON-0035, CANON-0036,
  CANON-0037, CANON-0038, CANON-0039).
