{"source_id":"audit:arch-mood-selector-consolidation","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"app-architecture","impact":"I1","effort":"E1","file":"components/mood-selector.tsx","line":1,"title":"Consolidate duplicate mood selector components - 3 implementations with diverging mood options","description":"Duplicate components diverge over time, creating inconsistent user experience and tripling the maintenance burden for mood-related features","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"arch-mood-selector-consolidation","confidence":85,"why_it_matters":"Duplicate components diverge over time, creating inconsistent user experience and tripling the maintenance burden for mood-related features","content_hash":"46aee9fe9ee7d956ad6fbdc9bac245aebd6fe12cd062dc313eabfd295ffba558","current_approach":"3 separate mood selector implementations exist with different emoji sets and mood option arrays. Each has diverged over time","proposed_outcome":"Single configurable MoodSelector component with props for mood options, allowing each usage to specify its variant while sharing core selection logic","counter_argument":"Each selector may serve a different UX context with intentionally different mood options. Consolidation could create an overly complex component that is harder to maintain than 3 simple ones","evidence":"3 mood selector implementations found with different emoji sets across components/","id":"ENH-0004"}
{"source_id":"audit:arch-meeting-time-parsing-dedup","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"app-architecture","impact":"I1","effort":"E1","file":"components/meetings/meeting-form.tsx","line":1,"title":"Extract meeting time parsing logic - ~80 lines duplicated between 2 files","description":"Duplicated parsing logic is a bug magnet - fixes applied to one copy but not the other create subtle inconsistencies","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"arch-meeting-time-parsing-dedup","confidence":88,"why_it_matters":"Duplicated parsing logic is a bug magnet - fixes applied to one copy but not the other create subtle inconsistencies","content_hash":"cb65b99a552e61c678a38dfccc79eb8ffb46f3f8c4b51e5ac3a7ff047498bb8b","current_approach":"Meeting time parsing logic (~80 lines) is duplicated between meeting-form.tsx and meeting-list.tsx with slightly different implementations","proposed_outcome":"Extract into a shared parseMeetingTime utility in lib/ or hooks/, used by both components","counter_argument":"The duplication is small (~80 lines) and each version may have context-specific edge cases. Extracting could create coupling between unrelated components","evidence":"~80 lines of time parsing duplicated between 2 meeting component files","id":"ENH-0005"}
{"source_id":"audit:arch-useauth-migration","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"app-architecture","impact":"I1","effort":"E2","file":"hooks/useAuth.ts","line":1,"title":"Migrate useAuth consumers to focused hooks - 16 components still using deprecated hook","description":"Focused hooks prevent unnecessary re-renders when only user or only todayLog changes, improving perceived performance especially on mobile","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"arch-useauth-migration","confidence":82,"why_it_matters":"Focused hooks prevent unnecessary re-renders when only user or only todayLog changes, improving perceived performance especially on mobile","content_hash":"c872af9b335031e005bfd106ad85d344e15dc5644449820493699c703a7442e3","current_approach":"16 components still use the deprecated useAuth() hook which returns the full auth context, while 2 focused hooks (useUser, useTodayLog) exist but are underutilized","proposed_outcome":"Migrate all 16 components to use focused hooks (useUser for stable user data, useTodayLog for volatile daily data), reducing unnecessary re-renders","counter_argument":"The migration requires touching 16 files with potential for regressions. The deprecated hook still works correctly, just triggers extra re-renders. The performance impact may be negligible","evidence":"16 components import useAuth vs 2 using focused hooks. Auth context is split into AuthProvider (stable) and TodayLogProvider (volatile)","id":"ENH-0006"}
{"source_id":"audit:arch-form-state-extraction","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"app-architecture","impact":"I2","effort":"E2","file":"components/journal/journal-entry-form.tsx","line":1,"title":"Extract common form state logic - ~150 lines of duplicate submission handling","description":"Reduces boilerplate in form components and ensures consistent error handling and user feedback patterns","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"arch-form-state-extraction","confidence":78,"why_it_matters":"Reduces boilerplate in form components and ensures consistent error handling and user feedback patterns","content_hash":"6ab0d7f9d41947523f59e027a4ae2eabf98daff3f7ee325c3a21fe40018044e6","current_approach":"Multiple form components duplicate submission handling logic (~150 lines): loading state, error state, validation, toast notifications, and optimistic updates","proposed_outcome":"Create a useFormSubmission hook encapsulating common patterns: loading/error state, validation, toast feedback, and retry logic","counter_argument":"Each form has unique validation and submission logic. A generic hook could become overly abstract and harder to debug than straightforward per-form code","evidence":"~150 lines of similar submission handling found across 3+ form components","id":"ENH-0007"}
{"source_id":"audit:arch-barrel-exports","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"app-architecture","impact":"I1","effort":"E1","file":"components/features/index.ts","line":1,"title":"Create barrel exports for component directories - only 1 exists","description":"Cleaner imports improve code readability and make refactoring easier since internal file moves don't break external imports","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"arch-barrel-exports","confidence":75,"why_it_matters":"Cleaner imports improve code readability and make refactoring easier since internal file moves don't break external imports","content_hash":"d5dd2bf9b3df896d14149e0990a9768ad732f552c1919470ad17851286bdd229","current_approach":"Only 1 barrel export file exists (features/index.ts). Other directories use direct file imports creating long import paths","proposed_outcome":"Add index.ts barrel exports to major component directories (components/journal/, components/meetings/, components/daily-log/) for cleaner imports","counter_argument":"Barrel exports can cause larger bundle sizes if tree-shaking is not configured properly. They also create circular dependency risks and can slow down IDE auto-imports","evidence":"Only 1 barrel export found. 38 default exports vs 69 named exports showing no consistent convention","id":"ENH-0008"}
{"source_id":"audit:arch-quote-collocation","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"app-architecture","impact":"I2","effort":"E3","file":"components/quotes/","line":1,"title":"Collocate related quote components - 3 variants scattered across 2 directories","description":"Scattered related components make it harder to understand the full quote feature surface area and increase risk of unintentional divergence","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"arch-quote-collocation","confidence":72,"why_it_matters":"Scattered related components make it harder to understand the full quote feature surface area and increase risk of unintentional divergence","content_hash":"9e6f94eec4caeb34fc367f2a6b22457c047a3399c740616e826d84b7edeac609","current_approach":"3 quote component variants are scattered across 2 different directories (components/quotes/ and components/daily-log/)","proposed_outcome":"Collocate all quote-related components in a single components/quotes/ directory with clear naming for each variant","counter_argument":"Components may be intentionally placed near their primary consumers. Moving them could break the intuitive colocation-by-usage pattern","evidence":"3 quote variants found across 2 directories","id":"ENH-0009"}
{"source_id":"audit:arch-export-style-standardize","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"app-architecture","impact":"I0","effort":"E1","file":"multiple","line":0,"title":"Standardize export style - 38 default vs 69 named exports with no convention","description":"Consistent exports improve IDE support (auto-imports work better with named exports) and prevent the common default-export renaming issue","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"arch-export-style-standardize","confidence":70,"why_it_matters":"Consistent exports improve IDE support (auto-imports work better with named exports) and prevent the common default-export renaming issue","content_hash":"9e1c2b6810434bb5ce722a5a311144d6e54f5b6eebf30884b13b02c691699781","current_approach":"Mixed export styles: 38 default exports and 69 named exports in component files with no documented convention","proposed_outcome":"Adopt named exports as the standard (better refactoring support, explicit imports) and add ESLint rule to enforce","counter_argument":"This is largely a stylistic preference with minimal functional impact. The refactor touches many files for cosmetic benefit and could conflict with Next.js page conventions","evidence":"38 default exports vs 69 named exports found across components/","id":"ENH-0010"}
{"source_id":"audit:arch-loading-states-consistency","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"app-architecture","impact":"I2","effort":"E2","file":"multiple","line":0,"title":"Inconsistent loading states - spinners vs text vs skeletons across components","description":"Consistent loading patterns create a more polished, professional feel and reduce perceived load times when users know what to expect","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"arch-loading-states-consistency","confidence":76,"why_it_matters":"Consistent loading patterns create a more polished, professional feel and reduce perceived load times when users know what to expect","content_hash":"7e31a69071396a056a6c1d68ec49aaf90b79457e754cb6e722be615a93c7f60b","current_approach":"Loading states are inconsistent: some components use skeleton screens, others use spinner icons, and some show plain Loading... text","proposed_outcome":"Standardize on skeleton loading states (already have infrastructure) with a shared LoadingSkeleton component library for common patterns","counter_argument":"Different loading patterns may be intentional for different contexts (brief loads vs long loads vs initial page loads). Forcing uniformity could worsen UX in some cases","evidence":"Mix of skeleton, spinner, and text loading states found across components","id":"ENH-0011"}
{"source_id":"audit:arch-daily-quote-caching","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"app-architecture","impact":"I3","effort":"E0","file":"hooks/useDailyQuote.ts","line":1,"title":"useDailyQuote hook has smart module-level caching preventing duplicate fetches","description":"Prevents unnecessary API calls and ensures consistent data across components","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"arch-daily-quote-caching","confidence":90,"why_it_matters":"Prevents unnecessary API calls and ensures consistent data across components","content_hash":"a1c717761b8b12e9c1458ceef1c529bfb106f60b3ddc3a02dffb2eead24e82f6","current_approach":"useDailyQuote uses module-level caching to prevent duplicate fetches across 3 component variants that all need the daily quote","proposed_outcome":"No change needed - this is a strength. Consider documenting this pattern for reuse in other hooks","counter_argument":"N/A - strength finding","evidence":"Module-level cache variable in useDailyQuote.ts shared across 3 consumers","id":"ENH-0012"}
{"source_id":"audit:content-generic-submit-buttons","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"content","impact":"I2","effort":"E0","file":"components/journal/journal-entry-form.tsx","line":1,"title":"Generic button labels - Submit used instead of action-specific text","description":"Action-specific button labels reduce cognitive load and confirm what will happen when clicked","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"content-generic-submit-buttons","confidence":88,"why_it_matters":"Action-specific button labels reduce cognitive load and confirm what will happen when clicked","content_hash":"3283aaaf2d2330fb5c90c783f9cc3bee4e510df26c5e8849150620a5ae051f2b","current_approach":"Several forms use generic Submit or Save button labels instead of action-specific text","proposed_outcome":"Replace with action-specific labels: Save Journal Entry, Schedule Meeting, Log Mood","counter_argument":"Generic labels are universally understood; action-specific labels add translation burden; Submit is a standard web convention","evidence":"Generic Submit/Save buttons found in form components","id":"ENH-0013"}
{"source_id":"audit:content-unhelpful-error-messages","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"content","impact":"I1","effort":"E1","file":"multiple","line":0,"title":"Error messages don't guide user to fix the problem","description":"Actionable error messages reduce support burden and user frustration, especially for daily-use apps","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"content-unhelpful-error-messages","confidence":82,"why_it_matters":"Actionable error messages reduce support burden and user frustration, especially for daily-use apps","content_hash":"a065d61230d513ecdb66c805063e4c6929aebdb9c46e1fc4b11bdcb4febbde8d","current_approach":"Error messages show what went wrong but not how to fix it (e.g., Something went wrong without next steps)","proposed_outcome":"Add actionable guidance to error messages: what failed, why, and what to try next","counter_argument":"Detailed error messages can be confusing; recovery-domain users may find technical details stressful; generic messages are simpler to maintain","evidence":"Error handling shows generic messages like Something went wrong or An error occurred","id":"ENH-0014"}
{"source_id":"audit:content-missing-empty-states","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"content","impact":"I2","effort":"E1","file":"multiple","line":0,"title":"Missing empty states for lists and data views","description":"Good empty states guide new users and reduce the feeling that something is broken","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"content-missing-empty-states","confidence":85,"why_it_matters":"Good empty states guide new users and reduce the feeling that something is broken","content_hash":"b29b0ce6899643335283d43fbd090d87e82519603c68881da4122e523aba656d","current_approach":"Empty lists show no content or a minimal No items found message without guidance","proposed_outcome":"Add empty state components with illustration, message, and CTA: No journal entries yet - Start your first entry","counter_argument":"Empty states add component complexity; users may not see them often after initial setup; recovery domain may not need encouragement-style CTAs","evidence":"List components render nothing or minimal text when data arrays are empty","id":"ENH-0015"}
{"source_id":"audit:content-inconsistent-terminology","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"content","impact":"I2","effort":"E1","file":"multiple","line":0,"title":"Inconsistent terminology - meeting vs session vs appointment","description":"Inconsistent terminology confuses users and makes the app feel less professional","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"content-inconsistent-terminology","confidence":78,"why_it_matters":"Inconsistent terminology confuses users and makes the app feel less professional","content_hash":"5a4712793b1ca9cbbe3ffe2139597d9c9c4569c277a057b0abfba44fe0133986","current_approach":"Mixed terminology for the same concept: meeting, session, and appointment used interchangeably across the UI","proposed_outcome":"Standardize on one term (meeting is most common) and create a terminology guide","counter_argument":"Different terms may be contextually appropriate; forcing one term could sound awkward in some contexts; recovery community may have preferred terminology","evidence":"Multiple terms for same concept found across meeting-related components","id":"ENH-0016"}
{"source_id":"audit:content-vague-confirmation-dialogs","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"content","impact":"I2","effort":"E0","file":"multiple","line":0,"title":"Confirmation dialogs lack specific consequences","description":"Users need to understand consequences before destructive actions, especially for personal recovery data","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"content-vague-confirmation-dialogs","confidence":80,"why_it_matters":"Users need to understand consequences before destructive actions, especially for personal recovery data","content_hash":"1e8cd4409dd17a096819801a7bc7c9b3c2079c0ff0b3e9edc52f29a5a1361c98","current_approach":"Delete confirmations use generic Are you sure? without explaining what will be lost","proposed_outcome":"Add specific consequences: Delete this journal entry from Jan 5? This cannot be undone.","counter_argument":"Specific messages require dynamic content which adds complexity; generic confirmations are industry standard; over-specific messages can feel patronizing","evidence":"Confirmation dialogs found with generic Are you sure? messaging","id":"ENH-0017"}
{"source_id":"audit:content-loading-text-inconsistent","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"content","impact":"I3","effort":"E0","file":"multiple","line":0,"title":"Loading text inconsistency - Loading... vs Fetching vs spinner only","description":"Consistent loading patterns create a more cohesive, polished user experience","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"content-loading-text-inconsistent","confidence":85,"why_it_matters":"Consistent loading patterns create a more cohesive, polished user experience","content_hash":"fe4bc07fa97ff9815481e9fd523448377be0684ce344982c8f59dae9c76d11b8","current_approach":"Loading states use different text: Loading..., Fetching data, or just a spinner with no text","proposed_outcome":"Standardize loading text or use consistent skeleton screens across all loading states","counter_argument":"Varying loading text is natural and not confusing; users understand all variants; standardizing is cosmetic","evidence":"Multiple loading text variants found across app and component directories","id":"ENH-0018"}
{"source_id":"audit:content-date-format-inconsistent","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"content","impact":"I2","effort":"E1","file":"multiple","line":0,"title":"Date formats inconsistent across the app","description":"Inconsistent date formats reduce readability and make the app feel unpolished","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"content-date-format-inconsistent","confidence":82,"why_it_matters":"Inconsistent date formats reduce readability and make the app feel unpolished","content_hash":"6e2a201fe78b737a066cefa54161126f4218c1a9b19b9563218ad9f162c89391","current_approach":"Dates displayed in different formats: Jan 5, 2026 vs 1/5/2026 vs 2026-01-05 across different views","proposed_outcome":"Create a shared formatDate utility with consistent format (e.g., Jan 5, 2026 for display, ISO for data)","counter_argument":"Different contexts may warrant different formats (tables vs cards vs headers); a utility adds indirection; current formatting works","evidence":"Multiple date formatting approaches found across components and lib files","id":"ENH-0019"}
{"source_id":"audit:content-brief-success-messages","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"content","impact":"I3","effort":"E0","file":"multiple","line":0,"title":"Success feedback messages too brief","description":"Contextual success messages confirm the user's action and build confidence that the right thing was saved","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"content-brief-success-messages","confidence":75,"why_it_matters":"Contextual success messages confirm the user's action and build confidence that the right thing was saved","content_hash":"af7b8168843d70363a4eecbb95caea13704e89bfe4d8c5ceae72bccc0e53f9d2","current_approach":"Success toasts show minimal text like Saved or Updated without confirming what was saved","proposed_outcome":"Add context to success messages: Journal entry saved for Jan 5 or Meeting updated to 3:00 PM","counter_argument":"Brief success messages are less intrusive; adding context requires passing data to toast; toasts should be dismissible not informational","evidence":"Toast notifications with minimal text observed in form submission handlers","id":"ENH-0020"}
{"source_id":"audit:devx-precommit-parallel","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"devx-automation","impact":"I1","effort":"E2","file":".husky/pre-commit","line":1,"title":"Pre-commit hook parallelization - sequential checks could run 40% faster","description":"With 361 commits in 2 weeks, even 1-2s savings per commit adds up to 6-12 minutes of developer time saved","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"devx-precommit-parallel","confidence":80,"why_it_matters":"With 361 commits in 2 weeks, even 1-2s savings per commit adds up to 6-12 minutes of developer time saved","content_hash":"f4428f00a0ac63a817b9e4aff3c401876a9ef0a8c160cc6beacf95da842c5d56","current_approach":"Pre-commit runs 13 validation gates sequentially (ESLint, lint-staged, pattern compliance, tests, skill validation, cross-doc deps, doc index, doc headers, agent compliance). Total time 3-5s per commit","proposed_outcome":"Run independent checks in parallel (ESLint + pattern compliance + skill validation can all run concurrently), reducing total time to 2-3s","counter_argument":"Sequential execution provides clear error messages in order of importance. Parallel execution would interleave output and make failures harder to diagnose. The 1-2s savings may not justify the complexity","evidence":"Pre-commit hook is 279 lines with 13 sequential validation gates","id":"ENH-0021"}
{"source_id":"audit:devx-ci-nonblocking-checks","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"devx-automation","impact":"I1","effort":"E1","file":".github/workflows/ci.yml","line":1,"title":"CI non-blocking checks should block - 5 checks use continue-on-error","description":"Non-blocking checks that always pass provide false confidence. If they fail silently, issues accumulate undetected","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"devx-ci-nonblocking-checks","confidence":85,"why_it_matters":"Non-blocking checks that always pass provide false confidence. If they fail silently, issues accumulate undetected","content_hash":"d5cfa41c71b0b6902813f381c76028331351ab7ac0b4439a56a8a3d64cb3b86c","current_approach":"5 CI checks use continue-on-error: true, including pattern compliance and debt views, allowing failures to merge","proposed_outcome":"Make pattern compliance and debt view checks blocking in CI. Keep only cosmetic/advisory checks as non-blocking","counter_argument":"Non-blocking checks were set that way intentionally to avoid blocking PRs on non-critical issues during rapid development. Tightening could slow PR velocity","evidence":"5 checks with continue-on-error: true in ci.yml","id":"ENH-0022"}
{"source_id":"audit:devx-script-consolidation","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"devx-automation","impact":"I2","effort":"E3","file":"multiple","line":0,"title":"Script consolidation - 30+ check/validate/sync scripts with inconsistent CLI patterns","description":"Consistent CLI patterns reduce cognitive load and make scripts easier to discover, document, and maintain","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"devx-script-consolidation","confidence":75,"why_it_matters":"Consistent CLI patterns reduce cognitive load and make scripts easier to discover, document, and maintain","content_hash":"9d337f3f05e4843f7851fe2da7d314d4677a379bf57678e6a3c77055a1d4ce7e","current_approach":"30+ individual scripts (check-pattern-compliance.js, check-docs-light.js, check-review-needed.js, validate-phase-completion.js, sync-sonarcloud.js, etc.) each with different CLI argument parsing and output formats","proposed_outcome":"Consolidate into unified CLI with subcommands: sonash check patterns, sonash check docs, sonash validate phase, etc. Share common arg parsing and output formatting","counter_argument":"Each script evolved independently for good reasons and has its own test coverage. Consolidation is a large refactor with high risk of regression and the current system works","evidence":"82 npm scripts in package.json, 85 files in scripts/ directory","id":"ENH-0023"}
{"source_id":"audit:devx-duplicate-pattern-check","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"devx-automation","impact":"I2","effort":"E0","file":".husky/pre-commit","line":1,"title":"Duplicate pattern check runs in both pre-commit and pre-push","description":"Saves 1-2s per push and reduces false graduation in the new graduated enforcement system","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"devx-duplicate-pattern-check","confidence":90,"why_it_matters":"Saves 1-2s per push and reduces false graduation in the new graduated enforcement system","content_hash":"d97f8bad06d572eda1ef8ddae0d45c7d88c7985315583a9dbf9df1e9b33e36a7","current_approach":"npm run patterns:check runs in both pre-commit (blocking) and pre-push (blocking). The pre-push check adds no value since pre-commit already caught violations","proposed_outcome":"Remove pattern check from pre-push hook, keeping only in pre-commit. Pre-push should focus on checks not already done (circular deps, type check, security audit)","counter_argument":"Pre-push is a safety net for cases where pre-commit was bypassed (--no-verify). Defense in depth principle says redundancy is acceptable","evidence":"Both .husky/pre-commit and .husky/pre-push run npm run patterns:check","id":"ENH-0024"}
{"source_id":"audit:devx-ci-build-caching","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"devx-automation","impact":"I2","effort":"E1","file":".github/workflows/ci.yml","line":1,"title":"Missing CI build caching for .next/cache and dist-tests","description":"Faster CI feedback loop improves developer experience and reduces PR merge time","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"devx-ci-build-caching","confidence":82,"why_it_matters":"Faster CI feedback loop improves developer experience and reduces PR merge time","content_hash":"fe59d904ba5f1a940c9f3585e6758af9e61ab608aa59e9f64d9ece9dff6ec2f8","current_approach":"CI builds .next and dist-tests from scratch on every run with no caching","proposed_outcome":"Add GitHub Actions cache for .next/cache and dist-tests/ directories, reducing CI build time by 30-60s per run","counter_argument":"Build caching can cause subtle bugs from stale cached artifacts. Clean builds are more reliable even if slower","evidence":"No cache: actions in ci.yml for build artifacts","id":"ENH-0025"}
{"source_id":"audit:docs-workflow-size-optimization","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"documentation-strategy","impact":"I2","effort":"E2","file":"AI_WORKFLOW.md","line":1,"title":"AI_WORKFLOW.md size optimization - 872 lines may exceed effective AI context loading","description":"Shorter AI instructions mean less token waste per session and faster context loading","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"docs-workflow-size-optimization","confidence":80,"why_it_matters":"Shorter AI instructions mean less token waste per session and faster context loading","content_hash":"3b1c88967981d5fdf9b931f085aa6e9124841b36c8a228cecbe32f4e5d9c6b1f","current_approach":"AI_WORKFLOW.md is 872 lines loaded during session-begin, containing session checklist, skill triggers, and detailed procedures all in one file","proposed_outcome":"Extract procedure details into on-demand reference docs (like CLAUDE.md v5.0 consolidation), keeping AI_WORKFLOW.md to ~200 lines of high-priority checklist items","counter_argument":"The file is only loaded once at session start and has been working well. Splitting could create more cross-reference overhead and make the checklist harder to follow as a single narrative","evidence":"AI_WORKFLOW.md is 872 lines. CLAUDE.md was successfully reduced 77% (497â†’118 lines) in v5.0 with positive results","id":"ENH-0026"}
{"source_id":"audit:docs-stale-todo-tbd-markers","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"documentation-strategy","impact":"I2","effort":"E1","file":"multiple","line":0,"title":"Stale documentation markers - 96 TODO/TBD occurrences across 34 files","description":"Stale TODOs reduce documentation credibility and create confusion about what is actually planned vs abandoned","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"docs-stale-todo-tbd-markers","confidence":85,"why_it_matters":"Stale TODOs reduce documentation credibility and create confusion about what is actually planned vs abandoned","content_hash":"9e294a68948e93acd0a5b3bc1bd4490600390a95bcdfea4eaed69216d519b439","current_approach":"TODO and TBD markers exist in documentation files, some from early sessions that were never resolved","proposed_outcome":"Triage all TODO/TBD markers: resolve, remove, or convert to tracked TDMS items with clear ownership","counter_argument":"Many TODOs serve as useful placeholders for future work and removing them could lose context about intended improvements","evidence":"96 TODO/TBD occurrences found across 34 files via grep","id":"ENH-0027"}
{"source_id":"audit:docs-security-guidance-consolidation","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"documentation-strategy","impact":"I1","effort":"E2","file":"docs/SECURITY.md","line":1,"title":"Security guidance consolidation - multiple overlapping security docs","description":"Duplicated security guidance risks contradictions when one doc is updated but others are not, and increases maintenance burden","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"docs-security-guidance-consolidation","confidence":75,"why_it_matters":"Duplicated security guidance risks contradictions when one doc is updated but others are not, and increases maintenance burden","content_hash":"fa0937c6a6684281331b84bc4ee5664b5a46f8e9d3a7e53958865bdc7bd0ab59","current_approach":"Security guidance is spread across 4+ documents: SECURITY.md, GLOBAL_SECURITY_STANDARDS.md, SECURITY_CHECKLIST.md, and CODE_PATTERNS.md security section","proposed_outcome":"Consolidate into a clear hierarchy: one canonical security reference with other docs referencing it, reducing duplication and potential contradictions","counter_argument":"Each doc serves a different audience/context (pre-write checklist vs patterns reference vs global standards). Consolidation could make each use case harder to serve","evidence":"4 separate security-focused documents with overlapping content on path traversal, error sanitization, and input validation","id":"ENH-0028"}
{"source_id":"audit:docs-effectiveness-metrics","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"documentation-strategy","impact":"I2","effort":"E2","file":"multiple","line":0,"title":"Documentation effectiveness metrics - no tracking of which docs are useful","description":"Data-driven documentation pruning would reduce maintenance burden and focus effort on docs that actually improve outcomes","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"docs-effectiveness-metrics","confidence":70,"why_it_matters":"Data-driven documentation pruning would reduce maintenance burden and focus effort on docs that actually improve outcomes","content_hash":"25ad5444273245049d65d8f9bdab4de2b6a978f05396e1b7152af0eb5cb37c7c","current_approach":"No mechanism to track which documentation files are actually referenced or useful during AI sessions vs rarely touched","proposed_outcome":"Add lightweight doc usage tracking (e.g., log which docs are read during sessions) to identify high-value vs dead-weight documentation","counter_argument":"Adding tracking infrastructure adds complexity and the team already has good intuition about which docs matter. Over-optimization of docs could be premature","evidence":"300+ markdown files in the project, unclear which are actively referenced vs historical","id":"ENH-0029"}
{"source_id":"audit:docs-crossref-navigation-overhead","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"documentation-strategy","impact":"I3","effort":"E1","file":"CLAUDE.md","line":1,"title":"Cross-reference navigation overhead in documentation","description":"Reducing indirection means AI agents and humans can understand guidance without chasing references across files","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"docs-crossref-navigation-overhead","confidence":72,"why_it_matters":"Reducing indirection means AI agents and humans can understand guidance without chasing references across files","content_hash":"fc05e4dd0854e97a148e18967a941c588883c56a24d5e9eaa5d3b7f3154327c2","current_approach":"Documents frequently use 'See X for details' cross-references, requiring multiple file reads to understand a topic","proposed_outcome":"Inline the most critical 2-3 lines from referenced docs at the point of reference, with link for full details","counter_argument":"Cross-references prevent duplication and are a standard documentation pattern. Inlining creates maintenance burden when the source changes","evidence":"Multiple 'See: docs/agent_docs/...' references in CLAUDE.md and AI_WORKFLOW.md","id":"ENH-0030"}
{"source_id":"audit:nextjs-missing-bundle-config","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"infrastructure","impact":"I1","effort":"E0","file":"12-19","line":0,"title":"Enable Next.js experimental optimizations and bundle analysis","description":"Large map/chart libraries (leaflet, recharts) are imported but not tree-shaken optimally","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"nextjs-missing-bundle-config","confidence":85,"why_it_matters":"Large map/chart libraries (leaflet, recharts) are imported but not tree-shaken optimally","content_hash":"003dfb0ad2c9991097caa5ab719bae3c36e087cc0afd82f21ccc30209e26d13a","current_approach":"Minimal next.config.mjs with only output:export and unoptimized images","proposed_outcome":"Add experimental.optimizePackageImports for heavy libraries (leaflet, recharts, framer-motion), enable bundle analyzer, configure modularizeImports for lucide-react","counter_argument":"Static export mode limits some Next.js optimizations; bundle analyzer adds dev dependency overhead; current build size may already be acceptable","evidence":"app/layout.tsx imports multiple heavy libraries, no dynamic imports detected, meeting-map.tsx imports entire leaflet","id":"ENH-0031"}
{"source_id":"audit:firebase-missing-csp-header","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"infrastructure","impact":"I1","effort":"E1","file":"6-57","line":0,"title":"Add Content-Security-Policy header to Firebase hosting configuration","description":"CSP provides additional layer against XSS attacks; industry best practice for modern web apps","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"firebase-missing-csp-header","confidence":75,"why_it_matters":"CSP provides additional layer against XSS attacks; industry best practice for modern web apps","content_hash":"7dc7d04897a4daffc5e850be50942e3eda0146f36245144e2904a2188dfdb562","current_approach":"Comprehensive security headers excluding CSP","proposed_outcome":"Add CSP header with directives for script-src, style-src, img-src, connect-src (Firebase domains + Google reCAPTCHA), frame-ancestors 'none'","counter_argument":"CSP can break functionality if misconfigured (reCAPTCHA, Firebase SDK, inline styles from Tailwind); requires extensive testing; existing headers provide strong baseline","evidence":"firebase.json has X-Frame-Options, HSTS, X-Content-Type-Options but no CSP","id":"ENH-0032"}
{"source_id":"audit:missing-node-engine-constraint","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"infrastructure","impact":"I1","effort":"E0","file":"1-165","line":0,"title":"Add engines field to root package.json for CI/CD consistency","description":"Ensures consistent Node version across development, CI, and production","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"missing-node-engine-constraint","confidence":90,"why_it_matters":"Ensures consistent Node version across development, CI, and production","content_hash":"c36186a144795590a6f0c264ebf1b87ee8fb1350f9d04a478f8dfcd3b7685fe0","current_approach":"Functions package.json specifies Node 20, root package.json has no engine constraint","proposed_outcome":"Add engines: {node: >=20.0.0} to root package.json matching functions runtime","counter_argument":"Lack of constraint hasn't caused issues; can be restrictive for contributors","evidence":"functions/package.json:14 specifies node 20, root has no engines field","id":"ENH-0033"}
{"source_id":"audit:missing-firestore-rules-file","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"infrastructure","impact":"I2","effort":"E0","file":"72-74","line":0,"title":"Firestore security rules file not found in repository","description":"Security rules are critical infrastructure and should be version controlled for audit trail","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"missing-firestore-rules-file","confidence":70,"why_it_matters":"Security rules are critical infrastructure and should be version controlled for audit trail","content_hash":"7c9e7898006c8ad9e6f88a48f8e5cbef6688ac2a36fef0f8303cce32d48454cc","current_approach":"firebase.json references firestore.rules but file not found in repo","proposed_outcome":"Ensure firestore.rules is tracked in repository, or confirm if managed via Firebase console","counter_argument":"Rules may be managed through Firebase console only; file might exist but search missed it","evidence":"firebase.json:73 references firestore.rules, no .rules files found in glob search","id":"ENH-0034"}
{"source_id":"audit:missing-ci-build-cache","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"infrastructure","impact":"I1","effort":"E1","file":"next.config.mjs","line":12,"title":"Configure Next.js build cache and dependency caching for faster CI builds","description":"Faster feedback loops for PRs; reduced CI minutes consumption","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"missing-ci-build-cache","confidence":80,"why_it_matters":"Faster feedback loops for PRs; reduced CI minutes consumption","content_hash":"8520bf7fe09bcdfd0c07231c75470b20fc0cdb07c292d3017c5495fe9ff6845d","current_approach":"No cache configuration for .next/cache or node_modules in CI","proposed_outcome":"Cache .next/cache, node_modules, and functions/lib directories; reduces build time 50-70%","counter_argument":"Cache invalidation can cause issues; storage costs; builds may already be fast enough","evidence":"tsconfig.json:15 has incremental: true, no CI cache actions found","id":"ENH-0035"}
{"source_id":"audit:heavy-libs-no-dynamic-import","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"infrastructure","impact":"I1","effort":"E2","file":"1-80","line":0,"title":"Lazy load Leaflet and Recharts with dynamic imports and Suspense","description":"Not all users visit map/chart pages; faster time-to-interactive for initial load","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"heavy-libs-no-dynamic-import","confidence":75,"why_it_matters":"Not all users visit map/chart pages; faster time-to-interactive for initial load","content_hash":"7e2c65026a95f1d1026405accf29e3d01f76671b154a71b177727bb7103bcbbf","current_approach":"Direct synchronous imports of leaflet (500KB+) and recharts (400KB+)","proposed_outcome":"Use Next.js dynamic() with ssr: false for map components, React.lazy for charts","counter_argument":"Static export mode may limit code splitting benefits; components may be on initial page load; adds loading state complexity","evidence":"meeting-map.tsx imports full leaflet synchronously, no dynamic imports for recharts","id":"ENH-0036"}
{"source_id":"audit:functions-runtime-node20-upgrade","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"infrastructure","impact":"I0","effort":"E1","file":"firebase.json","line":68,"title":"Upgrade Firebase Functions to Node.js 24 runtime","description":"Longer LTS support window; aligns with bleeding-edge philosophy of the project","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"functions-runtime-node20-upgrade","confidence":70,"why_it_matters":"Longer LTS support window; aligns with bleeding-edge philosophy of the project","content_hash":"5167d30899d81a430b8951ab0e6e705a7b9e38d03ae0e902a9ebf077008637b8","current_approach":"Firebase Functions using Node.js 20 runtime","proposed_outcome":"Upgrade to nodejs24 runtime, update engines to node 24, test all functions","counter_argument":"Node 20 is still LTS until October 2026; no compelling features for this use case; risk of breaking changes","evidence":"firebase.json:68 shows nodejs24 available, functions uses node 20","id":"ENH-0037"}
{"source_id":"audit:security-logs-missing-user-timestamp-index","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"infrastructure","impact":"I1","effort":"E0","file":"18-80","line":0,"title":"Add composite index for userId + timestamp on security_logs collection","description":"Admin panel likely needs per-user security logs; composite index prevents full collection scans","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"security-logs-missing-user-timestamp-index","confidence":85,"why_it_matters":"Admin panel likely needs per-user security logs; composite index prevents full collection scans","content_hash":"e65f46b2d1ed2d911094d758001a5bcda840a3b7a3c9380d8b2468f35868199d","current_approach":"Indexes for severity+timestamp, type+functionName+timestamp, but no userId composite","proposed_outcome":"Add index for security_logs: [userId ASC, timestamp DESC] for efficient user-specific log queries","counter_argument":"Query may not exist yet; automatic indexing warnings will prompt when needed; adds storage overhead","evidence":"firestore.indexes.json has security_logs indexes but only severity/type/functionName composites","id":"ENH-0038"}
{"source_id":"audit:testing-cf-integration-missing","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"testing-strategy","impact":"I2","effort":"E2","file":"multiple","line":0,"title":"Missing Cloud Functions integration tests - only 1 skipped test exists","description":"Mock-only testing misses real Firestore query behavior, security rules, rate limiting, and function-to-function interactions","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"testing-cf-integration-missing","confidence":85,"why_it_matters":"Mock-only testing misses real Firestore query behavior, security rules, rate limiting, and function-to-function interactions","content_hash":"b3f68ff4ca901dca8d718fa24c0182695128b35f879f887c5c3650d71280dbcd","current_approach":"Cloud Functions are tested only via mocked httpsCallable; only 1 skipped integration test exists","proposed_outcome":"Add integration tests using Firebase emulator that verify actual Cloud Function behavior, security rules enforcement, and Firestore triggers","counter_argument":"Mock-based tests are faster and more reliable in CI; emulator setup adds complexity; current mocks cover the API contract; integration tests are expensive to maintain","evidence":"1 skipped integration test found; all other Cloud Function tests use mocked httpsCallable","id":"ENH-0039"}
{"source_id":"audit:testing-visual-regression-missing","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"testing-strategy","impact":"I2","effort":"E3","file":"package.json","line":1,"title":"No visual regression testing despite Playwright being installed","description":"Catches unintended CSS/layout regressions that functional tests miss; especially important with Tailwind utility classes that can have subtle side effects","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"testing-visual-regression-missing","confidence":75,"why_it_matters":"Catches unintended CSS/layout regressions that functional tests miss; especially important with Tailwind utility classes that can have subtle side effects","content_hash":"0db794a4ea70aac0c95c748d5c860dfa8c8401b4a3b96bc9e70f51cfd1f9ddf4","current_approach":"Playwright is installed and used for protocol-based UI testing but not for visual regression (screenshot comparison)","proposed_outcome":"Add visual regression tests for key UI states (dashboard, journal entry, mood selector) using Playwright screenshot comparison","counter_argument":"Visual regression tests are brittle, require baseline maintenance, and break on intentional design changes; protocol tests already verify UI behavior; overhead may not be worth it for a small team","evidence":"Playwright in dependencies; 28 .protocol.json files exist but no screenshot comparison tests","id":"ENH-0040"}
{"source_id":"audit:testing-coverage-not-enforced","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"testing-strategy","impact":"I1","effort":"E1","file":"10-12","line":0,"title":"Coverage thresholds not enforced despite c8 being available","description":"Without thresholds, coverage can silently decrease as new code is added without tests","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"testing-coverage-not-enforced","confidence":90,"why_it_matters":"Without thresholds, coverage can silently decrease as new code is added without tests","content_hash":"8f51f0e25326ed79fd4a2bdbb1ac44fad999285e34cdd37631eccdd55bbb1f0b","current_approach":"c8 coverage tool is configured (npm run test:coverage) but no minimum thresholds are set or enforced in CI","proposed_outcome":"Add c8 configuration with minimum thresholds (e.g., 60% lines, 50% branches) and enforce in CI pipeline","counter_argument":"Arbitrary coverage thresholds encourage writing low-value tests to hit numbers; current test suite focuses on critical paths which is more valuable; enforcing could slow development","evidence":"npm run test:coverage exists but no --check-coverage flags or .c8rc configuration found","id":"ENH-0041"}
{"source_id":"audit:testing-script-coverage-low","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"testing-strategy","impact":"I2","effort":"E2","file":"multiple","line":0,"title":"Limited script testing - 5 test files for 60+ npm scripts","description":"Script bugs cause cascading failures in the entire development pipeline; the pattern checker and security checker are critical infrastructure","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"testing-script-coverage-low","confidence":80,"why_it_matters":"Script bugs cause cascading failures in the entire development pipeline; the pattern checker and security checker are critical infrastructure","content_hash":"1acae8d55f7acde3af50f6b085d86884d1097918328c19f6c50c4d48691ca0b1","current_approach":"Only ~5 test files cover scripts functionality despite 60+ npm scripts and 85+ script files","proposed_outcome":"Add targeted tests for high-risk scripts (pattern checker, security checker, debt intake) that run in pre-commit pipeline","counter_argument":"Scripts are validated by the pre-commit/pre-push pipeline itself; adding unit tests for scripts creates a meta-testing problem; scripts change frequently making tests a maintenance burden","evidence":"85 files in scripts/, 60+ npm scripts, only ~5 test files covering script behavior","id":"ENH-0042"}
{"source_id":"audit:testing-performance-benchmarks-missing","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"testing-strategy","impact":"I1","effort":"E2","file":"multiple","line":0,"title":"No performance benchmarks for pagination and data loading","description":"Performance regressions are hard to detect in code review; automated benchmarks catch them before users notice","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"testing-performance-benchmarks-missing","confidence":75,"why_it_matters":"Performance regressions are hard to detect in code review; automated benchmarks catch them before users notice","content_hash":"5d79ab8be235536887ad72812126e1c9fcd1e9c44f1322de54015b72d32081c7","current_approach":"Performance testing is manual only; no automated benchmarks for pagination, data loading, or render times","proposed_outcome":"Add performance benchmarks for critical paths: Firestore query times, component render times for large datasets, pagination performance","counter_argument":"Performance benchmarks are environment-dependent and flaky in CI; manual testing catches major regressions; premature optimization without data","evidence":"Pagination and data loading mentioned in ROADMAP as P0 concerns but no automated performance tests exist","id":"ENH-0043"}
{"source_id":"audit:testing-error-boundaries-untested","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"testing-strategy","impact":"I2","effort":"E1","file":"multiple","line":0,"title":"Error boundary and Sentry integration not tested","description":"If error boundaries fail silently, users see white screens instead of graceful fallbacks; if Sentry breaks, errors go unreported","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"testing-error-boundaries-untested","confidence":85,"why_it_matters":"If error boundaries fail silently, users see white screens instead of graceful fallbacks; if Sentry breaks, errors go unreported","content_hash":"7e6628ce6b6b6243eb556a0e22ab5580f8c9a6e521d000705308969a626ce185","current_approach":"Error boundaries and Sentry integration exist but have no test coverage verifying they catch and report errors correctly","proposed_outcome":"Add tests that trigger errors within error boundaries and verify Sentry capture is called with correct context","counter_argument":"Error boundaries are simple React patterns that rarely break; Sentry SDK is well-tested; testing error paths is hard to do meaningfully","evidence":"Sentry integration in lib/sentry.ts, error boundaries in components, no test coverage for either","id":"ENH-0044"}
{"source_id":"audit:testing-rate-limiter-flaky-timing","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"testing-strategy","impact":"I1","effort":"E1","file":"tests/rate-limiter.test.ts","line":1,"title":"Flaky timing in rate limiter tests using real setTimeout","description":"Real timer tests are inherently flaky under CI load and slow down the test suite unnecessarily","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"testing-rate-limiter-flaky-timing","confidence":90,"why_it_matters":"Real timer tests are inherently flaky under CI load and slow down the test suite unnecessarily","content_hash":"53221a6b5a5b98eac890117f69e0d253c11fee7f4a65ab9971ca7f5be6dff105","current_approach":"Rate limiter tests use real setTimeout with actual wall-clock delays (30ms, 72ms, 110ms waits)","proposed_outcome":"Use fake timers (node:test mock timers or sinon) to make tests deterministic and faster","counter_argument":"Real timers test actual behavior; fake timers can mask real timing bugs; current tests pass consistently; the delays are small enough","evidence":"Rate limiter test has explicit setTimeout waits: 30ms, 72ms, 110ms observed in test output","id":"ENH-0045"}
{"source_id":"audit:testing-msw-unused","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"testing-strategy","impact":"I1","effort":"E2","file":"package.json","line":1,"title":"msw installed but unused for API mocking","description":"msw provides more realistic API mocking that catches serialization and request format issues","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"testing-msw-unused","confidence":75,"why_it_matters":"msw provides more realistic API mocking that catches serialization and request format issues","content_hash":"db21889072c6b91c5614d058973c22f4d0983da432079dd0448725cc381a432b","current_approach":"msw (Mock Service Worker) is in dependencies but not used; tests mock at the module level instead","proposed_outcome":"Use msw for API mocking in integration tests to verify actual HTTP request/response patterns","counter_argument":"Module-level mocking is simpler and sufficient for unit tests; msw adds setup complexity; the app uses Firebase SDK not REST APIs; msw may not integrate well with Firebase","evidence":"msw in package.json dependencies but no msw handlers or setup files found in tests/","id":"ENH-0046"}
{"source_id":"audit:ux-missing-aria-nav-tabs","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"product-ux","impact":"I1","effort":"E0","file":"multiple","line":0,"title":"Missing ARIA labels on critical navigation tabs","description":"Navigation is the primary interaction pattern; missing ARIA labels make the app unusable for screen reader users","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"ux-missing-aria-nav-tabs","confidence":88,"why_it_matters":"Navigation is the primary interaction pattern; missing ARIA labels make the app unusable for screen reader users","content_hash":"3a52ba02c4f090188659f2b4264fbe1c3fe793a97eb562fbd8c399a844633db6","current_approach":"Navigation tabs lack aria-label or aria-current attributes for screen reader users","proposed_outcome":"Add aria-label to tab buttons and aria-current='page' to active tab for screen reader navigation","counter_argument":"Current tab styling provides visual indication; screen reader user base may be small; existing focus styles may be sufficient","evidence":"Tab components found without aria-label attributes in navigation components","id":"ENH-0047"}
{"source_id":"audit:ux-small-touch-targets","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"product-ux","impact":"I1","effort":"E1","file":"multiple","line":0,"title":"Small touch targets on mobile - tabs only 8-10px padding","description":"WCAG 2.5.8 requires minimum 44x44px touch targets; small targets cause frustration and errors on mobile","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"ux-small-touch-targets","confidence":85,"why_it_matters":"WCAG 2.5.8 requires minimum 44x44px touch targets; small targets cause frustration and errors on mobile","content_hash":"298310c4d92e49d8015d9dbbd30baf4df2b55d02b96c47913daf16c7d5d08f10","current_approach":"Navigation tabs have minimal padding (8-10px) resulting in touch targets below the recommended 44x44px minimum","proposed_outcome":"Increase tab padding to ensure minimum 44x44px touch targets on mobile, use Tailwind responsive classes","counter_argument":"Current styling may be intentional for compact layout; increasing size could break layout on small screens; most users may not have difficulty","evidence":"Tab components with p-2 (8px) padding observed","id":"ENH-0048"}
{"source_id":"audit:ux-modal-focus-trap-missing","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"product-ux","impact":"I1","effort":"E2","file":"multiple","line":0,"title":"No focus trap management in modals and dialogs","description":"Focus escaping modals is a WCAG 2.4.3 violation and confusing for keyboard and screen reader users","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"ux-modal-focus-trap-missing","confidence":82,"why_it_matters":"Focus escaping modals is a WCAG 2.4.3 violation and confusing for keyboard and screen reader users","content_hash":"51da1d01243e4a11393d5cc0df0301ecce53b52dd5eecf061fd80ec7c15f0dc2","current_approach":"Modal and dialog components don't trap focus, allowing Tab key to navigate to elements behind the modal","proposed_outcome":"Add focus trap to modal components using a lightweight focus-trap library or custom implementation","counter_argument":"Adding focus trap adds complexity; most users don't tab through modals; could interfere with custom keyboard shortcuts","evidence":"Modal components without focus trap implementation or aria-modal attribute","id":"ENH-0049"}
{"source_id":"audit:ux-error-state-illustrations","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"product-ux","impact":"I2","effort":"E2","file":"multiple","line":0,"title":"Missing error state illustrations - plain text errors only","description":"Visual error states are more noticeable and help users understand what went wrong faster","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"ux-error-state-illustrations","confidence":78,"why_it_matters":"Visual error states are more noticeable and help users understand what went wrong faster","content_hash":"0ab82c3284dd80578956d4e74e178be145f2cf06ada7c310f73a41386ed52698","current_approach":"Error states display plain text messages without visual indication (icons, illustrations, or color coding)","proposed_outcome":"Add error illustration components with clear visual hierarchy: icon + message + action button","counter_argument":"Plain text errors are clear and accessible; illustrations add bundle size; recovery domain may benefit from minimal, calm error states","evidence":"Error handling in components uses plain text without icons or illustrations","id":"ENH-0050"}
{"source_id":"audit:ux-loading-skeletons-inconsistent","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"product-ux","impact":"I2","effort":"E2","file":"multiple","line":0,"title":"Missing loading skeletons on data-heavy pages","description":"Consistent loading patterns reduce perceived wait time and create a more polished experience","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"ux-loading-skeletons-inconsistent","confidence":80,"why_it_matters":"Consistent loading patterns reduce perceived wait time and create a more polished experience","content_hash":"4291792f1e6e4e9aa848e542e29fd529a5653772f0da94c25ee8d9d1899ad5bd","current_approach":"Some pages use skeleton loading screens while others show spinners or plain Loading... text","proposed_outcome":"Standardize on skeleton loading for all data-heavy pages (journal, meetings, admin) to match existing skeleton infrastructure","counter_argument":"Skeleton screens are more complex to build and maintain; spinners are universally understood; loading times may be short enough that skeletons flash","evidence":"Mix of skeleton, spinner, and text loading states across app pages","id":"ENH-0051"}
{"source_id":"audit:ux-optimistic-updates-missing","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"product-ux","impact":"I2","effort":"E2","file":"multiple","line":0,"title":"No optimistic updates for form submissions","description":"Optimistic updates make the app feel instant and responsive, improving perceived performance","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"ux-optimistic-updates-missing","confidence":75,"why_it_matters":"Optimistic updates make the app feel instant and responsive, improving perceived performance","content_hash":"f81c09f1c364d10d73e8fc0ad01b03cb31c624f9de114818617bbdc35e9caa30","current_approach":"Form submissions show loading state and wait for server response before updating UI","proposed_outcome":"Implement optimistic updates for common actions (journal entry save, mood logging) with rollback on error","counter_argument":"Optimistic updates add complexity and can show incorrect state if the server rejects; recovery domain may benefit from confirmation that data was truly saved","evidence":"Form components use loading state and await server response before UI update","id":"ENH-0052"}
{"source_id":"audit:ux-keyboard-shortcuts-missing","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"product-ux","impact":"I3","effort":"E2","file":"multiple","line":0,"title":"Missing keyboard shortcuts for power users","description":"Power users who journal daily benefit significantly from keyboard shortcuts for repetitive actions","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"ux-keyboard-shortcuts-missing","confidence":72,"why_it_matters":"Power users who journal daily benefit significantly from keyboard shortcuts for repetitive actions","content_hash":"d760de0600a5339d596e42972599697fae55be680fcaf1a49a3750b49218fb62","current_approach":"No keyboard shortcuts for common actions like creating journal entries or navigating between sections","proposed_outcome":"Add keyboard shortcuts for top 5 actions: new journal entry (Ctrl+N), save (Ctrl+S), navigate tabs (Ctrl+1-5)","counter_argument":"Keyboard shortcuts add complexity and can conflict with browser/OS shortcuts; discovery is poor; few users use them; mobile users can't benefit","evidence":"No keyboard event handlers or shortcut system found in app code","id":"ENH-0053"}
{"source_id":"audit:ux-inline-validation-missing","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"product-ux","impact":"I2","effort":"E2","file":"multiple","line":0,"title":"Form validation shows errors only on submit, not inline","description":"Inline validation prevents form submission failures and helps users correct mistakes in real-time","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"ux-inline-validation-missing","confidence":78,"why_it_matters":"Inline validation prevents form submission failures and helps users correct mistakes in real-time","content_hash":"dde80487c3dea4bbdb1f1b2950d4bbaf776a253b281797313410facce722a0ad","current_approach":"Form validation errors appear only after submission attempt, not as the user types","proposed_outcome":"Add inline validation for required fields and format constraints using Zod schemas already defined","counter_argument":"Inline validation can be annoying if too aggressive; on-submit validation is simpler; Zod schemas are for server-side validation","evidence":"Form components use Zod validation on submit but don't show field-level errors during input","id":"ENH-0054"}
{"source_id":"audit:workflow-session-start-timeout","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"workflow-lifecycle","impact":"I2","effort":"E1","file":".claude/hooks/session-start.js","line":1,"title":"Session-start timeout risks in low-bandwidth environments","description":"In slow network environments, npm commands can hang indefinitely, blocking the entire session start","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"workflow-session-start-timeout","confidence":78,"why_it_matters":"In slow network environments, npm commands can hang indefinitely, blocking the entire session start","content_hash":"5763ef9465654b89a97900c6832116c601e7859b84e49098803d862d207c4e21","current_approach":"Session-start hook runs multiple npm commands and checks synchronously without timeout guards","proposed_outcome":"Add per-step timeouts (e.g., 10s for dependency checks, 30s for builds) with graceful fallback on timeout","counter_argument":"Session-start works reliably in practice; adding timeout logic adds complexity; failures are already handled with try/catch","evidence":"Session-start hook runs npm install, tsc builds, and multiple checks without timeout guards","id":"ENH-0055"}
{"source_id":"audit:workflow-duplicate-hook-validation","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"workflow-lifecycle","impact":"I1","effort":"E2","file":"multiple","line":0,"title":"Duplicate hook validation for Write+Edit+MultiEdit tools","description":"Reduces hook execution time and prevents inconsistent behavior if one tool's handler is updated but others aren't","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"workflow-duplicate-hook-validation","confidence":82,"why_it_matters":"Reduces hook execution time and prevents inconsistent behavior if one tool's handler is updated but others aren't","content_hash":"c2d2d9e1e1912a44ba7c13e319f6cb88c438ed0f5bf92d1e7adc86f0e08fd1a6","current_approach":"Some PostToolUse hooks run the same validation for Write, Edit, and MultiEdit events, tripling execution","proposed_outcome":"Consolidate into single handler that triggers on any file-modifying tool, deduplicating per-file checks","counter_argument":"Each tool type may need different validation logic; consolidation could miss tool-specific edge cases; current duplication is simple and reliable","evidence":"Multiple hooks registered for Write, Edit, and MultiEdit with similar validation logic","id":"ENH-0056"}
{"source_id":"audit:workflow-firebase-deploy-no-rollback","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"workflow-lifecycle","impact":"I2","effort":"E2","file":"firebase.json","line":1,"title":"Firebase deployment lacks rollback on partial failure","description":"Inconsistent deployment state can cause runtime errors when frontend expects API endpoints that haven't deployed","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"workflow-firebase-deploy-no-rollback","confidence":75,"why_it_matters":"Inconsistent deployment state can cause runtime errors when frontend expects API endpoints that haven't deployed","content_hash":"f3f9d7a21727b0e2622bbbc7019e3da4db2386a71ef9431da8f905bc5bde1d4b","current_approach":"Firebase deploy pushes hosting + functions together; if functions fail after hosting succeeds, app is in inconsistent state","proposed_outcome":"Deploy functions first (validate), then hosting. Add rollback script that reverts to previous version on failure","counter_argument":"Firebase hosting is versioned and supports instant rollback via console; partial failures are rare; adding rollback automation adds significant complexity","evidence":"firebase.json configures both hosting and functions targets deployed together","id":"ENH-0057"}
{"source_id":"audit:workflow-ci-duplicate-build","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"workflow-lifecycle","impact":"I1","effort":"E2","file":".github/workflows/ci.yml","line":1,"title":"CI runs full build twice - once for lint, once for test","description":"Reduces CI pipeline duration by eliminating redundant compilation, faster PR feedback","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"workflow-ci-duplicate-build","confidence":80,"why_it_matters":"Reduces CI pipeline duration by eliminating redundant compilation, faster PR feedback","content_hash":"94bf6f9d8c36c339f3413b1c4ca4f2566b31519a047fff923d8965923402a67b","current_approach":"CI pipeline builds the project for linting and then rebuilds for testing, duplicating the compilation step","proposed_outcome":"Build once, share artifacts between lint and test jobs using GitHub Actions cache or artifact upload","counter_argument":"Separate builds ensure isolation; shared artifacts add complexity; CI time may already be acceptable","evidence":"CI workflow has separate build steps for lint and test stages","id":"ENH-0058"}
{"source_id":"audit:workflow-sonarcloud-not-enforced","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"external-services","impact":"I2","effort":"E1","file":".github/workflows/ci.yml","line":1,"title":"SonarCloud not enforced in CI gates","description":"Without enforcement, SonarCloud findings accumulate without accountability, reducing the tool's value","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"workflow-sonarcloud-not-enforced","confidence":85,"why_it_matters":"Without enforcement, SonarCloud findings accumulate without accountability, reducing the tool's value","content_hash":"5817a6c2290c6e432597e3c451a959ab83b8b485ab5890e37c98b717817131d4","current_approach":"SonarCloud analysis runs in CI but results are not used as a gate - PRs can merge even with new issues","proposed_outcome":"Add SonarCloud quality gate check as required status check for PR merge","counter_argument":"SonarCloud quality gates can be overly strict and block PRs for minor issues; team may prefer advisory mode; gate thresholds need tuning first","evidence":"SonarCloud integration exists but not configured as blocking CI check","id":"ENH-0059"}
{"source_id":"audit:workflow-sentry-disabled-dev","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"external-services","impact":"I1","effort":"E1","file":"lib/sentry.ts","line":1,"title":"Sentry disabled in dev mode by default","description":"Some errors only reproduce in specific conditions; having dev errors in Sentry helps identify patterns before they reach production","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"workflow-sentry-disabled-dev","confidence":76,"why_it_matters":"Some errors only reproduce in specific conditions; having dev errors in Sentry helps identify patterns before they reach production","content_hash":"a0beaeb96c7dc968093ed628bb1d3f57034ee049e1a834cc3fdcccabf6dde401","current_approach":"Sentry error tracking only active in production, dev errors go to console only","proposed_outcome":"Enable Sentry in dev mode with reduced sampling rate and dev-specific project/environment tag","counter_argument":"Dev errors are noisy and would pollute Sentry dashboard; console is sufficient for local debugging; adds API calls during development","evidence":"Sentry initialization checks for production environment before enabling","id":"ENH-0060"}
{"source_id":"audit:workflow-hook-performance-untracked","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"workflow-lifecycle","impact":"I2","effort":"E2","file":"multiple","line":0,"title":"Hook performance not tracked - no metrics on execution time","description":"Without metrics, slow hooks accumulate unnoticed, gradually degrading developer experience","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"workflow-hook-performance-untracked","confidence":72,"why_it_matters":"Without metrics, slow hooks accumulate unnoticed, gradually degrading developer experience","content_hash":"d31762760939159e19c99e5aa9b5a6d5f7e4df43f86ab35b47e326bf5c161723","current_approach":"Hooks execute without performance tracking; no visibility into which hooks are slow or how total hook time trends","proposed_outcome":"Add lightweight timing wrapper that logs hook execution times to .claude/state/hook-metrics.jsonl for analysis","counter_argument":"Adding timing to every hook adds overhead; the data may not be actionable; hooks are already fast enough; more infrastructure to maintain","evidence":"20+ hooks in .claude/hooks/ with no execution time tracking","id":"ENH-0061"}
{"source_id":"audit:workflow-firebase-emulator-ci","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"external-services","impact":"I2","effort":"E2","file":".github/workflows/ci.yml","line":1,"title":"Firebase emulator not used in CI for integration tests","description":"Mock-only testing misses real Firestore query behavior, security rules enforcement, and Cloud Function integration issues","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"workflow-firebase-emulator-ci","confidence":74,"why_it_matters":"Mock-only testing misses real Firestore query behavior, security rules enforcement, and Cloud Function integration issues","content_hash":"7a13f39be70942993fa9c31a25a808727d390f7636c118764ab960866e5b6f99","current_approach":"CI tests mock Firebase entirely; no integration tests run against Firebase emulator","proposed_outcome":"Add Firebase emulator to CI pipeline for integration tests that verify actual Firestore queries and Cloud Functions","counter_argument":"Firebase emulator adds significant CI setup time (2-3 min); mocks are sufficient for unit tests; emulator can be flaky in CI; current test strategy works","evidence":"Tests use mocked httpsCallable, no emulator configuration in CI workflow","id":"ENH-0062"}
{"source_id":"audit:workflow-prepush-duplicate-patterns","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"workflow-lifecycle","impact":"I1","effort":"E0","file":".husky/pre-push","line":1,"title":"Pre-push duplicates pre-commit pattern checks","description":"Saves time per push and prevents graduated enforcement self-escalation (warned in pre-commit, blocked in pre-push)","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"workflow-prepush-duplicate-patterns","confidence":88,"why_it_matters":"Saves time per push and prevents graduated enforcement self-escalation (warned in pre-commit, blocked in pre-push)","content_hash":"7ba5e1753427fe64d3043c0e9e4facc8517c418fb8717918d6dce7636b22eaad","current_approach":"Pattern compliance check runs in both pre-commit (blocking) and pre-push (blocking), duplicating 1-2s of work","proposed_outcome":"Remove pattern check from pre-push; rely on pre-commit for pattern enforcement since it already blocks commits","counter_argument":"Pre-push is a safety net for --no-verify commits; defense in depth is valuable; 1-2s is negligible","evidence":"Both .husky/pre-commit and .husky/pre-push run npm run patterns:check","id":"ENH-0063"}
{"source_id":"audit:workflow-session-start-sync-consolidation","source_file":"docs/audits/single-session/enhancements/audit-2026-02-11/merged-all.jsonl","category":"workflow-lifecycle","impact":"I2","effort":"E1","file":".claude/hooks/session-start.js","line":1,"title":"Session-start consolidation check blocks synchronously","description":"Every second added to session-start creates friction and delays the user from starting productive work","recommendation":"","status":"PROPOSED","created":"2026-02-12","verified_by":null,"resolution":null,"fingerprint":"workflow-session-start-sync-consolidation","confidence":75,"why_it_matters":"Every second added to session-start creates friction and delays the user from starting productive work","content_hash":"33bbd6d9110d8c1728d673432e28e34e3df5b31fdad337f70733bef3aa0e31d8","current_approach":"Auto-consolidation check runs synchronously during session-start, adding latency to every session","proposed_outcome":"Run consolidation check asynchronously or defer to first idle moment after session starts","counter_argument":"Consolidation check is fast (<1s usually); async execution could miss showing results to user; synchronous is simpler and more reliable","evidence":"Session-start hook runs consolidation check synchronously before yielding control","id":"ENH-0064"}
