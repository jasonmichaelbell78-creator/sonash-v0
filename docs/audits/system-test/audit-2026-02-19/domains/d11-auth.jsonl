{"id":"SYST-2026-02-19-D11-001","domain":11,"domain_name":"Auth & Session Management","check_id":"11.2","severity":"S2","effort":"E1","category":"security","title":"Implicit localStorage persistence — no session management for shared devices","description":"Firebase Auth is initialized without explicit setPersistence() call. The SDK defaults to browserLocalPersistence (localStorage), meaning sessions survive browser close and device restart. For a recovery community app where users may share devices, this means User B could access User A's data without re-authenticating.","recommendation":"Configure explicit session persistence (browserSessionPersistence) or add re-auth prompt on app launch.","file":"lib/firebase.ts","line":54,"evidence":"lib/firebase.ts:54 → _auth = getAuth(_app); // No setPersistence call\nGrep for setPersistence: 0 results in app code\nGrep for browserSessionPersistence: 0 results\nFirebase default = browserLocalPersistence (sessions survive browser close)","suggested_fix":"Add explicit persistence configuration: import { browserSessionPersistence, setPersistence } from 'firebase/auth'; await setPersistence(auth, browserSessionPersistence); This ensures sessions end when the browser tab closes. Alternatively, add a re-authentication prompt on app launch for sensitive data access.","status":"accepted","suggestion_text":"Accept at S2. Shared device risk is real for recovery community. SESSION persistence or re-auth prompt would mitigate.","counter_argument":"PWA installed on personal mobile (primary use case) benefits from persistent sessions. Shared device is edge case. Adding SESSION persistence would force re-login every browser close, frustrating mobile PWA users.","related_findings":[],"detected_at":"2026-02-19T14:15:00Z","reviewed_at":"2026-02-19T14:20:00Z"}
{"id":"SYST-2026-02-19-D11-002","domain":11,"domain_name":"Auth & Session Management","check_id":"11.4","severity":"S2","effort":"E2","category":"correctness","title":"Anonymous-to-auth migration has partial failure risk with inconsistent success reporting","description":"The migrateAnonymousUserData Cloud Function uses multiple Firestore batch writes that are not atomic across batches. If batch 3 of 5 fails, batches 1-2 are permanently committed with no rollback. Additionally, the Google OAuth migration path in account-linking.ts returns success: true even when migration fails, potentially misleading the user about their data state.","recommendation":"Add migration status tracking and change Google OAuth error path to return success: false when migration fails.","file":"functions/src/index.ts","line":688,"evidence":"functions/src/index.ts:688-722 → Non-atomic batch loop: for (let i = 0; i < batches.length; i++) { await batches[i].commit(); } — catch logs PARTIAL_MIGRATION_FAILURE\naccount-linking.ts:351-361 → Google path catch: returns { success: true, user: result.user, warning: 'Some data may not have transferred' }","suggested_fix":"(A) Add migration status tracking: write a migration_log doc before starting, update on each batch completion. (B) Change Google OAuth error path to return success: false with clear user messaging. (C) Add a 'check migration' Cloud Function that users can call to verify data integrity.","status":"accepted","suggestion_text":"Accept at S2. Non-atomic migration could leave data in inconsistent state. Google path returning success:true on failure is misleading.","counter_argument":"Critical data (journal) migrates first. Rate limiting (5/5min) prevents abuse. Partial migration is better than no migration — returning success:true lets user continue with their authenticated account.","related_findings":["D09-001"],"detected_at":"2026-02-19T14:15:00Z","reviewed_at":"2026-02-19T14:20:00Z"}
{"id":"SYST-2026-02-19-D11-003","domain":11,"domain_name":"Auth & Session Management","check_id":"11.7","severity":"S1","effort":"E2","category":"security","title":"Sign-in and sign-up lack reCAPTCHA protection — primary auth surface unprotected","description":"RECAPTCHA_ACTIONS in secure-caller.ts covers journal, daily log, inventory, and account linking operations. However, sign-in-modal.tsx calls Firebase Auth SDK directly (signInWithEmailAndPassword, createUserWithEmailAndPassword) without any reCAPTCHA token. This leaves the primary authentication surface unprotected against brute force attacks and automated account creation.","file":"components/auth/sign-in-modal.tsx","line":49,"evidence":["sign-in-modal.tsx:49 — await createUserWithEmailAndPassword(auth, email, password) with no reCAPTCHA","sign-in-modal.tsx:51 — await signInWithEmailAndPassword(auth, email, password) with no reCAPTCHA","lib/utils/secure-caller.ts:23-36 — RECAPTCHA_ACTIONS has no sign_in or sign_up action","Contrast: account-linking.ts:201 — getRecaptchaToken('migrate_user_data') — linking IS protected"],"confidence":"HIGH","recommendation":"Add reCAPTCHA Enterprise to sign-in and sign-up flows via Cloud Function wrapper or Firebase App Check's built-in reCAPTCHA integration.","verification_steps":{"first_pass":{"method":"grep","evidence_collected":["grep RECAPTCHA_ACTIONS secure-caller.ts → no sign_in/sign_up entries","grep reCAPTCHA sign-in-modal.tsx → 0 results"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed — sign-in and sign-up paths have no reCAPTCHA protection","reference":"sign-in-modal.tsx:49-51, secure-caller.ts:23-36"}},"suggested_fix":"Add reCAPTCHA Enterprise to sign-in and sign-up flows: (1) Add SIGN_IN and SIGN_UP to RECAPTCHA_ACTIONS, (2) Generate reCAPTCHA token before auth call, (3) Verify token server-side via a Cloud Function wrapper, or use Firebase App Check's built-in reCAPTCHA integration for auth operations.","status":"accepted","suggestion_text":"Accept at S1. Auth endpoints are the primary attack surface. Journal writes are protected but the front door is open.","counter_argument":"Firebase has built-in rate limiting for auth operations (per-IP). reCAPTCHA on sign-in adds friction to onboarding in a recovery app where ease of access is critical. Most users use Google OAuth which has its own protections.","related_findings":["D07-001","D09-005"],"detected_at":"2026-02-19T14:15:00Z","reviewed_at":"2026-02-19T14:20:00Z"}
{"id":"SYST-2026-02-19-D11-004","domain":11,"domain_name":"Auth & Session Management","check_id":"11.8","severity":"S2","effort":"E1","category":"security","title":"Password requirements minimal — 6 characters only, no complexity enforcement","description":"Email/password authentication enforces only a 6-character minimum (Firebase default + client validation in account-link-modal.tsx). No complexity requirements are enforced: no uppercase, numbers, or special characters required. For a recovery community app storing sensitive personal data, this allows trivially guessable passwords.","recommendation":"Enforce minimum 8 characters with mixed case and numbers for email/password authentication.","file":"components/auth/account-link-modal.tsx","line":45,"evidence":"account-link-modal.tsx:45-54 → if (password.length < 6) { setError('Password must be at least 6 characters'); }\nlib/utils/errors.ts:71 → 'auth/weak-password': 'Password should be at least 6 characters'\nNo complexity regex, no strength meter, no server-side validation beyond Firebase 6-char minimum","suggested_fix":"Implement stronger client-side validation: minimum 8 characters, require at least one uppercase, one number, and one special character. Add a password strength meter for UX. Consider using zxcvbn library for realistic strength estimation.","status":"accepted","suggestion_text":"Accept at S2. Minimal password requirements for an app storing sensitive recovery data.","counter_argument":"Most users use Google OAuth. Adding complexity requirements frustrates the few email users. Firebase's rate limiting mitigates brute force. Recovery apps prioritize accessibility over security friction.","related_findings":["D11-003"],"detected_at":"2026-02-19T14:15:00Z","reviewed_at":"2026-02-19T14:20:00Z"}
{"id":"SYST-2026-02-19-D11-005","domain":11,"domain_name":"Auth & Session Management","check_id":"11.9","severity":"S2","effort":"E1","category":"security","title":"Account linking error messages reveal user existence for enumeration","description":"The account linking flow in account-linking.ts returns specific error messages that reveal whether an email is registered: 'This email is already registered. Try signing in instead.' This enables user enumeration attacks. The sign-in flow correctly uses generic 'Invalid email or password' messages, but the linking flow is inconsistent.","recommendation":"Change account linking error messages to generic text that does not reveal user existence.","file":"lib/auth/account-linking.ts","line":82,"evidence":"account-linking.ts:82-85 → 'auth/email-already-in-use': { message: 'This email is already registered. Try signing in instead.' }\naccount-linking.ts:80 → 'auth/credential-already-in-use': { message: 'This email or Google account is already linked to another user.' }\nContrast: sign-in-modal.tsx:59 → 'Invalid email or password.' (generic, correct)","suggested_fix":"Change linking error messages to generic text: 'This email cannot be used for linking. Please try a different email or sign in with your existing account.' Avoid confirming whether the email is registered.","status":"accepted","suggestion_text":"Accept at S2. Inconsistent error messaging — sign-in hides user existence but linking reveals it. Same information leaks through different path.","counter_argument":"Account linking requires an authenticated anonymous session. Attacker must create anonymous sessions to enumerate — low volume. The 'email-already-in-use' case is also informational for legitimate users who forgot they already signed up.","related_findings":["D11-003","D11-004"],"detected_at":"2026-02-19T14:15:00Z","reviewed_at":"2026-02-19T14:20:00Z"}
