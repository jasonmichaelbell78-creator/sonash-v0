{"id":"SYST-2026-02-19-D09-001","domain":9,"domain_name":"Firestore Rules","check_id":"9.8","severity":"S1","effort":"E2","category":"correctness","title":"Admin CRUD for sober_living broken — rules block all client writes","description":"The sober-living admin tab uses direct Firestore client SDK writes (addDoc, updateDoc, deleteDoc via SoberLivingService), but firestore.rules sets 'allow write: if false' for the sober_living collection. All admin write operations for sober living homes will be denied by Firestore in production. The meetings tab correctly uses Cloud Functions (httpsCallable → adminSaveMeeting) which bypass rules via Admin SDK.","file":"firestore.rules","line":98,"evidence":["firestore.rules:98 — allow write: if false; for sober_living collection","components/admin/sober-living-tab.tsx:126-131 uses SoberLivingService (direct client addDoc/updateDoc/deleteDoc)","Contrast: components/admin/meetings-tab.tsx:309 uses cloudFunctions: { saveFunctionName, deleteFunctionName }"],"confidence":"HIGH","recommendation":"Migrate sober-living-tab to use Cloud Functions like meetings-tab (preferred — consistent pattern), or change rules to allow write: if isAdmin() with field validation.","verification_steps":{"first_pass":{"method":"grep","evidence_collected":["grep 'allow write' firestore.rules → sober_living: allow write: if false","grep addDoc components/admin/sober-living-tab.tsx → direct client writes"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed — rules block writes but admin UI uses direct client SDK writes","reference":"firestore.rules:98, sober-living-tab.tsx:126-131"}},"suggested_fix":"Either: (A) Migrate sober-living-tab to use Cloud Functions like meetings-tab (preferred — consistent pattern), or (B) Change rules to 'allow write: if isAdmin()' with field validation. Option A is preferred because it routes writes through server-side validation.","status":"accepted","suggestion_text":"Accept at S1. Admin cannot manage sober living homes in production. The UI exists and appears functional but silently fails on every write operation.","counter_argument":"If sober living data was seeded once and rarely changes, this may not be actively impacting users. But the admin UI exists and appears functional, creating a false sense of capability.","related_findings":["D07-005","D18-002"],"detected_at":"2026-02-19T13:50:00Z","reviewed_at":"2026-02-19T13:55:00Z"}
{"id":"SYST-2026-02-19-D09-002","domain":9,"domain_name":"Firestore Rules","check_id":"9.3","severity":"S2","effort":"E1","category":"security","title":"No field-level validation in rules for admin-writable public collections","description":"Collections daily_quotes, glossary, slogans, quick_links, and prayers allow 'write: if isAdmin()' without any field-level validation. An admin user could write arbitrary fields, incorrect data types, or oversized documents. While admin is trusted, missing validation allows accidental data corruption.","recommendation":"Add field-level validation (keys, types) to admin-writable collection rules.","file":"firestore.rules","line":104,"evidence":"firestore.rules:104 → allow write: if isAdmin(); // daily_quotes\nfirestore.rules:112 → allow write: if isAdmin(); // glossary\nfirestore.rules:117 → allow write: if isAdmin(); // slogans\nfirestore.rules:124 → allow write: if isAdmin(); // quick_links\nfirestore.rules:130 → allow write: if isAdmin(); // prayers\nNone have request.resource.data field validation.","suggested_fix":"Add field validation for each collection, e.g.: allow write: if isAdmin() && request.resource.data.keys().hasAll(['text','author']) && request.resource.data.text is string;","status":"accepted","suggestion_text":"Accept at S2. Admin is trusted, but field validation prevents accidental data corruption from malformed writes or admin UI bugs.","counter_argument":"Admin users are a small trusted group. Adding rules-level validation creates maintenance burden — schema changes require updating both app code and rules.","related_findings":[],"detected_at":"2026-02-19T13:50:00Z","reviewed_at":"2026-02-19T13:55:00Z"}
{"id":"SYST-2026-02-19-D09-003","domain":9,"domain_name":"Firestore Rules","check_id":"9.6","severity":"S2","effort":"E1","category":"security","title":"Soft-deleted documents still readable via Firestore rules","description":"Firestore rules for journal, daily_logs, and inventoryEntries allow read access to all documents owned by the user regardless of isDeleted status. Soft-deleted documents remain accessible until the scheduled hard-delete job runs. A client-side bug could display deleted entries to users.","recommendation":"Add isDeleted != true condition to read rules for journal, daily_logs, and inventoryEntries.","file":"firestore.rules","line":34,"evidence":"firestore.rules:34 → allow read: if isOwner(userId); // journal — no isDeleted filter\nfirestore.rules:48 → allow read: if isOwner(userId); // daily_logs — no isDeleted filter\nfirestore.rules:62 → allow read: if isOwner(userId); // inventoryEntries — no isDeleted filter\nNo where clause equivalent in rules to filter isDeleted == true.","suggested_fix":"Add condition: allow read: if isOwner(userId) && (!(resource.data.keys().hasAny(['isDeleted'])) || resource.data.isDeleted != true); This blocks reads on soft-deleted docs while allowing reads on docs without the isDeleted field.","status":"accepted","suggestion_text":"Accept at S2. Soft-deleted data should be invisible to prevent client-side bugs from accidentally displaying deleted content. Defense-in-depth against UI bugs.","counter_argument":"Client-side filtering already excludes soft-deleted items from display. Rules-level filtering adds complexity and could break admin restore operations if not carefully implemented.","related_findings":["D07-002","D19-003"],"detected_at":"2026-02-19T13:50:00Z","reviewed_at":"2026-02-19T13:55:00Z"}
{"id":"SYST-2026-02-19-D09-004","domain":9,"domain_name":"Firestore Rules","check_id":"9.10","severity":"S2","effort":"E1","category":"performance","title":"Unbounded reads on public collections (slogans, sober_living)","description":"DailySloganWidget.tsx fetches all slogans via getDocs(slogansRef) with no limit(). SoberLivingService.getAllHomes() fetches all sober_living docs. While these are currently small admin-managed collections, there is no guard against growth. Public collections with 'allow read: if true' are accessible to any authenticated or unauthenticated user.","recommendation":"Add limit() to slogans and sober_living queries to prevent unbounded reads.","file":"components/growth/DailySloganWidget.tsx","line":26,"evidence":"DailySloganWidget.tsx:26 → const snapshot = await getDocs(slogansRef); // No limit\nlib/db/sober-living.ts:31 → const q = query(collection(db, COLLECTION)); // No limit\nBoth are public collections (allow read: if true) fetched without limit().","suggested_fix":"Add limit() to both queries. For slogans, limit(100) is reasonable. For sober living, limit(200) with pagination if needed. Consider adding rules-level list limit if Firestore supports it.","status":"accepted","suggestion_text":"Accept at S2. Small collections now but no protection against growth. Public read access means any user (even unauthenticated) can trigger these unbounded reads.","counter_argument":"These are admin-managed seed datasets unlikely to exceed 50-100 docs. Adding limits adds complexity. If admin manages content responsibly, the risk is minimal.","related_findings":["D12-004"],"detected_at":"2026-02-19T13:50:00Z","reviewed_at":"2026-02-19T13:55:00Z"}
{"id":"SYST-2026-02-19-D09-005","domain":9,"domain_name":"Firestore Rules","check_id":"9.9","severity":"S3","effort":"E3","category":"security","title":"No rate limiting at Firestore rules level","description":"Firestore rules do not implement any rate limiting. All rate limiting is handled in Cloud Functions via the security wrapper. Public collections with 'allow read: if true' (meetings, sober_living, daily_quotes, glossary, slogans, quick_links, prayers) have no read-side rate limiting, making them vulnerable to read storms from unauthenticated clients.","file":"firestore.rules","line":1,"evidence":"All public collections use 'allow read: if true' with no rate limiting functions.\nRate limiting exists in functions/src/security-wrapper.ts for write operations only.\nrate_limits collection exists (line 148) but only used by Cloud Functions server-side.","suggested_fix":"Informational. Firestore rules-level rate limiting is complex and has limited support. Consider App Check enforcement at the rules level: allow read: if request.auth != null || firebase.appCheck.valid; This at least ensures reads come from verified app instances.","status":"accepted","suggestion_text":"Accept at S3. Cloud Functions handle write rate limiting. Read-side rate limiting at rules level is complex and rarely needed for small public datasets.","counter_argument":"Public reads are cached by the Firebase SDK client-side. Malicious read storms would need to bypass the SDK. Firebase's built-in DDoS protection at the infrastructure level provides baseline protection.","related_findings":["D07-001"],"detected_at":"2026-02-19T13:50:00Z","reviewed_at":"2026-02-19T13:55:00Z"}
