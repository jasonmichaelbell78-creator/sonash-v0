{"category":"performance","title":"N+1 query pattern in weekly stats calculation","fingerprint":"performance::components/notebook/pages/today-page.tsx::PERF-001","severity":"S1","effort":"E2","confidence":90,"files":["components/notebook/pages/today-page.tsx:744"],"why_it_matters":"Debug query in calculateWeeklyStats() fetches ALL logs unbounded using query(logsRef, orderBy('date', 'desc')) without limit(), causing excessive Firestore reads and billing impact","suggested_fix":"Remove debug query in production or add limit(10) for debug visibility. Consider caching weekly stats.","acceptance_tests":["Open browser DevTools Network tab","Navigate to Today page","Check Firestore requests - should see 2 queries","Compare request sizes before/after fix"],"evidence":["const allLogsQuery = query(logsRef, orderBy('date', 'desc'));","const allLogsSnapshot = await getDocs(allLogsQuery);"],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["Check Firestore requests - should see 2 queries"]},"second_pass":{"method":"manual_verification","confirmed":true,"notes":"Confirmed via dual-pass review"},"tool_confirmation":{"tool":"NONE","reference":"Manual verification only"}}}
{"category":"performance","title":"Large monolithic component with 1200+ lines causing excessive re-renders","fingerprint":"performance::components/notebook/pages/today-page.tsx::PERF-002","severity":"S1","effort":"E2","confidence":90,"files":["components/notebook/pages/today-page.tsx:231"],"why_it_matters":"TodayPage component is 1200+ lines with 15+ useState hooks, 10+ useEffect hooks, and multiple inline child components. Any state change triggers full component re-render.","suggested_fix":"Extract child components (ToggleButton, CheckInQuestion, SmartPromptsSection) to separate files with React.memo. Split into TodayHeader, CleanTimeTracker, MoodCheckIn, HaltCheck, WeeklyStats.","acceptance_tests":["Add React DevTools Profiler","Measure re-renders when typing in journal entry","After refactor verify re-renders isolated to changed sections"],"evidence":["export default function TodayPage({ nickname, onNavigate }: TodayPageProps) {","// 1200+ lines of component code"],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["Add React DevTools Profiler"]},"second_pass":{"method":"contextual_review","confirmed":true,"notes":"After refactor verify re-renders isolated to changed sections"},"tool_confirmation":{"tool":"NONE","reference":"Manual verification only"}}}
{"category":"performance","title":"Redundant mood history fetch duplicates existing data","fingerprint":"performance::components/notebook/visualizations/mood-sparkline.tsx::PERF-003","severity":"S1","effort":"E1","confidence":90,"files":["components/notebook/visualizations/mood-sparkline.tsx:18"],"why_it_matters":"MoodSparkline fetches history via FirestoreService.getHistory() independently, but this same data is already fetched by useJournal hook. Causes duplicate Firestore reads.","suggested_fix":"Pass mood data as props from parent TodayPage which already has access via useJournal, or lift history state to shared context","acceptance_tests":["Check Network tab for duplicate Firestore requests on Today page load","After fix verify only one history request occurs"],"evidence":["const history = await FirestoreService.getHistory(user.uid);","setLogs(history.entries.slice(0, 7).reverse());"],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["Check Network tab for duplicate Firestore requests on Today page load"]},"second_pass":{"method":"contextual_review","confirmed":true,"notes":"After fix verify only one history request occurs"},"tool_confirmation":{"tool":"NONE","reference":"Manual verification only"}}}
{"category":"performance","title":"Large ResourcesPage component not code-split","fingerprint":"performance::components/notebook/pages/resources-page.tsx::PERF-004","severity":"S2","effort":"E1","confidence":70,"files":["components/notebook/pages/resources-page.tsx:1"],"why_it_matters":"ResourcesPage is 960 lines and not dynamically imported. While the map component IS lazy loaded, the main component adds ~50KB to bundle for all users even if they never visit Resources tab.","suggested_fix":"Use dynamic import in roadmap-modules.tsx: const ResourcesPage = dynamic(() => import('./pages/resources-page'))","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["export default function ResourcesPage() {","// 960 lines of component code"]}
{"category":"performance","title":"Array creation in render path for lined paper effect","fingerprint":"performance::components/notebook/notebook-shell.tsx::PERF-005","severity":"S2","effort":"E0","confidence":90,"files":["components/notebook/notebook-shell.tsx:245"],"why_it_matters":"Creates new 25-element array on every render with [...Array(25)].map(), causing unnecessary memory allocation and GC pressure","suggested_fix":"Move array creation outside component: const LINED_PAPER_INDICES = Array.from({ length: 25 }, (_, i) => i);","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["{[...Array(25)].map((_, i) => (","<div key={i} className=\"absolute left-0 right-0 h-px bg-sky-200/30\" ..."]}
{"category":"performance","title":"onSnapshot listener recreated on journalEntry change","fingerprint":"performance::components/notebook/pages/today-page.tsx::PERF-006","severity":"S2","effort":"E1","confidence":70,"files":["components/notebook/pages/today-page.tsx:526"],"why_it_matters":"The Firestore onSnapshot listener effect has journalEntry in dependency array, causing listener recreation when journalEntry changes. While collision avoidance exists via isEditingRef, the listener itself is recreated.","suggested_fix":"Remove journalEntry from dependencies (already guarded by ref). Use separate effect for localStorage restoration.","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["}, [referenceDate, user, journalEntry, handleSnapshotUpdate]);"]}
{"category":"performance","title":"getAllHomes() fetches without limit() - unbounded query","fingerprint":"performance::lib/db/sober-living.ts::PERF-007","severity":"S2","effort":"E0","confidence":90,"files":["lib/db/sober-living.ts:30"],"why_it_matters":"SoberLivingService.getAllHomes() queries entire collection without limit(), fetching ALL documents regardless of collection size","suggested_fix":"Add limit(100) to query: const q = query(collection(db, COLLECTION), limit(100));","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["getAllHomes: async (): Promise<SoberLivingHome[]> => {","const q = query(collection(db, COLLECTION));"]}
{"category":"performance","title":"Keypress listener not optimized with useCallback","fingerprint":"performance::components/notebook/features/enhanced-mood-selector.tsx::PERF-008","severity":"S2","effort":"E0","confidence":70,"files":["components/notebook/features/enhanced-mood-selector.tsx:58"],"why_it_matters":"handleKeyPress function defined inside useEffect but onChange in deps can cause unnecessary effect re-runs when parent re-renders","suggested_fix":"Extract handleKeyPress to useCallback with [onChange] deps, then use in useEffect with [handleKeyPress, showKeyboardShortcuts] deps","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["const handleKeyPress = (e: KeyboardEvent) => {","window.addEventListener('keypress', handleKeyPress);"]}
{"category":"performance","title":"Heavy animation library (framer-motion ~45KB) for simple animations","fingerprint":"performance::package.json::PERF-009","severity":"S2","effort":"E2","confidence":70,"files":["package.json:92"],"why_it_matters":"framer-motion adds ~45KB gzipped for animations that could partially be achieved with CSS transitions. Used for page transitions, mood sparkline, celebration overlays.","suggested_fix":"Evaluate CSS transitions for simple cases. Consider @motionone/solid (~3KB) for simple animations. Ensure tree-shaking: import { motion } from 'framer-motion'","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["\"framer-motion\": \"^12.23.0\""]}
{"category":"performance","title":"Full document processing on every Firestore snapshot","fingerprint":"performance::hooks/use-journal.ts::PERF-010","severity":"S2","effort":"E1","confidence":70,"files":["hooks/use-journal.ts:284"],"why_it_matters":"On every onSnapshot callback, ALL documents are re-processed through processJournalDoc and groupEntriesByDate, even when only one document changed","suggested_fix":"Use snapshot.docChanges() to process only changed documents. Merge changes into existing state instead of replacing entirely.","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["snapshot.forEach((doc) => {","const entry = processJournalDoc(doc.id, doc.data());"]}
{"category":"performance","title":"Meeting data refetch on every userLocation change","fingerprint":"performance::components/widgets/compact-meeting-countdown.tsx::PERF-011","severity":"S2","effort":"E1","confidence":70,"files":["components/widgets/compact-meeting-countdown.tsx:135"],"why_it_matters":"findNextMeeting effect runs on every userLocation change, refetching all today's and tomorrow's meetings even though only proximity sorting needs update","suggested_fix":"Cache meeting data separately from location-dependent sorting. Only recalculate proximity when location changes, not refetch.","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["}, [userLocation, locationStatus, refreshKey]);"]}
{"category":"performance","title":"reCAPTCHA script with lazyOnload still impacts INP","fingerprint":"performance::app/layout.tsx::PERF-012","severity":"S3","effort":"E1","confidence":70,"files":["app/layout.tsx:88"],"why_it_matters":"reCAPTCHA Enterprise script loaded with strategy='lazyOnload' but can still block interaction on first use (e.g., first form submission)","suggested_fix":"Consider loading reCAPTCHA only when needed (e.g., before first protected action) using dynamic script loading","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["<Script","src={`https://www.google.com/recaptcha/enterprise.js?render=...`}","strategy=\"lazyOnload\""]}
{"category":"performance","title":"isProfileEqual creates new arrays on every comparison","fingerprint":"performance::components/providers/profile-context.tsx::PERF-013","severity":"S3","effort":"E0","confidence":70,"files":["components/providers/profile-context.tsx:50"],"why_it_matters":"Object.keys() creates new arrays on every isProfileEqual call, which happens on every profile snapshot. Minor but unnecessary allocation.","suggested_fix":"Cache keys or use a more efficient shallow comparison utility","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["const keysA = Object.keys(a) as Array<keyof UserProfile>;","const keysB = Object.keys(b) as Array<keyof UserProfile>;"]}
{"category":"performance","title":"Static module config imported eagerly","fingerprint":"performance::components/notebook/roadmap-modules.tsx::PERF-014","severity":"S3","effort":"E0","confidence":50,"files":["components/notebook/roadmap-modules.tsx:1"],"why_it_matters":"notebookModules array imports all page components at module level even though dynamic() could be used for deferred loading","suggested_fix":"Consider lazy module registration pattern where render functions use dynamic imports","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["import TodayPage from './pages/today-page';","import ResourcesPage from './pages/resources-page';"]}
{"category":"performance","title":"Timeout cleanup pattern could use single ref","fingerprint":"performance::components/celebrations/celebration-provider.tsx::PERF-015","severity":"S3","effort":"E0","confidence":50,"files":["components/celebrations/celebration-provider.tsx:29"],"why_it_matters":"Timeout cleanup is properly implemented but uses setTimeout return value directly. Could use a single ref pattern for cleaner code.","suggested_fix":"Current implementation is correct. Optional refactor for consistency with other patterns.","acceptance_tests":["Verify the fix addresses the issue","Run relevant tests"],"evidence":["const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);"]}
