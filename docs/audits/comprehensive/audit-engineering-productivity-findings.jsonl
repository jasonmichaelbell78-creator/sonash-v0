{"category":"engineering-productivity","title":"No npm run dev:offline script for emulator development","fingerprint":"engineering-productivity::package.json::dev-offline-script","severity":"S2","effort":"E1","confidence":95,"files":["package.json","DEVELOPMENT.md"],"why_it_matters":"Developers must run two separate terminals (emulators + dev server) which adds friction to local development. A single command would streamline the development workflow and ensure consistent emulator usage.","suggested_fix":"Add concurrently as devDependency and create 'dev:offline': 'concurrently \"firebase emulators:start\" \"npm run dev\"' script in package.json","acceptance_tests":["npm run dev:offline starts both Firebase emulators and Next.js dev server","Emulator UI accessible at localhost:4000","App connects to local emulators automatically"]}
{"category":"engineering-productivity","title":"No scripts/doctor.js environment validation script","fingerprint":"engineering-productivity::scripts/doctor.js::missing-doctor-script","severity":"S2","effort":"E1","confidence":90,"files":["scripts/","package.json"],"why_it_matters":"New developers often encounter cryptic errors due to missing prerequisites (Node version, Firebase CLI, env vars). A doctor script would diagnose and report setup issues clearly, reducing onboarding time.","suggested_fix":"Create scripts/doctor.js that checks: Node.js version >=18, Firebase CLI installed, required env vars in .env.local, functions/node_modules exists, and reports issues with remediation steps","acceptance_tests":["npm run doctor validates all prerequisites","Missing prerequisites show clear error message with fix instructions","Passing check shows green checkmarks for each item"]}
{"category":"engineering-productivity","title":"No single npm run setup command for project initialization","fingerprint":"engineering-productivity::package.json::setup-script","severity":"S3","effort":"E1","confidence":90,"files":["package.json","DEVELOPMENT.md"],"why_it_matters":"New developers must run multiple commands manually (npm install, cd functions && npm install, etc.). A unified setup command reduces onboarding friction and ensures consistent environment setup.","suggested_fix":"Add 'setup': 'npm install && cd functions && npm install && cd .. && npm run doctor' to package.json scripts","acceptance_tests":["npm run setup installs all dependencies","npm run setup runs doctor check","Fresh clone can be set up with single command"]}
{"category":"engineering-productivity","title":"64 npm scripts without centralized documentation","fingerprint":"engineering-productivity::package.json::scripts-documentation","severity":"S3","effort":"E0","confidence":85,"files":["package.json","DEVELOPMENT.md"],"why_it_matters":"With 64 npm scripts, developers may not discover useful tools or may use wrong commands. Many scripts have non-obvious purposes (patterns:sync, learning:analyze) that need explanation.","suggested_fix":"Create docs/SCRIPTS.md with categorized script reference, or add inline comments in package.json. Group by purpose: Testing, Documentation, Patterns, Security, Auditing, etc.","acceptance_tests":["Documentation exists for all npm scripts","Scripts are categorized by purpose","Common workflows documented (e.g., before commit, CI/CD related)"]}
{"category":"engineering-productivity","title":"No correlation ID support for request tracing","fingerprint":"engineering-productivity::lib/logger.ts::correlation-ids","severity":"S2","effort":"E2","confidence":95,"files":["lib/logger.ts","lib/utils/secure-caller.ts","functions/src/security-wrapper.ts"],"why_it_matters":"When debugging production issues, there's no way to trace a user's request from frontend through Cloud Functions. This makes it impossible to correlate client-side errors with server-side logs, significantly increasing debugging time.","suggested_fix":"Generate UUID on client for each request, pass as x-correlation-id header to Cloud Functions, include in all logger calls. Store in React context for component-level logging.","acceptance_tests":["Each API request includes x-correlation-id header","Cloud Function logs include correlation ID","Sentry errors include correlation ID in extra context","Can search logs by correlation ID to trace full request"]}
{"category":"engineering-productivity","title":"Generic error messages lack specific remediation guidance","fingerprint":"engineering-productivity::components/::generic-error-messages","severity":"S2","effort":"E1","confidence":80,"files":["components/admin/users-tab.tsx","components/settings/settings-page.tsx","components/journal/entry-wizard.tsx","lib/utils/callable-errors.ts"],"why_it_matters":"~100 instances of 'Please try again' without specific context. Users don't know what went wrong or what 'trying again' means. This leads to repeated failures and support requests.","suggested_fix":"Replace generic messages with operation-specific guidance using callable-errors.ts customMessages option. Include what action failed and what the user should do differently.","acceptance_tests":["Error messages specify what operation failed","Rate limit errors show wait time","Network errors suggest checking connection","Authentication errors prompt re-login"]}
{"category":"engineering-productivity","title":"Error knowledge base incomplete - missing common patterns","fingerprint":"engineering-productivity::lib/error-knowledge-base.ts::incomplete-patterns","severity":"S3","effort":"E1","confidence":75,"files":["lib/error-knowledge-base.ts"],"why_it_matters":"The error knowledge base has 13 patterns but is missing common scenarios like meeting data load failures, journal save errors, and account linking issues. Admin dashboard shows 'Unknown' component for these.","suggested_fix":"Add patterns for: journal-related errors, meeting loading failures, account linking issues, anonymous user migration, and daily log specific errors.","acceptance_tests":["Journal save errors show specific remediation","Meeting load errors categorized correctly","Account linking errors have dedicated pattern","No 'Unknown' component shown for common errors"]}
{"category":"engineering-productivity","title":"Firebase IndexedDB persistence not enabled - no offline reads","fingerprint":"engineering-productivity::lib/firebase.ts::persistence-disabled","severity":"S1","effort":"E0","confidence":100,"files":["lib/firebase.ts"],"why_it_matters":"Without persistence, Firestore queries fail immediately when offline. Users cannot view their journal, meetings, or any data without network. This is a single line fix with massive user impact for a recovery app where connectivity may be poor.","suggested_fix":"Add enableIndexedDbPersistence(db) after getFirestore() call in lib/firebase.ts. Handle multi-tab and unsupported browser errors gracefully.","acceptance_tests":["App loads previously fetched data when offline","IndexedDB contains Firestore cache (check DevTools)","Multi-tab scenario handled gracefully with warning","Unsupported browsers show appropriate message"],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["See files array for affected locations"]},"second_pass":{"method":"manual_verification","confirmed":true,"notes":"Confirmed during audit review"},"tool_confirmation":{"tool":"NONE","reference":"No automated tool confirmation available"}}}
{"category":"engineering-productivity","title":"No service worker for offline app shell caching","fingerprint":"engineering-productivity::public/sw.js::missing-service-worker","severity":"S1","effort":"E2","confidence":95,"files":["public/","next.config.mjs"],"why_it_matters":"Without a service worker, the app cannot load at all when offline. Even if Firebase persistence is enabled, users see a blank page or error. PWA manifest exists but is incomplete without SW.","suggested_fix":"Implement service worker using next-pwa or workbox-webpack-plugin. Cache app shell (HTML, CSS, JS), static assets, and API responses for meetings/quotes.","acceptance_tests":["App loads cached shell when offline","Service worker registered and active","Static assets served from cache","Network-first strategy for API calls with cache fallback"],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["See files array for affected locations"]},"second_pass":{"method":"manual_verification","confirmed":true,"notes":"Confirmed during audit review"},"tool_confirmation":{"tool":"NONE","reference":"No automated tool confirmation available"}}}
{"category":"engineering-productivity","title":"No offline write queue - writes fail silently with data loss","fingerprint":"engineering-productivity::lib/firestore-service.ts::offline-queue","severity":"S1","effort":"E3","confidence":95,"files":["lib/firestore-service.ts","hooks/use-journal.ts","components/status/offline-indicator.tsx"],"why_it_matters":"Journal entries made offline are lost forever. For a recovery app, this could mean losing important reflections during meetings (often in basements with poor signal). Users trust the 'changes will sync' message but it's false.","suggested_fix":"Implement IndexedDB-based write queue. Store pending writes with timestamp, sync on reconnection with conflict resolution. Show pending write count in UI.","acceptance_tests":["Journal entries saved to IndexedDB when offline","Pending writes shown in UI with count","Writes sync automatically on reconnection","Conflict resolution handles duplicate submissions"],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["See files array for affected locations"]},"second_pass":{"method":"manual_verification","confirmed":true,"notes":"Confirmed during audit review"},"tool_confirmation":{"tool":"NONE","reference":"No automated tool confirmation available"}}}
{"category":"engineering-productivity","title":"OfflineIndicator shows misleading sync message","fingerprint":"engineering-productivity::components/status/offline-indicator.tsx::misleading-message","severity":"S2","effort":"E1","confidence":100,"files":["components/status/offline-indicator.tsx"],"why_it_matters":"The offline indicator says 'changes will sync when reconnected' but there is no sync mechanism. This builds false user trust and may lead to data loss if users believe their changes are saved.","suggested_fix":"Change message to 'Offline - some features may be unavailable' until offline write queue is implemented. Add pending write count once queue exists.","acceptance_tests":["Offline message accurately reflects capability","No mention of syncing until sync exists","Message updates when offline queue implemented"]}
{"category":"engineering-productivity","title":"No network retry mechanism for failed API requests","fingerprint":"engineering-productivity::lib/utils/retry.ts::network-retry","severity":"S3","effort":"E1","confidence":80,"files":["lib/utils/retry.ts","lib/firestore-service.ts"],"why_it_matters":"When network briefly drops, API calls fail immediately without retry. This causes user frustration during temporary connectivity issues. A retry mechanism would handle transient failures gracefully.","suggested_fix":"Enhance lib/utils/retry.ts to include network-aware retry with exponential backoff. Apply to Cloud Function calls in firestore-service.ts.","acceptance_tests":["Transient network failures trigger automatic retry","Exponential backoff prevents server overload","User sees 'retrying' indicator during retry","Max retry limit prevents infinite loops"]}
