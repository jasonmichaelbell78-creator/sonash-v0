{"id":"COMP-2026-02-19-D07-001","domain":7,"domain_name":"Cloud Functions","check_id":"7.1","severity":"S1","effort":"E2","category":"security","title":"App Check globally disabled on all 5 user-callable functions via requireAppCheck: false","description":"Every user-callable function (saveDailyLog, saveJournalEntry, softDeleteJournalEntry, saveInventoryEntry, migrateAnonymousUserData) has requireAppCheck: false with comment 'TEMPORARILY DISABLED'. migrateAnonymousUserData has entire App Check block commented out. Security wrapper defaults requireAppCheck to true but all callers override it.","file":"functions/src/index.ts","line":84,"evidence":["index.ts:84 — requireAppCheck: false, // TEMPORARILY DISABLED","index.ts:170,269,363 — same pattern on all user functions","index.ts:506-511 — App Check block commented out in migrateAnonymousUserData"],"confidence":"HIGH","recommendation":"Re-enable App Check on all user-callable functions. Investigate throttle issue that caused temporary disable.","verification_steps":{"first_pass":{"method":"grep","evidence_collected":["grep requireAppCheck functions/src/index.ts → 4 lines with false"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed — all 5 user functions have requireAppCheck: false","reference":"functions/src/index.ts:84,170,269,363"}},"suggested_fix":"Change requireAppCheck: false to requireAppCheck: true on all user functions. Re-enable commented block in migrateAnonymousUserData.","status":"accepted","suggestion_text":"Accept at S1. App Check is a critical defense-in-depth layer.","counter_argument":"App Check was disabled due to throttling issues. Re-enabling requires testing.","related_findings":[],"detected_at":"2026-02-19T12:40:00Z"}
{"id":"COMP-2026-02-19-D07-002","domain":7,"domain_name":"Cloud Functions","check_id":"7.2","severity":"S1","effort":"E2","category":"security","title":"migrateAnonymousUserData bypasses security wrapper — reCAPTCHA optional, internal errors leaked","description":"migrateAnonymousUserData is the only user-callable function not using withSecurityChecks. reCAPTCHA is silently optional (logs WARNING and continues). Rate limit catch block passes raw rateLimitError.message to HttpsError (leaks internals). Zod error path at line 545 exposes raw validation messages to client.","file":"functions/src/index.ts","line":486,"evidence":["index.ts:499-503 — throw new HttpsError('resource-exhausted', errorMessage) with raw internal message","index.ts:516-527 — reCAPTCHA missing → logs warning, continues without protection","index.ts:545 — throw new HttpsError('invalid-argument', 'Validation failed: ' + errorMessages)"],"confidence":"HIGH","recommendation":"Refactor migrateAnonymousUserData to use withSecurityChecks wrapper. Replace raw error messages with generic client-safe messages.","verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["index.ts:486 — migrateAnonymousUserData does not call withSecurityChecks"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed — only function not using withSecurityChecks","reference":"functions/src/index.ts:486"}},"suggested_fix":"Wrap in withSecurityChecks. Use generic error messages for client responses.","status":"accepted","suggestion_text":"Accept at S1. Security wrapper bypass + error message leakage.","counter_argument":"Migration is a one-time operation per user with low attack surface.","related_findings":[],"detected_at":"2026-02-19T12:40:00Z"}
{"id":"COMP-2026-02-19-D07-003","domain":7,"domain_name":"Cloud Functions","check_id":"7.3","severity":"S1","effort":"E1","category":"code-quality","title":"Node.js engine version mismatch — package.json says node 20, firebase.json deploys nodejs24","description":"functions/package.json engines.node is '20' but firebase.json runtime is 'nodejs24'. Functions run on Node 24 in production but local dev/CI validates against Node 20. Behavior differences between versions may cause silent bugs.","file":"functions/package.json","line":14,"evidence":["functions/package.json:14 — engines: { node: '20' }","firebase.json:68 — runtime: 'nodejs24'"],"confidence":"HIGH","recommendation":"Align engine version. Update functions/package.json to engines.node: '24'.","verification_steps":{"first_pass":{"method":"file_read","evidence_collected":["functions/package.json engines.node = '20'","firebase.json runtime = 'nodejs24'"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed — version mismatch between package.json and firebase.json","reference":"functions/package.json:14, firebase.json:68"}},"suggested_fix":"Update functions/package.json engines.node to '24'.","status":"accepted","suggestion_text":"Accept at S1. Version mismatch between dev and prod environments.","counter_argument":"Node 24 is backwards-compatible with Node 20 code.","related_findings":[],"detected_at":"2026-02-19T12:40:00Z"}
{"id":"COMP-2026-02-19-D07-004","domain":7,"domain_name":"Cloud Functions","check_id":"7.4","severity":"S1","effort":"E1","category":"code-quality","title":"Rate limiter reset() uses wrong Firestore document key — rate limit clears never work","description":"consume() calls consumeByKey('user_${userId}', operation) producing doc key 'user_${userId}_${operation}'. But reset() constructs key as '${userId}_${operation}' — missing the 'user_' prefix. reset() deletes a non-existent document. Admin panel 'Clear Rate Limit' feature does nothing.","file":"functions/src/firestore-rate-limiter.ts","line":149,"evidence":["consume() → consumeByKey('user_${userId}', operation) → doc key 'user_abc123_saveDailyLog'","reset() → docId = '${userId}_${operation}' → key 'abc123_saveDailyLog' — WRONG prefix"],"confidence":"HIGH","recommendation":"Fix reset() to use 'user_${userId}_${operation}' key matching consume().","verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["firestore-rate-limiter.ts:149 — reset() key missing user_ prefix"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed — key mismatch between consume and reset methods","reference":"functions/src/firestore-rate-limiter.ts:149"}},"suggested_fix":"Change reset() to use `user_${userId}_${operation}` as the document ID.","status":"accepted","suggestion_text":"Accept at S1. Broken admin feature — rate limit resets silently fail.","counter_argument":"Rate limits expire naturally. reset() is rarely used.","related_findings":[],"detected_at":"2026-02-19T12:40:00Z"}
{"id":"COMP-2026-02-19-D07-005","domain":7,"domain_name":"Cloud Functions","check_id":"7.5","severity":"S2","effort":"E1","category":"security","title":"reCAPTCHA site key hard-coded as fallback literal in recaptcha-verify.ts","description":"Production reCAPTCHA site key committed in source code as a fallback. While site keys are public-facing, embedding in repo makes it unrotatable without code change.","file":"functions/src/recaptcha-verify.ts","line":66,"evidence":["const siteKey = process.env.RECAPTCHA_SITE_KEY || '6LdeazosAAAAAMDNCh1hTUDKh_UeS6xWY1-85B2O'"],"recommendation":"Remove fallback literal. Require RECAPTCHA_SITE_KEY env var with fail-closed behavior.","suggested_fix":"Remove hardcoded fallback. Throw if env var is missing.","status":"accepted","suggestion_text":"Accept at S2. Credential in source code.","counter_argument":"Site keys are public by design. Fallback prevents misconfiguration downtime.","related_findings":[],"detected_at":"2026-02-19T12:40:00Z"}
{"id":"COMP-2026-02-19-D07-006","domain":7,"domain_name":"Cloud Functions","check_id":"7.6","severity":"S2","effort":"E1","category":"code-quality","title":"saveInventoryEntry uses wrong TypeScript generic — typeof schema instead of inferred type","description":"saveInventoryEntry declared as onCall<typeof inventoryEntrySchema> instead of onCall<InventoryEntryInput>. typeof inventoryEntrySchema is the Zod schema object type, not the validated output type. TypeScript provides no compile-time safety for request.data properties.","file":"functions/src/index.ts","line":356,"evidence":["onCall<typeof inventoryEntrySchema> — wrong: schema type, not data type","Other functions use correct pattern: onCall<DailyLogData>"],"recommendation":"Change to onCall<InventoryEntryInput> using z.infer<typeof inventoryEntrySchema>.","suggested_fix":"Fix generic parameter to use inferred Zod output type.","status":"accepted","suggestion_text":"Accept at S2. Type safety bypassed on data handler.","counter_argument":"Runtime Zod validation still catches invalid data.","related_findings":[],"detected_at":"2026-02-19T12:40:00Z"}
{"id":"COMP-2026-02-19-D07-007","domain":7,"domain_name":"Cloud Functions","check_id":"7.7","severity":"S2","effort":"E2","category":"security","title":"Zod data fields are unbounded z.record — saveJournalEntry writes unsanitized data to Firestore","description":"journalEntrySchema and inventoryEntrySchema define data as z.record(z.string(), z.unknown()) with no size/depth limits. saveJournalEntry writes entryData directly to Firestore without sanitization. A malicious user can send megabytes of deeply nested JSON.","file":"functions/src/schemas.ts","line":32,"evidence":["schemas.ts:32,51 — data: z.record(z.string(), z.unknown()) — no limits","index.ts:196-213 — saveJournalEntry writes entryData directly without sanitization","saveInventoryEntry has sanitizeData() with MAX_DEPTH=50 but saveJournalEntry does not"],"recommendation":"Add z.record constraints: max keys, max depth. Apply sanitizeData() to saveJournalEntry.","suggested_fix":"Add .refine() constraints to Zod schema. Apply sanitizeData() consistently.","status":"accepted","suggestion_text":"Accept at S2. DoS vector via unbounded input on write path.","counter_argument":"Firestore has its own document size limits (1MB max).","related_findings":[],"detected_at":"2026-02-19T12:40:00Z"}
{"id":"COMP-2026-02-19-D07-008","domain":7,"domain_name":"Cloud Functions","check_id":"7.8","severity":"S2","effort":"E1","category":"security","title":"Admin functions have no enforceAppCheck in onCall config","description":"All admin functions use onCall(async (request) => { requireAdmin() ... }) without enforceAppCheck option. Firebase Functions v2 supports onCall({ enforceAppCheck: true }, handler). An attacker with a valid admin token but no App Check token can call admin endpoints.","file":"functions/src/admin.ts","line":707,"evidence":["admin.ts:707,765,797,859,897,987,1038,1166 — onCall without enforceAppCheck","requireAdmin checks auth claim but not request.app"],"recommendation":"Add { enforceAppCheck: true } to all admin onCall declarations.","suggested_fix":"Add enforceAppCheck: true to onCall options for all admin functions.","status":"accepted","suggestion_text":"Accept at S2. Missing platform-level security check on admin endpoints.","counter_argument":"Admin claim verification is sufficient. App Check adds defense-in-depth.","related_findings":["COMP-2026-02-19-D07-001"],"detected_at":"2026-02-19T12:40:00Z"}
{"id":"COMP-2026-02-19-D07-009","domain":7,"domain_name":"Cloud Functions","check_id":"7.9","severity":"S2","effort":"E1","category":"security","title":"Rate limiter console.warn leaks un-hashed user ID in logs","description":"When rate limit is exceeded, consumeByKey logs the Firestore doc key containing raw user_${userId} to console.warn. GCP Cloud Logging captures this. Rest of codebase hashes user IDs via hashUserId() before logging.","file":"functions/src/firestore-rate-limiter.ts","line":108,"evidence":["console.warn('Rate limit exceeded for ${docId}:', { requests, limit, ... })","docId = 'user_<rawUserId>_saveDailyLog' — raw UID in log"],"recommendation":"Hash the userId portion before logging. Use hashUserId() consistently.","suggested_fix":"Replace docId in log with hashed version.","status":"accepted","suggestion_text":"Accept at S2. PII logging inconsistency.","counter_argument":"Cloud Logging is internal. User IDs are not PII in all jurisdictions.","related_findings":[],"detected_at":"2026-02-19T12:40:00Z"}
{"id":"COMP-2026-02-19-D07-010","domain":7,"domain_name":"Cloud Functions","check_id":"7.10","severity":"S2","effort":"E1","category":"security","title":"migrateAnonymousUserData logs raw UIDs to Sentry (PII in third-party telemetry)","description":"Multiple logSecurityEvent calls include raw anonymousUid and targetUid in metadata without hashing. redactSensitiveMetadata only strips keys matching SENSITIVE_KEYS list — anonymousUid/targetUid are not on that list. Raw Firebase Auth UIDs are sent to Sentry.","file":"functions/src/index.ts","line":556,"evidence":["index.ts:555-560 — metadata: { anonymousUid: validatedData.anonymousUid, targetUid: validatedData.targetUid }","index.ts:724-738 — success log also includes raw UIDs","captureToSentry not set to false → goes to Sentry with raw UIDs"],"recommendation":"Hash anonymousUid and targetUid before including in metadata. Or add to SENSITIVE_KEYS list.","suggested_fix":"Apply hashUserId() to UIDs before logging, or add to redactSensitiveMetadata list.","status":"accepted","suggestion_text":"Accept at S2. PII sent to third-party service violates hashing convention.","counter_argument":"Sentry has its own PII scrubbing capabilities.","related_findings":["COMP-2026-02-19-D07-009"],"detected_at":"2026-02-19T12:40:00Z"}
