{"category":"ai-optimization","title":"No automated SKILL_INDEX.md sync — 9 orphaned skills discovered manually","fingerprint":"ai-optimization::automation-gap::skill-index-sync","severity":"S2","effort":"E2","confidence":95,"files":[".claude/skills/SKILL_INDEX.md"],"why_it_matters":"Stage 2b found 9 skills missing from SKILL_INDEX.md and 2 duplicate listings. There is no pre-commit hook or CI check that validates SKILL_INDEX.md matches the filesystem. New skills can be added without updating the index indefinitely.","suggested_fix":"Create scripts/check-skill-index.js that scans .claude/skills/*/SKILL.md directories and validates every directory has a SKILL_INDEX.md entry with no duplicates. Add to pre-commit hook chain after doc-index check.","acceptance_tests":["scripts/check-skill-index.js exists and passes","Pre-commit rejects commits adding skill dirs without index entry","Duplicate listings are flagged as errors"]}
{"category":"ai-optimization","title":"No automated state file rotation — 5 append-only files grow unbounded","fingerprint":"ai-optimization::automation-gap::state-file-rotation","severity":"S2","effort":"E2","confidence":95,"files":[".claude/state/commit-log.jsonl",".claude/state/reviews.jsonl",".claude/state/agent-invocations.jsonl",".claude/override-log.jsonl",".claude/state/velocity-log.jsonl"],"why_it_matters":"Stage 2e found 5 append-only JSONL/JSON state files with no rotation, archival, or size-cap logic. Session-end rarely runs (10:1 begin/end ratio), so even documented cleanup never executes. Files will grow unbounded.","suggested_fix":"Create scripts/rotate-state-files.js that enforces size caps on all 5 files (archive older entries). Call it from session-start.js (which always runs) instead of session-end (which rarely runs). Add size-check alerts to run-alerts.js.","acceptance_tests":["rotate-state-files.js enforces caps: commit-log 500 lines, reviews 50 entries, agent-invocations 200, override-log 100, velocity-log 100","session-start.js calls rotation on startup","Archived entries preserved in .archive.jsonl files"]}
{"category":"ai-optimization","title":"No automated temp file cleanup at session start — stale tmp-*.json persists","fingerprint":"ai-optimization::automation-gap::temp-file-cleanup","severity":"S3","effort":"E1","confidence":90,"files":[".claude/tmp-alerts.json",".claude/hooks/session-start.js"],"why_it_matters":"Stage 2e found .claude/tmp-alerts.json persisting across sessions and appearing in git status. Session-end cleanup rarely runs (10:1 ratio). No session-start cleanup exists for temp files, so they accumulate across sessions.","suggested_fix":"Add a cleanup step to session-start.js that removes .claude/tmp-*.json and other ephemeral files (.session-agents.json, .agent-trigger-state.json) left from previous sessions. Run before any diagnostic output.","acceptance_tests":["session-start.js removes .claude/tmp-*.json files on startup","session-start.js removes stale .session-agents.json and .agent-trigger-state.json","No untracked temp files appear in git status after session start"]}
{"category":"ai-optimization","title":"No automated stale task-state pruning — completed tasks persist indefinitely","fingerprint":"ai-optimization::automation-gap::stale-task-state-pruning","severity":"S3","effort":"E1","confidence":95,"files":[".claude/state/task-audit-template-overhaul.state.json",".claude/hooks/session-start.js"],"why_it_matters":"Stage 2e found task-audit-template-overhaul.state.json persisting 7 days after completion with all steps pending. Session-end only cleans in_progress tasks. No automated pruning exists for planned/completed tasks older than a threshold.","suggested_fix":"Add age-based pruning to session-start.js: remove task-*.state.json files where all steps are pending and lastUpdated is >3 days old, or status is completed. Log removed files for audit trail.","acceptance_tests":["Task state files older than 3 days with all-pending steps are auto-removed","Completed task state files are auto-removed","Removal is logged to commit-log or stdout"]}
{"category":"ai-optimization","title":"No pre-commit check for FALSE_POSITIVES.jsonl integration in audit skills","fingerprint":"ai-optimization::automation-gap::false-positives-check","severity":"S3","effort":"E1","confidence":85,"files":[".claude/skills/audit-process/SKILL.md",".claude/skills/audit-enhancements/SKILL.md"],"why_it_matters":"Stage 2b found audit-process and audit-enhancements do not reference FALSE_POSITIVES.jsonl, meaning they re-report known false positives. No CI or hook check validates that all audit skills integrate with the false-positives exclusion list.","suggested_fix":"Add a check to scripts/check-skill-index.js (or new script) that greps each audit-*/SKILL.md for FALSE_POSITIVES.jsonl reference. Fail if any audit skill lacks it. Add to pre-commit chain.","acceptance_tests":["All audit-*/SKILL.md files reference FALSE_POSITIVES.jsonl","Pre-commit check fails if new audit skill omits false-positives integration","audit-process and audit-enhancements are fixed to load FALSE_POSITIVES.jsonl"]}
{"category":"ai-optimization","title":"No automated hook consolidation — 10 PostToolUse Write hooks run as separate processes","fingerprint":"ai-optimization::automation-gap::hook-consolidation-gate","severity":"S1","effort":"E2","confidence":95,"files":[".claude/settings.json",".claude/hooks/pattern-check.js",".claude/hooks/firestore-write-block.js",".claude/hooks/app-check-validator.js",".claude/hooks/typescript-strict-check.js",".claude/hooks/repository-pattern-check.js",".claude/hooks/test-mocking-validator.js",".claude/hooks/component-size-check.js"],"why_it_matters":"Stage 2a found 10 separate Node.js processes spawn per Write, 9 per Edit, and 4 per UserPromptSubmit. Each process has ~30-50ms cold start overhead. No unified hook runner exists, so adding new checks always means adding another process spawn. This is the single largest performance issue found across all stages.","suggested_fix":"Create .claude/hooks/unified-post-tool-use.js that imports all check functions and runs them in a single process. Route by CLAUDE_TOOL environment variable. Read file content once, share across checks. Replace all 10 individual hook entries in settings.json with one unified entry.","acceptance_tests":["Single unified hook process handles all PostToolUse Write/Edit/MultiEdit checks","settings.json has 1 PostToolUse entry per tool type instead of 10","Per-Write latency drops from ~500ms to under 100ms","All existing validations still run"]}
{"category":"ai-optimization","title":"No automated detection of dead MCP server references in skills","fingerprint":"ai-optimization::automation-gap::mcp-reference-validation","severity":"S2","effort":"E1","confidence":90,"files":[".mcp.json",".claude/settings.local.json",".claude/skills/save-context/SKILL.md",".claude/skills/audit-enhancements/SKILL.md",".claude/skills/pr-retro/SKILL.md"],"why_it_matters":"Stage 2c found 3 skills referencing mcp__memory__ tools from a server that is configured but not enabled, causing silent failures. No validation exists to check that MCP tool references in skills match enabled servers.","suggested_fix":"Create scripts/check-mcp-refs.js that: (1) reads .mcp.json and settings.local.json to determine enabled servers, (2) greps all SKILL.md files for mcp__*__ references, (3) flags any reference to a disabled or unconfigured server. Add to pre-commit hook chain for .claude/skills/ changes.","acceptance_tests":["scripts/check-mcp-refs.js detects mcp__memory__ references when server is disabled","Pre-commit rejects skill changes with dead MCP references","Script handles both .mcp.json and plugin-based servers"]}
{"category":"ai-optimization","title":"No automated detection of superseded/orphaned hooks on disk","fingerprint":"ai-optimization::automation-gap::orphaned-hook-detection","severity":"S3","effort":"E1","confidence":90,"files":[".claude/hooks/check-edit-requirements.js",".claude/hooks/check-write-requirements.js",".claude/settings.json"],"why_it_matters":"Stage 2a found check-edit-requirements.js and check-write-requirements.js still on disk but no longer referenced in settings.json (superseded by check-requirements.js). No automated check validates that all .claude/hooks/*.js files are actually referenced in settings.json.","suggested_fix":"Create scripts/check-orphaned-hooks.js that lists all .js files in .claude/hooks/ and validates each appears in at least one settings.json hook configuration. Flag unreferenced hooks for removal. Add to session-start.js diagnostics.","acceptance_tests":["scripts/check-orphaned-hooks.js detects unreferenced hook files","session-start.js reports orphaned hooks as warnings","check-edit-requirements.js and check-write-requirements.js flagged"]}
{"category":"ai-optimization","title":"No automated velocity-log.jsonl data quality check — malformed sprint field undetected","fingerprint":"ai-optimization::automation-gap::velocity-data-quality","severity":"S2","effort":"E1","confidence":100,"files":[".claude/state/velocity-log.jsonl","scripts/velocity/track-session.js"],"why_it_matters":"Stage 2e found all 5 velocity-log entries have malformed sprint fields containing full markdown table rows instead of sprint names. This has been silently corrupting velocity analytics with no automated detection. The regression went unnoticed because no validation exists.","suggested_fix":"Add a data quality check to track-session.js that validates the sprint field matches /^[A-Z]\\d+ - .{3,50}$/ pattern before writing. Add a retroactive fixer script. Add velocity-log schema validation to session-start.js diagnostics.","acceptance_tests":["track-session.js validates sprint field format before writing","Malformed entries trigger a warning in session-start diagnostics","Existing malformed entries are flagged for correction"]}
{"category":"ai-optimization","title":"No automated settings.json hook-list deduplication check","fingerprint":"ai-optimization::automation-gap::settings-hook-dedup","severity":"S3","effort":"E1","confidence":95,"files":[".claude/settings.json"],"why_it_matters":"Stage 2d found Edit and MultiEdit hook lists are near-exact copies of Write hooks (minus one entry), triplicating ~120 lines of configuration. No CI check validates that shared hooks are not duplicated across tool types, enabling configuration drift.","suggested_fix":"Add a lint check in pre-commit that validates settings.json hook arrays: (1) no exact duplicate entries within a single tool type, (2) warn when >80% overlap between tool type hook lists (suggesting consolidation). Better: refactor settings.json to use shared hook references.","acceptance_tests":["Pre-commit warns on >80% hook overlap between tool types","settings.json uses shared matcher patterns where possible","Adding a hook to Write but not Edit triggers a warning"]}
{"category":"ai-optimization","title":"No automated CRITICAL RETURN PROTOCOL check in audit skill agent prompts","fingerprint":"ai-optimization::automation-gap::return-protocol-check","severity":"S2","effort":"E1","confidence":90,"files":[".claude/skills/audit-process/SKILL.md",".claude/skills/audit-enhancements/SKILL.md",".claude/skills/audit-documentation/SKILL.md"],"why_it_matters":"Stage 2b found audit-process, audit-documentation, and audit-enhancements lack the CRITICAL RETURN PROTOCOL in agent prompts, risking context overflow (Session #140 lesson). No automated check validates that all audit skills with Task() prompts include the required return protocol.","suggested_fix":"Create scripts/check-audit-prompts.js that greps audit-*/SKILL.md for Task() or agent prompt patterns and validates each contains 'Return ONLY: COMPLETE' nearby. Add to pre-commit chain for .claude/skills/ changes.","acceptance_tests":["All audit skill agent prompts contain CRITICAL RETURN PROTOCOL","Pre-commit rejects audit skill changes missing the protocol","New audit skills must include the protocol to pass checks"]}
{"category":"ai-optimization","title":"Session-end cleanup is practically dead code — needs migration to session-start","fingerprint":"ai-optimization::automation-gap::cleanup-migration-to-start","severity":"S1","effort":"E2","confidence":95,"files":[".claude/hooks/.session-state.json",".claude/skills/session-end/SKILL.md",".claude/hooks/session-start.js"],"why_it_matters":"Stage 2e found 166 session begins vs 16 session ends (10:1 ratio). All state cleanup logic in session-end step 6 is effectively dead code since it runs in <10% of sessions. Temp files, ephemeral state, stale tasks, and JSONL rotation all depend on session-end which almost never runs.","suggested_fix":"Move all critical cleanup operations from session-end step 6 to session-start.js: (1) remove stale temp files, (2) prune old task states, (3) clean ephemeral agent tracking files, (4) check JSONL sizes and rotate if needed. Session-end becomes optional nice-to-have, not a critical cleanup dependency.","acceptance_tests":["session-start.js performs all critical cleanup that session-end step 6 currently does","State files are properly managed even when session-end never runs","session-end step 6 still works but is no longer the only cleanup path"]}
{"category":"ai-optimization","title":"No automated context-injection budget tracking across hooks","fingerprint":"ai-optimization::automation-gap::context-injection-budget","severity":"S2","effort":"E2","confidence":85,"files":[".claude/hooks/alerts-reminder.js",".claude/hooks/analyze-user-request.js",".claude/hooks/session-start.js",".claude/hooks/compact-restore.js"],"why_it_matters":"Stage 2d found multiple hooks inject text to stdout (context-consuming) without coordination: session-start outputs ~50 lines, alerts-reminder injects per-prompt, analyze-user-request injects per-match, compact-restore injects ~30 lines. No budget or deduplication exists — total context injection is unbounded.","suggested_fix":"Create a shared context-injection tracker in .claude/state/context-injections.json that logs what each hook has injected this session. Each hook checks the tracker before injecting: skip if already injected this session (for one-time messages) or if cooldown period has not elapsed (for recurring messages). Set a per-session budget of ~20 lines total stdout injection.","acceptance_tests":["Each hook checks context-injection tracker before stdout output","One-time messages (session-start checklist) are not re-injected after compaction","Total context injection per session stays under 30 lines","Cooldown prevents repeated alert injections"]}
{"category":"ai-optimization","title":"No automated check that hooks use execFileSync instead of execSync for subprocesses","fingerprint":"ai-optimization::automation-gap::execsync-security-check","severity":"S2","effort":"E1","confidence":95,"files":[".claude/hooks/compaction-handoff.js",".claude/hooks/pattern-check.js"],"why_it_matters":"Stage 2a found compaction-handoff.js uses execSync (shell spawn) instead of execFileSync for git commands, creating both performance overhead and shell injection risk. This is a known anti-pattern but no automated check catches it in hooks. patterns:check may cover scripts/ but not .claude/hooks/.","suggested_fix":"Add a pattern to npm run patterns:check (or pattern-check.js itself) that flags execSync usage in .claude/hooks/*.js files. The check should require execFileSync for all subprocess calls in hooks, matching the pattern already used in commit-tracker.js.","acceptance_tests":["patterns:check flags execSync usage in .claude/hooks/ as a warning","compaction-handoff.js is fixed to use execFileSync","New hooks using execSync fail the pattern check"]}
{"category":"ai-optimization","title":"No automated monitoring of hook execution time — slow hooks go undetected","fingerprint":"ai-optimization::automation-gap::hook-timing-monitoring","severity":"S2","effort":"E2","confidence":85,"files":[".claude/hooks/session-start.js",".claude/settings.json"],"why_it_matters":"Stage 2a found SessionStart taking 30-60s and PostToolUse Write taking ~500ms, but these were discovered through manual audit. No automated timing exists to detect hook performance regressions. A new hook adding 200ms would go unnoticed.","suggested_fix":"Add timing instrumentation to each hook: log execution time to .claude/state/hook-timing.jsonl. Add a session-start diagnostic that reads recent timing data and warns if any hook exceeds its budget (e.g., PostToolUse >100ms, SessionStart >15s, UserPromptSubmit >200ms).","acceptance_tests":["Each hook logs its execution time to hook-timing.jsonl","session-start.js warns when any hook exceeds its time budget","hook-timing.jsonl has rotation at 500 entries"]}
{"category":"ai-optimization","title":"No automated duplicate file-read detection across PostToolUse hooks","fingerprint":"ai-optimization::automation-gap::duplicate-file-read-detection","severity":"S3","effort":"E2","confidence":80,"files":[".claude/hooks/firestore-write-block.js",".claude/hooks/app-check-validator.js",".claude/hooks/typescript-strict-check.js",".claude/hooks/repository-pattern-check.js",".claude/hooks/test-mocking-validator.js"],"why_it_matters":"Stage 2a found up to 7 hooks independently calling fs.readFileSync on the same target file per Edit operation. This is a performance anti-pattern that compounds with the 10-process-per-Write issue. No tooling detects or prevents this redundant I/O pattern.","suggested_fix":"This is best solved by hook consolidation (unified-post-tool-use.js). As an interim measure, add a lint rule to check-orphaned-hooks.js or a new script that detects multiple hooks reading the same env variable (CLAUDE_FILE_PATHS) and flags them for consolidation.","acceptance_tests":["Unified hook reads target file content once and passes to all check functions","Or: lint rule flags multiple hooks doing fs.readFileSync on CLAUDE_FILE_PATHS","Per-Edit disk I/O reduced from 7 reads to 1"]}
