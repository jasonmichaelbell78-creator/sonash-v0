{"category":"ai-optimization","title":"SessionStart: session-start.js spawns 6+ sequential execSync subprocesses","fingerprint":"ai-optimization::session-start.js::sequential-execsync","severity":"S2","effort":"E2","confidence":95,"files":[".claude/hooks/session-start.js"],"why_it_matters":"SessionStart is on the critical path for every new session. session-start.js calls execSync sequentially for: node -v, npm -v, npm ci (root), npm ci (functions), npm run build (functions), npm run test:build, node scripts/check-pattern-compliance.js, node scripts/run-consolidation.js. Each execSync spawns a new shell process (~50-150ms overhead each). Total hook time can exceed 30-60 seconds.","suggested_fix":"Parallelize independent operations using Promise.all with child_process.exec (async). npm ci root and npm ci functions are independent. node -v and npm -v can run in parallel. Build steps that depend on install can be chained but run concurrently with unrelated checks. Pattern compliance and consolidation checks are independent of each other.","acceptance_tests":["SessionStart completes in under 15 seconds when no installs are needed","Independent checks (pattern-compliance, consolidation, TDMS) run in parallel"]}
{"category":"ai-optimization","title":"SessionStart: check-remote-session-context.js runs git fetch on every session start","fingerprint":"ai-optimization::check-remote-session-context.js::git-fetch-critical-path","severity":"S2","effort":"E1","confidence":90,"files":[".claude/hooks/check-remote-session-context.js"],"why_it_matters":"git fetch --quiet origin runs synchronously on SessionStart critical path. Network latency can add 2-10+ seconds to every session startup. The hook then iterates up to 10 remote branches calling git show for each, adding further latency with multiple sequential execFileSync calls (up to 11 git subprocess spawns total).","suggested_fix":"Move git fetch to a background/async operation or cache the result. Only re-fetch if last fetch was more than N minutes ago. Alternatively, run this hook in the background (non-blocking) since the information is advisory only.","acceptance_tests":["SessionStart does not block on network I/O for remote branch checking","git fetch result is cached with a TTL of at least 5 minutes"]}
{"category":"ai-optimization","title":"SessionStart: stop-serena-dashboard.js spawns PowerShell subprocesses for process discovery","fingerprint":"ai-optimization::stop-serena-dashboard.js::powershell-subprocess-overhead","severity":"S3","effort":"E1","confidence":85,"files":[".claude/hooks/stop-serena-dashboard.js"],"why_it_matters":"On Windows, this hook spawns PowerShell twice (Get-NetTCPConnection then Get-CimInstance) plus taskkill. PowerShell startup alone adds 500-2000ms. This runs on every SessionStart even when no Serena dashboard is running. The hook has a 10-second timeout but PowerShell cold start can consume significant time.","suggested_fix":"Use a lighter-weight check first: try to connect to port 24282 with Node.js net.createConnection() which takes ~5ms if nothing is listening. Only spawn PowerShell if something is actually listening. Alternative: use child_process.execFileSync with netstat instead of PowerShell for faster process discovery.","acceptance_tests":["When no process is on port 24282, hook completes in under 50ms","PowerShell is only spawned when a listening process is confirmed"]}
{"category":"ai-optimization","title":"PostToolUse Write: 10 sequential hook processes spawned per Write operation","fingerprint":"ai-optimization::posttooluse-write::10-sequential-hooks","severity":"S1","effort":"E2","confidence":95,"files":[".claude/settings.json"],"why_it_matters":"Every Write tool call spawns 10 separate Node.js processes sequentially: check-requirements, audit-s0s1-validator, pattern-check, component-size-check, firestore-write-block, test-mocking-validator, app-check-validator, typescript-strict-check, repository-pattern-check, agent-trigger-enforcer. Node.js cold start is ~30-50ms each, so minimum overhead is 300-500ms per Write even when all hooks bail out early. This is the most frequently triggered hook chain.","suggested_fix":"Consolidate into a single unified PostToolUse hook that runs all checks in-process. Each current hook does simple regex/string matching on file paths and content -- no reason to spawn separate processes. A single entry point could import check functions and run them sequentially in one process, saving ~9 process spawns (~270-450ms) per Write.","acceptance_tests":["PostToolUse Write hooks complete in under 100ms total for non-matching files","Only 1 Node.js process is spawned instead of 10"]}
{"category":"ai-optimization","title":"PostToolUse Edit: 9 sequential hook processes spawned per Edit operation","fingerprint":"ai-optimization::posttooluse-edit::9-sequential-hooks","severity":"S1","effort":"E2","confidence":95,"files":[".claude/settings.json"],"why_it_matters":"Every Edit tool call spawns 9 separate Node.js processes: check-requirements, pattern-check, component-size-check, firestore-write-block, test-mocking-validator, app-check-validator, typescript-strict-check, repository-pattern-check, agent-trigger-enforcer. Same overhead as Write hooks minus audit-s0s1-validator. Edit is the most common tool used during coding sessions.","suggested_fix":"Same consolidation as Write hooks. Create a unified post-tool-use.js that accepts CLAUDE_TOOL as a parameter and runs all applicable checks in a single process. Share the file content read across checks to avoid redundant fs.readFileSync calls (currently 6 hooks may independently read the same file).","acceptance_tests":["PostToolUse Edit hooks complete in under 100ms total for non-matching files","Only 1 Node.js process is spawned instead of 9"]}
{"category":"ai-optimization","title":"PostToolUse Read: 3 hooks with redundant file reads and state tracking","fingerprint":"ai-optimization::posttooluse-read::redundant-state-tracking","severity":"S2","effort":"E1","confidence":85,"files":[".claude/hooks/large-context-warning.js",".claude/hooks/auto-save-context.js",".claude/hooks/compaction-handoff.js"],"why_it_matters":"On every Read operation, 3 separate processes spawn: large-context-warning.js, auto-save-context.js, compaction-handoff.js. All three read .context-tracking-state.json independently. large-context-warning.js reads the target file to count lines (potentially large). compaction-handoff.js calls execSync 5 times for git operations when threshold is hit. All share similar threshold logic that could be unified.","suggested_fix":"Consolidate into a single read-tracking.js hook. Read .context-tracking-state.json once. Check all three thresholds in one pass. Only spawn git operations when compaction handoff threshold is actually exceeded (already gated by cooldown, but the process spawn overhead is unnecessary when below threshold).","acceptance_tests":["PostToolUse Read hooks complete in under 50ms when thresholds are not exceeded","Context tracking state is read only once per Read operation"]}
{"category":"ai-optimization","title":"compaction-handoff.js uses execSync (shell) instead of execFileSync for git commands","fingerprint":"ai-optimization::compaction-handoff.js::execsync-shell-overhead","severity":"S2","effort":"E0","confidence":95,"files":[".claude/hooks/compaction-handoff.js"],"why_it_matters":"compaction-handoff.js gitExec() uses execSync (which spawns a shell) instead of execFileSync (which calls git directly). Shell spawn adds ~20-50ms overhead per call. The function is called 5 times for git operations: rev-parse, log --oneline -1, diff --name-only, ls-files, diff --cached, log --oneline -10. This is both a performance issue and a security issue (shell injection risk via crafted branch names).","suggested_fix":"Change execSync to execFileSync with array arguments, matching the pattern already used in commit-tracker.js and pre-compaction-save.js. This is a simple find-and-replace: execSync('git rev-parse --abbrev-ref HEAD') becomes execFileSync('git', ['rev-parse', '--abbrev-ref', 'HEAD']).","acceptance_tests":["compaction-handoff.js uses execFileSync instead of execSync for all git commands","No shell is spawned for git operations"]}
{"category":"ai-optimization","title":"agent-trigger-enforcer.js loads external config via require() on every invocation","fingerprint":"ai-optimization::agent-trigger-enforcer.js::require-config-overhead","severity":"S3","effort":"E1","confidence":80,"files":[".claude/hooks/agent-trigger-enforcer.js","scripts/config/load-config.js"],"why_it_matters":"agent-trigger-enforcer.js calls loadConfigWithRegex('agent-triggers') which reads and parses a JSON file from disk, then recursively converts regex descriptor objects to RegExp instances. This happens on every Write, Edit, and MultiEdit operation. While Node.js caches require(), the loadConfig function always re-reads from disk since it uses fs.readFileSync directly rather than require().","suggested_fix":"Cache the parsed config in-memory by using require() for the JSON file instead of fs.readFileSync, or add a module-level cache with a file mtime check. Better yet, if hooks are consolidated into a single process, this config only needs to be loaded once.","acceptance_tests":["Agent trigger config is loaded from disk at most once per hook process invocation","Config parsing overhead is less than 5ms"]}
{"category":"ai-optimization","title":"Duplicate file content reads across PostToolUse hooks","fingerprint":"ai-optimization::posttooluse::duplicate-file-reads","severity":"S2","effort":"E1","confidence":90,"files":[".claude/hooks/firestore-write-block.js",".claude/hooks/app-check-validator.js",".claude/hooks/typescript-strict-check.js",".claude/hooks/repository-pattern-check.js",".claude/hooks/test-mocking-validator.js",".claude/hooks/component-size-check.js",".claude/hooks/pattern-check.js"],"why_it_matters":"When the Edit tool is used (no content in arguments), up to 7 hooks independently call fs.readFileSync on the same target file. For a 500-line TypeScript component file, this means 7 separate disk reads of the same content. Combined with per-process overhead, this multiplies I/O waste. pattern-check.js additionally calls fs.realpathSync and fs.statSync.","suggested_fix":"In a consolidated hook, read the file once and pass the content to all check functions. For the current architecture, the Write tool already includes content in the JSON arguments -- ensure Edit tool hooks parse content from arguments when available before falling back to disk reads.","acceptance_tests":["Target file is read from disk at most once across all PostToolUse checks","File content is shared across check functions in unified hook"]}
{"category":"ai-optimization","title":"large-context-warning.js reads entire file just to count lines","fingerprint":"ai-optimization::large-context-warning.js::full-file-read-for-line-count","severity":"S3","effort":"E0","confidence":85,"files":[".claude/hooks/large-context-warning.js"],"why_it_matters":"large-context-warning.js reads the entire file content with fs.readFileSync then splits by newline to count lines. For large files (the exact ones this hook is designed to warn about), this can be slow and memory-intensive. A 5000-line file could be several hundred KB.","suggested_fix":"Use fs.statSync to get file size and estimate line count (average ~40-80 bytes per line for code files), or read only the first N bytes to count newlines. Alternatively, use a streaming approach with fs.createReadStream to count newlines without loading the entire file into memory.","acceptance_tests":["Line counting for files over 100KB uses streaming or size estimation","Hook does not load entire file into memory for line counting"]}
{"category":"ai-optimization","title":"check-edit-requirements.js and check-write-requirements.js are superseded but still present","fingerprint":"ai-optimization::orphaned-hooks::check-edit-write-requirements","severity":"S3","effort":"E0","confidence":90,"files":[".claude/hooks/check-edit-requirements.js",".claude/hooks/check-write-requirements.js"],"why_it_matters":"check-requirements.js was created as a unified replacement for check-edit-requirements.js and check-write-requirements.js. The settings.json now uses check-requirements.js for all three tool types (Write, Edit, MultiEdit). The old files are still present on disk but are not referenced in settings.json hooks configuration. They add confusion and maintenance burden.","suggested_fix":"Delete check-edit-requirements.js and check-write-requirements.js since they are fully superseded by check-requirements.js. Verify no other configuration or script references them before deletion.","acceptance_tests":["check-edit-requirements.js and check-write-requirements.js are removed","No hook configuration references the deleted files","check-requirements.js handles all Write/Edit/MultiEdit cases"]}
{"category":"ai-optimization","title":"UserPromptSubmit: 4 hooks run on every user message including heavy regex matching","fingerprint":"ai-optimization::userpromptsubmit::4-hooks-every-message","severity":"S2","effort":"E1","confidence":85,"files":[".claude/hooks/alerts-reminder.js",".claude/hooks/analyze-user-request.js",".claude/hooks/session-end-reminder.js",".claude/hooks/plan-mode-suggestion.js"],"why_it_matters":"Every user message triggers 4 separate Node.js process spawns. analyze-user-request.js constructs multiple RegExp objects dynamically per invocation for word boundary matching. plan-mode-suggestion.js tests 20+ regex patterns against the user message. alerts-reminder.js reads 4 separate JSON files from disk. Total overhead is ~200-400ms per user message.","suggested_fix":"Consolidate into a single user-prompt-handler.js. Read all necessary state files once. Run all pattern matching in a single pass. The four hooks have zero dependencies on each other and could trivially be combined into sequential function calls in one process.","acceptance_tests":["UserPromptSubmit hooks complete in under 80ms total","Only 1 Node.js process is spawned for UserPromptSubmit"]}
{"category":"ai-optimization","title":"pre-compaction-save.js calls 7 git subprocess operations sequentially","fingerprint":"ai-optimization::pre-compaction-save.js::7-sequential-git-calls","severity":"S3","effort":"E1","confidence":80,"files":[".claude/hooks/pre-compaction-save.js"],"why_it_matters":"pre-compaction-save.js gatherGitContext() calls execFileSync 7 times sequentially for: rev-parse, log -1, log -15, diff --name-only, diff --cached, ls-files, and another rev-parse. Each spawns a separate git process. While PreCompact is less frequent than PostToolUse, it adds unnecessary latency during compaction.","suggested_fix":"Combine git commands where possible. Use git status --porcelain=v2 to get staged, unstaged, and untracked files in a single call. Combine the two log commands into one (git log --oneline -15 subsumes git log --oneline -1). This reduces 7 calls to approximately 3.","acceptance_tests":["Git context gathering uses no more than 4 subprocess calls","git status --porcelain replaces separate diff and ls-files calls"]}
{"category":"ai-optimization","title":"commit-tracker.js spawns 4 git subprocesses on commit detection","fingerprint":"ai-optimization::commit-tracker.js::4-git-subprocesses","severity":"S3","effort":"E1","confidence":80,"files":[".claude/hooks/commit-tracker.js"],"why_it_matters":"When a commit is detected, commit-tracker.js calls gitExec 4 times: rev-parse HEAD, git log --format, rev-parse --abbrev-ref HEAD, and diff-tree. It also reads SESSION_CONTEXT.md to extract the session counter. While the fast-path regex bail-out is good (~1ms for non-commit commands), the commit detection path spawns 4 git processes sequentially.","suggested_fix":"Combine rev-parse HEAD and rev-parse --abbrev-ref HEAD into a single call using git log --format='%H%x1f%h%x1f%s%x1f%an%x1f%ad%x1f%D' which includes the ref names. This reduces from 4 to 2 git calls.","acceptance_tests":["Commit tracking uses no more than 3 git subprocess calls","rev-parse calls are combined into the log format string"]}
{"category":"ai-optimization","title":"pattern-check.js calls fs.realpathSync twice (file and project dir)","fingerprint":"ai-optimization::pattern-check.js::double-realpathsync","severity":"S3","effort":"E0","confidence":75,"files":[".claude/hooks/pattern-check.js"],"why_it_matters":"pattern-check.js calls fs.realpathSync on both the target file path and the project directory on every invocation. realpathSync resolves symlinks by making multiple OS calls. The project directory never changes within a session, so resolving it every time is wasteful. Combined with the statSync call, this is 3 synchronous filesystem metadata operations per hook invocation.","suggested_fix":"Cache the resolved project directory path. It could be computed once at module load time since it will not change. This saves one realpathSync call per invocation.","acceptance_tests":["Project directory realpathSync result is cached","Only the target file path is resolved per invocation"]}
{"category":"ai-optimization","title":"alerts-reminder.js reads 4 JSON files synchronously on every user prompt","fingerprint":"ai-optimization::alerts-reminder.js::4-file-reads-every-prompt","severity":"S3","effort":"E1","confidence":80,"files":[".claude/hooks/alerts-reminder.js"],"why_it_matters":"alerts-reminder.js reads up to 4 files on every UserPromptSubmit: pending-alerts.json, alerts-acknowledged.json, .context-tracking-state.json, and pending-mcp-save.json. This happens on every single user message, even when there are no pending alerts. Each file read involves a try/catch with JSON.parse.","suggested_fix":"Add a fast-path check: if pending-alerts.json does not exist (the common case when no alerts are active), skip all subsequent file reads. Use a single statSync to check existence before reading. Alternatively, consolidate with the other UserPromptSubmit hooks to share file reads.","acceptance_tests":["When no pending-alerts.json exists, hook completes in under 5ms with zero file reads","File reads are skipped when alerts file is absent"]}
