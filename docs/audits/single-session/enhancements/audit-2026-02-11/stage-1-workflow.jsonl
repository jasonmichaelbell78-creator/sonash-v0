{"category":"workflow-lifecycle","title":"Session-start timeout risks in low-bandwidth environments","fingerprint":"workflow-session-start-timeout","impact":"I2","effort":"E1","confidence":78,"files":[".claude/hooks/session-start.js:1"],"current_approach":"Session-start hook runs multiple npm commands and checks synchronously without timeout guards","proposed_outcome":"Add per-step timeouts (e.g., 10s for dependency checks, 30s for builds) with graceful fallback on timeout","counter_argument":"Session-start works reliably in practice; adding timeout logic adds complexity; failures are already handled with try/catch","why_it_matters":"In slow network environments, npm commands can hang indefinitely, blocking the entire session start","evidence":"Session-start hook runs npm install, tsc builds, and multiple checks without timeout guards"}
{"category":"workflow-lifecycle","title":"Duplicate hook validation for Write+Edit+MultiEdit tools","fingerprint":"workflow-duplicate-hook-validation","impact":"I1","effort":"E2","confidence":82,"files":[".claude/hooks/:multiple"],"current_approach":"Some PostToolUse hooks run the same validation for Write, Edit, and MultiEdit events, tripling execution","proposed_outcome":"Consolidate into single handler that triggers on any file-modifying tool, deduplicating per-file checks","counter_argument":"Each tool type may need different validation logic; consolidation could miss tool-specific edge cases; current duplication is simple and reliable","why_it_matters":"Reduces hook execution time and prevents inconsistent behavior if one tool's handler is updated but others aren't","evidence":"Multiple hooks registered for Write, Edit, and MultiEdit with similar validation logic"}
{"category":"workflow-lifecycle","title":"Firebase deployment lacks rollback on partial failure","fingerprint":"workflow-firebase-deploy-no-rollback","impact":"I2","effort":"E2","confidence":75,"files":["firebase.json:1"],"current_approach":"Firebase deploy pushes hosting + functions together; if functions fail after hosting succeeds, app is in inconsistent state","proposed_outcome":"Deploy functions first (validate), then hosting. Add rollback script that reverts to previous version on failure","counter_argument":"Firebase hosting is versioned and supports instant rollback via console; partial failures are rare; adding rollback automation adds significant complexity","why_it_matters":"Inconsistent deployment state can cause runtime errors when frontend expects API endpoints that haven't deployed","evidence":"firebase.json configures both hosting and functions targets deployed together"}
{"category":"workflow-lifecycle","title":"CI runs full build twice - once for lint, once for test","fingerprint":"workflow-ci-duplicate-build","impact":"I1","effort":"E2","confidence":80,"files":[".github/workflows/ci.yml:1"],"current_approach":"CI pipeline builds the project for linting and then rebuilds for testing, duplicating the compilation step","proposed_outcome":"Build once, share artifacts between lint and test jobs using GitHub Actions cache or artifact upload","counter_argument":"Separate builds ensure isolation; shared artifacts add complexity; CI time may already be acceptable","why_it_matters":"Reduces CI pipeline duration by eliminating redundant compilation, faster PR feedback","evidence":"CI workflow has separate build steps for lint and test stages"}
{"category":"external-services","title":"SonarCloud not enforced in CI gates","fingerprint":"workflow-sonarcloud-not-enforced","impact":"I2","effort":"E1","confidence":85,"files":[".github/workflows/ci.yml:1"],"current_approach":"SonarCloud analysis runs in CI but results are not used as a gate - PRs can merge even with new issues","proposed_outcome":"Add SonarCloud quality gate check as required status check for PR merge","counter_argument":"SonarCloud quality gates can be overly strict and block PRs for minor issues; team may prefer advisory mode; gate thresholds need tuning first","why_it_matters":"Without enforcement, SonarCloud findings accumulate without accountability, reducing the tool's value","evidence":"SonarCloud integration exists but not configured as blocking CI check"}
{"category":"external-services","title":"Sentry disabled in dev mode by default","fingerprint":"workflow-sentry-disabled-dev","impact":"I1","effort":"E1","confidence":76,"files":["lib/sentry.ts:1"],"current_approach":"Sentry error tracking only active in production, dev errors go to console only","proposed_outcome":"Enable Sentry in dev mode with reduced sampling rate and dev-specific project/environment tag","counter_argument":"Dev errors are noisy and would pollute Sentry dashboard; console is sufficient for local debugging; adds API calls during development","why_it_matters":"Some errors only reproduce in specific conditions; having dev errors in Sentry helps identify patterns before they reach production","evidence":"Sentry initialization checks for production environment before enabling"}
{"category":"workflow-lifecycle","title":"Hook performance not tracked - no metrics on execution time","fingerprint":"workflow-hook-performance-untracked","impact":"I2","effort":"E2","confidence":72,"files":[".claude/hooks/:multiple"],"current_approach":"Hooks execute without performance tracking; no visibility into which hooks are slow or how total hook time trends","proposed_outcome":"Add lightweight timing wrapper that logs hook execution times to .claude/state/hook-metrics.jsonl for analysis","counter_argument":"Adding timing to every hook adds overhead; the data may not be actionable; hooks are already fast enough; more infrastructure to maintain","why_it_matters":"Without metrics, slow hooks accumulate unnoticed, gradually degrading developer experience","evidence":"20+ hooks in .claude/hooks/ with no execution time tracking"}
{"category":"external-services","title":"Firebase emulator not used in CI for integration tests","fingerprint":"workflow-firebase-emulator-ci","impact":"I2","effort":"E2","confidence":74,"files":[".github/workflows/ci.yml:1","firebase.json:1"],"current_approach":"CI tests mock Firebase entirely; no integration tests run against Firebase emulator","proposed_outcome":"Add Firebase emulator to CI pipeline for integration tests that verify actual Firestore queries and Cloud Functions","counter_argument":"Firebase emulator adds significant CI setup time (2-3 min); mocks are sufficient for unit tests; emulator can be flaky in CI; current test strategy works","why_it_matters":"Mock-only testing misses real Firestore query behavior, security rules enforcement, and Cloud Function integration issues","evidence":"Tests use mocked httpsCallable, no emulator configuration in CI workflow"}
{"category":"workflow-lifecycle","title":"Pre-push duplicates pre-commit pattern checks","fingerprint":"workflow-prepush-duplicate-patterns","impact":"I1","effort":"E0","confidence":88,"files":[".husky/pre-push:1",".husky/pre-commit:1"],"current_approach":"Pattern compliance check runs in both pre-commit (blocking) and pre-push (blocking), duplicating 1-2s of work","proposed_outcome":"Remove pattern check from pre-push; rely on pre-commit for pattern enforcement since it already blocks commits","counter_argument":"Pre-push is a safety net for --no-verify commits; defense in depth is valuable; 1-2s is negligible","why_it_matters":"Saves time per push and prevents graduated enforcement self-escalation (warned in pre-commit, blocked in pre-push)","evidence":"Both .husky/pre-commit and .husky/pre-push run npm run patterns:check"}
{"category":"workflow-lifecycle","title":"Session-start consolidation check blocks synchronously","fingerprint":"workflow-session-start-sync-consolidation","impact":"I2","effort":"E1","confidence":75,"files":[".claude/hooks/session-start.js:1"],"current_approach":"Auto-consolidation check runs synchronously during session-start, adding latency to every session","proposed_outcome":"Run consolidation check asynchronously or defer to first idle moment after session starts","counter_argument":"Consolidation check is fast (<1s usually); async execution could miss showing results to user; synchronous is simpler and more reliable","why_it_matters":"Every second added to session-start creates friction and delays the user from starting productive work","evidence":"Session-start hook runs consolidation check synchronously before yielding control"}
{"type":"strength","domain":"workflow","description":"Compaction-resilient state persistence with 4-layer approach (commit-tracker, compaction-handoff, pre-compaction-save, compact-restore)","evidence":["4 independent layers ensure no state loss across compaction","commit-log.jsonl as single source of truth","Successfully recovered from crashes in production use"]}
{"type":"strength","domain":"workflow","description":"Intelligent session-start hook with hash-based dependency caching skips unchanged installs","evidence":["Compares lockfile hash to skip npm install","Skips Firebase build if unchanged","Saves 30-60s per session when deps haven't changed"]}
{"type":"strength","domain":"workflow","description":"Well-structured pre-commit chain with granular escape hatches via environment variables","evidence":["SKIP_CROSS_DOC_CHECK, SKIP_AUDIT_VALIDATION, SKIP_TRIGGERS available","Each check independently skippable","Clear error messages with remediation guidance"]}
{"type":"strength","domain":"workflow","description":"Efficient GitHub Actions CI with proper job structure and artifact handling","evidence":["Separate lint, test, and deploy jobs","Proper dependency caching for node_modules","Status checks integrated with PR workflow"]}
