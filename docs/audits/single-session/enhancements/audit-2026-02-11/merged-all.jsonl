{"category":"app-architecture","title":"Consolidate duplicate mood selector components - 3 implementations with diverging mood options","fingerprint":"arch-mood-selector-consolidation","impact":"I1","effort":"E1","confidence":85,"files":["components/mood-selector.tsx:1","components/daily-log/mood-selector.tsx:1"],"current_approach":"3 separate mood selector implementations exist with different emoji sets and mood option arrays. Each has diverged over time","proposed_outcome":"Single configurable MoodSelector component with props for mood options, allowing each usage to specify its variant while sharing core selection logic","counter_argument":"Each selector may serve a different UX context with intentionally different mood options. Consolidation could create an overly complex component that is harder to maintain than 3 simple ones","why_it_matters":"Duplicate components diverge over time, creating inconsistent user experience and tripling the maintenance burden for mood-related features","evidence":"3 mood selector implementations found with different emoji sets across components/"}
{"category":"app-architecture","title":"Extract meeting time parsing logic - ~80 lines duplicated between 2 files","fingerprint":"arch-meeting-time-parsing-dedup","impact":"I1","effort":"E1","confidence":88,"files":["components/meetings/meeting-form.tsx:1","components/meetings/meeting-list.tsx:1"],"current_approach":"Meeting time parsing logic (~80 lines) is duplicated between meeting-form.tsx and meeting-list.tsx with slightly different implementations","proposed_outcome":"Extract into a shared parseMeetingTime utility in lib/ or hooks/, used by both components","counter_argument":"The duplication is small (~80 lines) and each version may have context-specific edge cases. Extracting could create coupling between unrelated components","why_it_matters":"Duplicated parsing logic is a bug magnet - fixes applied to one copy but not the other create subtle inconsistencies","evidence":"~80 lines of time parsing duplicated between 2 meeting component files"}
{"category":"app-architecture","title":"Migrate useAuth consumers to focused hooks - 16 components still using deprecated hook","fingerprint":"arch-useauth-migration","impact":"I1","effort":"E2","confidence":82,"files":["hooks/useAuth.ts:1"],"current_approach":"16 components still use the deprecated useAuth() hook which returns the full auth context, while 2 focused hooks (useUser, useTodayLog) exist but are underutilized","proposed_outcome":"Migrate all 16 components to use focused hooks (useUser for stable user data, useTodayLog for volatile daily data), reducing unnecessary re-renders","counter_argument":"The migration requires touching 16 files with potential for regressions. The deprecated hook still works correctly, just triggers extra re-renders. The performance impact may be negligible","why_it_matters":"Focused hooks prevent unnecessary re-renders when only user or only todayLog changes, improving perceived performance especially on mobile","evidence":"16 components import useAuth vs 2 using focused hooks. Auth context is split into AuthProvider (stable) and TodayLogProvider (volatile)"}
{"category":"app-architecture","title":"Extract common form state logic - ~150 lines of duplicate submission handling","fingerprint":"arch-form-state-extraction","impact":"I2","effort":"E2","confidence":78,"files":["components/journal/journal-entry-form.tsx:1","components/meetings/meeting-form.tsx:1","components/daily-log/daily-log-form.tsx:1"],"current_approach":"Multiple form components duplicate submission handling logic (~150 lines): loading state, error state, validation, toast notifications, and optimistic updates","proposed_outcome":"Create a useFormSubmission hook encapsulating common patterns: loading/error state, validation, toast feedback, and retry logic","counter_argument":"Each form has unique validation and submission logic. A generic hook could become overly abstract and harder to debug than straightforward per-form code","why_it_matters":"Reduces boilerplate in form components and ensures consistent error handling and user feedback patterns","evidence":"~150 lines of similar submission handling found across 3+ form components"}
{"category":"app-architecture","title":"Create barrel exports for component directories - only 1 exists","fingerprint":"arch-barrel-exports","impact":"I1","effort":"E1","confidence":75,"files":["components/features/index.ts:1"],"current_approach":"Only 1 barrel export file exists (features/index.ts). Other directories use direct file imports creating long import paths","proposed_outcome":"Add index.ts barrel exports to major component directories (components/journal/, components/meetings/, components/daily-log/) for cleaner imports","counter_argument":"Barrel exports can cause larger bundle sizes if tree-shaking is not configured properly. They also create circular dependency risks and can slow down IDE auto-imports","why_it_matters":"Cleaner imports improve code readability and make refactoring easier since internal file moves don't break external imports","evidence":"Only 1 barrel export found. 38 default exports vs 69 named exports showing no consistent convention"}
{"category":"app-architecture","title":"Collocate related quote components - 3 variants scattered across 2 directories","fingerprint":"arch-quote-collocation","impact":"I2","effort":"E3","confidence":72,"files":["components/quotes/:1","components/daily-log/:1"],"current_approach":"3 quote component variants are scattered across 2 different directories (components/quotes/ and components/daily-log/)","proposed_outcome":"Collocate all quote-related components in a single components/quotes/ directory with clear naming for each variant","counter_argument":"Components may be intentionally placed near their primary consumers. Moving them could break the intuitive colocation-by-usage pattern","why_it_matters":"Scattered related components make it harder to understand the full quote feature surface area and increase risk of unintentional divergence","evidence":"3 quote variants found across 2 directories"}
{"category":"app-architecture","title":"Standardize export style - 38 default vs 69 named exports with no convention","fingerprint":"arch-export-style-standardize","impact":"I0","effort":"E1","confidence":70,"files":["components/:multiple"],"current_approach":"Mixed export styles: 38 default exports and 69 named exports in component files with no documented convention","proposed_outcome":"Adopt named exports as the standard (better refactoring support, explicit imports) and add ESLint rule to enforce","counter_argument":"This is largely a stylistic preference with minimal functional impact. The refactor touches many files for cosmetic benefit and could conflict with Next.js page conventions","why_it_matters":"Consistent exports improve IDE support (auto-imports work better with named exports) and prevent the common default-export renaming issue","evidence":"38 default exports vs 69 named exports found across components/"}
{"category":"app-architecture","title":"Inconsistent loading states - spinners vs text vs skeletons across components","fingerprint":"arch-loading-states-consistency","impact":"I2","effort":"E2","confidence":76,"files":["components/:multiple"],"current_approach":"Loading states are inconsistent: some components use skeleton screens, others use spinner icons, and some show plain Loading... text","proposed_outcome":"Standardize on skeleton loading states (already have infrastructure) with a shared LoadingSkeleton component library for common patterns","counter_argument":"Different loading patterns may be intentional for different contexts (brief loads vs long loads vs initial page loads). Forcing uniformity could worsen UX in some cases","why_it_matters":"Consistent loading patterns create a more polished, professional feel and reduce perceived load times when users know what to expect","evidence":"Mix of skeleton, spinner, and text loading states found across components"}
{"category":"app-architecture","title":"useDailyQuote hook has smart module-level caching preventing duplicate fetches","fingerprint":"arch-daily-quote-caching","impact":"I3","effort":"E0","confidence":90,"files":["hooks/useDailyQuote.ts:1"],"current_approach":"useDailyQuote uses module-level caching to prevent duplicate fetches across 3 component variants that all need the daily quote","proposed_outcome":"No change needed - this is a strength. Consider documenting this pattern for reuse in other hooks","counter_argument":"N/A - strength finding","why_it_matters":"Prevents unnecessary API calls and ensures consistent data across components","evidence":"Module-level cache variable in useDailyQuote.ts shared across 3 consumers"}
{"type":"strength","domain":"architecture","description":"Split auth contexts separating stable (user) from volatile (todayLog) state - excellent performance optimization","evidence":["AuthProvider for stable user data","TodayLogProvider for volatile daily data","425 total lines across 4 well-organized auth context files"]}
{"type":"strength","domain":"architecture","description":"Consolidated useDailyQuote hook with module-level caching prevents duplicate fetches across 3 variants","evidence":["Module-level cache in useDailyQuote.ts","3 quote component variants share single fetch"]}
{"type":"strength","domain":"architecture","description":"Clean repository pattern in firestore-service.ts with security validation and rate limiting","evidence":["firestore-service.ts with structured data access","Rate limiting integration","Security validation on queries"]}
{"type":"strength","domain":"architecture","description":"AdminTabContext with smart 30-second refresh throttling prevents excessive API calls","evidence":["30-second throttle on admin tab refresh","Prevents API hammering during rapid tab switches"]}
{"category":"content","title":"Generic button labels - Submit used instead of action-specific text","fingerprint":"content-generic-submit-buttons","impact":"I2","effort":"E0","confidence":88,"files":["components/journal/journal-entry-form.tsx:1","components/meetings/meeting-form.tsx:1"],"current_approach":"Several forms use generic Submit or Save button labels instead of action-specific text","proposed_outcome":"Replace with action-specific labels: Save Journal Entry, Schedule Meeting, Log Mood","counter_argument":"Generic labels are universally understood; action-specific labels add translation burden; Submit is a standard web convention","why_it_matters":"Action-specific button labels reduce cognitive load and confirm what will happen when clicked","evidence":"Generic Submit/Save buttons found in form components"}
{"category":"content","title":"Error messages don't guide user to fix the problem","fingerprint":"content-unhelpful-error-messages","impact":"I1","effort":"E1","confidence":82,"files":["components/:multiple"],"current_approach":"Error messages show what went wrong but not how to fix it (e.g., Something went wrong without next steps)","proposed_outcome":"Add actionable guidance to error messages: what failed, why, and what to try next","counter_argument":"Detailed error messages can be confusing; recovery-domain users may find technical details stressful; generic messages are simpler to maintain","why_it_matters":"Actionable error messages reduce support burden and user frustration, especially for daily-use apps","evidence":"Error handling shows generic messages like Something went wrong or An error occurred"}
{"category":"content","title":"Missing empty states for lists and data views","fingerprint":"content-missing-empty-states","impact":"I2","effort":"E1","confidence":85,"files":["components/journal/:multiple","components/meetings/:multiple"],"current_approach":"Empty lists show no content or a minimal No items found message without guidance","proposed_outcome":"Add empty state components with illustration, message, and CTA: No journal entries yet - Start your first entry","counter_argument":"Empty states add component complexity; users may not see them often after initial setup; recovery domain may not need encouragement-style CTAs","why_it_matters":"Good empty states guide new users and reduce the feeling that something is broken","evidence":"List components render nothing or minimal text when data arrays are empty"}
{"category":"content","title":"Inconsistent terminology - meeting vs session vs appointment","fingerprint":"content-inconsistent-terminology","impact":"I2","effort":"E1","confidence":78,"files":["components/meetings/:multiple","app/:multiple"],"current_approach":"Mixed terminology for the same concept: meeting, session, and appointment used interchangeably across the UI","proposed_outcome":"Standardize on one term (meeting is most common) and create a terminology guide","counter_argument":"Different terms may be contextually appropriate; forcing one term could sound awkward in some contexts; recovery community may have preferred terminology","why_it_matters":"Inconsistent terminology confuses users and makes the app feel less professional","evidence":"Multiple terms for same concept found across meeting-related components"}
{"category":"content","title":"Confirmation dialogs lack specific consequences","fingerprint":"content-vague-confirmation-dialogs","impact":"I2","effort":"E0","confidence":80,"files":["components/:multiple"],"current_approach":"Delete confirmations use generic Are you sure? without explaining what will be lost","proposed_outcome":"Add specific consequences: Delete this journal entry from Jan 5? This cannot be undone.","counter_argument":"Specific messages require dynamic content which adds complexity; generic confirmations are industry standard; over-specific messages can feel patronizing","why_it_matters":"Users need to understand consequences before destructive actions, especially for personal recovery data","evidence":"Confirmation dialogs found with generic Are you sure? messaging"}
{"category":"content","title":"Loading text inconsistency - Loading... vs Fetching vs spinner only","fingerprint":"content-loading-text-inconsistent","impact":"I3","effort":"E0","confidence":85,"files":["app/:multiple","components/:multiple"],"current_approach":"Loading states use different text: Loading..., Fetching data, or just a spinner with no text","proposed_outcome":"Standardize loading text or use consistent skeleton screens across all loading states","counter_argument":"Varying loading text is natural and not confusing; users understand all variants; standardizing is cosmetic","why_it_matters":"Consistent loading patterns create a more cohesive, polished user experience","evidence":"Multiple loading text variants found across app and component directories"}
{"category":"content","title":"Date formats inconsistent across the app","fingerprint":"content-date-format-inconsistent","impact":"I2","effort":"E1","confidence":82,"files":["components/:multiple","lib/:multiple"],"current_approach":"Dates displayed in different formats: Jan 5, 2026 vs 1/5/2026 vs 2026-01-05 across different views","proposed_outcome":"Create a shared formatDate utility with consistent format (e.g., Jan 5, 2026 for display, ISO for data)","counter_argument":"Different contexts may warrant different formats (tables vs cards vs headers); a utility adds indirection; current formatting works","why_it_matters":"Inconsistent date formats reduce readability and make the app feel unpolished","evidence":"Multiple date formatting approaches found across components and lib files"}
{"category":"content","title":"Success feedback messages too brief","fingerprint":"content-brief-success-messages","impact":"I3","effort":"E0","confidence":75,"files":["components/:multiple"],"current_approach":"Success toasts show minimal text like Saved or Updated without confirming what was saved","proposed_outcome":"Add context to success messages: Journal entry saved for Jan 5 or Meeting updated to 3:00 PM","counter_argument":"Brief success messages are less intrusive; adding context requires passing data to toast; toasts should be dismissible not informational","why_it_matters":"Contextual success messages confirm the user's action and build confidence that the right thing was saved","evidence":"Toast notifications with minimal text observed in form submission handlers"}
{"type":"strength","domain":"content","description":"Recovery-domain appropriate tone - supportive, non-judgmental language throughout the app","evidence":["No harsh error language found","Encouraging microcopy in daily log and journal sections"]}
{"type":"strength","domain":"content","description":"Consistent use of sonner toasts for all action feedback - unified feedback pattern","evidence":["Toast notifications for save, delete, error actions across all components","Consistent positioning and styling"]}
{"type":"strength","domain":"content","description":"Good use of descriptive page titles and headings for navigation clarity","evidence":["Clear page titles in app/ layout files","Descriptive section headings in dashboard and journal views"]}
{"category":"devx-automation","title":"Pre-commit hook parallelization - sequential checks could run 40% faster","fingerprint":"devx-precommit-parallel","impact":"I1","effort":"E2","confidence":80,"files":[".husky/pre-commit:1"],"current_approach":"Pre-commit runs 13 validation gates sequentially (ESLint, lint-staged, pattern compliance, tests, skill validation, cross-doc deps, doc index, doc headers, agent compliance). Total time 3-5s per commit","proposed_outcome":"Run independent checks in parallel (ESLint + pattern compliance + skill validation can all run concurrently), reducing total time to 2-3s","counter_argument":"Sequential execution provides clear error messages in order of importance. Parallel execution would interleave output and make failures harder to diagnose. The 1-2s savings may not justify the complexity","why_it_matters":"With 361 commits in 2 weeks, even 1-2s savings per commit adds up to 6-12 minutes of developer time saved","evidence":"Pre-commit hook is 279 lines with 13 sequential validation gates"}
{"category":"devx-automation","title":"CI non-blocking checks should block - 5 checks use continue-on-error","fingerprint":"devx-ci-nonblocking-checks","impact":"I1","effort":"E1","confidence":85,"files":[".github/workflows/ci.yml:1"],"current_approach":"5 CI checks use continue-on-error: true, including pattern compliance and debt views, allowing failures to merge","proposed_outcome":"Make pattern compliance and debt view checks blocking in CI. Keep only cosmetic/advisory checks as non-blocking","counter_argument":"Non-blocking checks were set that way intentionally to avoid blocking PRs on non-critical issues during rapid development. Tightening could slow PR velocity","why_it_matters":"Non-blocking checks that always pass provide false confidence. If they fail silently, issues accumulate undetected","evidence":"5 checks with continue-on-error: true in ci.yml"}
{"category":"devx-automation","title":"Script consolidation - 30+ check/validate/sync scripts with inconsistent CLI patterns","fingerprint":"devx-script-consolidation","impact":"I2","effort":"E3","confidence":75,"files":["scripts/:multiple","package.json:1"],"current_approach":"30+ individual scripts (check-pattern-compliance.js, check-docs-light.js, check-review-needed.js, validate-phase-completion.js, sync-sonarcloud.js, etc.) each with different CLI argument parsing and output formats","proposed_outcome":"Consolidate into unified CLI with subcommands: sonash check patterns, sonash check docs, sonash validate phase, etc. Share common arg parsing and output formatting","counter_argument":"Each script evolved independently for good reasons and has its own test coverage. Consolidation is a large refactor with high risk of regression and the current system works","why_it_matters":"Consistent CLI patterns reduce cognitive load and make scripts easier to discover, document, and maintain","evidence":"82 npm scripts in package.json, 85 files in scripts/ directory"}
{"category":"devx-automation","title":"Duplicate pattern check runs in both pre-commit and pre-push","fingerprint":"devx-duplicate-pattern-check","impact":"I2","effort":"E0","confidence":90,"files":[".husky/pre-commit:1",".husky/pre-push:1"],"current_approach":"npm run patterns:check runs in both pre-commit (blocking) and pre-push (blocking). The pre-push check adds no value since pre-commit already caught violations","proposed_outcome":"Remove pattern check from pre-push hook, keeping only in pre-commit. Pre-push should focus on checks not already done (circular deps, type check, security audit)","counter_argument":"Pre-push is a safety net for cases where pre-commit was bypassed (--no-verify). Defense in depth principle says redundancy is acceptable","why_it_matters":"Saves 1-2s per push and reduces false graduation in the new graduated enforcement system","evidence":"Both .husky/pre-commit and .husky/pre-push run npm run patterns:check"}
{"category":"devx-automation","title":"Missing CI build caching for .next/cache and dist-tests","fingerprint":"devx-ci-build-caching","impact":"I2","effort":"E1","confidence":82,"files":[".github/workflows/ci.yml:1"],"current_approach":"CI builds .next and dist-tests from scratch on every run with no caching","proposed_outcome":"Add GitHub Actions cache for .next/cache and dist-tests/ directories, reducing CI build time by 30-60s per run","counter_argument":"Build caching can cause subtle bugs from stale cached artifacts. Clean builds are more reliable even if slower","why_it_matters":"Faster CI feedback loop improves developer experience and reduces PR merge time","evidence":"No cache: actions in ci.yml for build artifacts"}
{"type":"strength","domain":"devx","description":"Comprehensive pre-commit pipeline with 13 gates prevents 90%+ of issues before CI","evidence":["279-line pre-commit hook","ESLint, pattern compliance, tests, skill validation, cross-doc deps, doc index, headers, agent compliance all checked"]}
{"type":"strength","domain":"devx","description":"Security-first infrastructure with reusable security-helpers.js (487 lines) providing vetted patterns","evidence":["scripts/lib/security-helpers.js with sanitizeError, validatePathInDir, safeCloneObject, etc.","Referenced across 20+ scripts"]}
{"type":"strength","domain":"devx","description":"Compaction-resilient state persistence system prevents lost work across context resets","evidence":["commit-tracker.js auto-logs commits","compaction-handoff.js saves full state","compact-restore.js recovers after compaction"]}
{"type":"strength","domain":"devx","description":"60+ specialized skills covering all development phases with clear trigger documentation","evidence":[".claude/skills/ directory with 50+ skill folders","CLAUDE.md Section 6 documents agent triggers"]}
{"category":"documentation-strategy","title":"AI_WORKFLOW.md size optimization - 872 lines may exceed effective AI context loading","fingerprint":"docs-workflow-size-optimization","impact":"I2","effort":"E2","confidence":80,"files":["AI_WORKFLOW.md:1"],"current_approach":"AI_WORKFLOW.md is 872 lines loaded during session-begin, containing session checklist, skill triggers, and detailed procedures all in one file","proposed_outcome":"Extract procedure details into on-demand reference docs (like CLAUDE.md v5.0 consolidation), keeping AI_WORKFLOW.md to ~200 lines of high-priority checklist items","counter_argument":"The file is only loaded once at session start and has been working well. Splitting could create more cross-reference overhead and make the checklist harder to follow as a single narrative","why_it_matters":"Shorter AI instructions mean less token waste per session and faster context loading","evidence":"AI_WORKFLOW.md is 872 lines. CLAUDE.md was successfully reduced 77% (497→118 lines) in v5.0 with positive results"}
{"category":"documentation-strategy","title":"Stale documentation markers - 96 TODO/TBD occurrences across 34 files","fingerprint":"docs-stale-todo-tbd-markers","impact":"I2","effort":"E1","confidence":85,"files":["docs/:multiple"],"current_approach":"TODO and TBD markers exist in documentation files, some from early sessions that were never resolved","proposed_outcome":"Triage all TODO/TBD markers: resolve, remove, or convert to tracked TDMS items with clear ownership","counter_argument":"Many TODOs serve as useful placeholders for future work and removing them could lose context about intended improvements","why_it_matters":"Stale TODOs reduce documentation credibility and create confusion about what is actually planned vs abandoned","evidence":"96 TODO/TBD occurrences found across 34 files via grep"}
{"category":"documentation-strategy","title":"Security guidance consolidation - multiple overlapping security docs","fingerprint":"docs-security-guidance-consolidation","impact":"I1","effort":"E2","confidence":75,"files":["docs/SECURITY.md:1","docs/GLOBAL_SECURITY_STANDARDS.md:1","docs/agent_docs/SECURITY_CHECKLIST.md:1","docs/agent_docs/CODE_PATTERNS.md:1"],"current_approach":"Security guidance is spread across 4+ documents: SECURITY.md, GLOBAL_SECURITY_STANDARDS.md, SECURITY_CHECKLIST.md, and CODE_PATTERNS.md security section","proposed_outcome":"Consolidate into a clear hierarchy: one canonical security reference with other docs referencing it, reducing duplication and potential contradictions","counter_argument":"Each doc serves a different audience/context (pre-write checklist vs patterns reference vs global standards). Consolidation could make each use case harder to serve","why_it_matters":"Duplicated security guidance risks contradictions when one doc is updated but others are not, and increases maintenance burden","evidence":"4 separate security-focused documents with overlapping content on path traversal, error sanitization, and input validation"}
{"category":"documentation-strategy","title":"Documentation effectiveness metrics - no tracking of which docs are useful","fingerprint":"docs-effectiveness-metrics","impact":"I2","effort":"E2","confidence":70,"files":["docs/:multiple"],"current_approach":"No mechanism to track which documentation files are actually referenced or useful during AI sessions vs rarely touched","proposed_outcome":"Add lightweight doc usage tracking (e.g., log which docs are read during sessions) to identify high-value vs dead-weight documentation","counter_argument":"Adding tracking infrastructure adds complexity and the team already has good intuition about which docs matter. Over-optimization of docs could be premature","why_it_matters":"Data-driven documentation pruning would reduce maintenance burden and focus effort on docs that actually improve outcomes","evidence":"300+ markdown files in the project, unclear which are actively referenced vs historical"}
{"category":"documentation-strategy","title":"Cross-reference navigation overhead in documentation","fingerprint":"docs-crossref-navigation-overhead","impact":"I3","effort":"E1","confidence":72,"files":["CLAUDE.md:1","AI_WORKFLOW.md:1"],"current_approach":"Documents frequently use 'See X for details' cross-references, requiring multiple file reads to understand a topic","proposed_outcome":"Inline the most critical 2-3 lines from referenced docs at the point of reference, with link for full details","counter_argument":"Cross-references prevent duplication and are a standard documentation pattern. Inlining creates maintenance burden when the source changes","why_it_matters":"Reducing indirection means AI agents and humans can understand guidance without chasing references across files","evidence":"Multiple 'See: docs/agent_docs/...' references in CLAUDE.md and AI_WORKFLOW.md"}
{"type":"strength","domain":"documentation","description":"Well-structured 5-tier documentation system with clear hierarchy (CLAUDE.md → AI_WORKFLOW.md → agent_docs → technical-debt → archive)","evidence":["CLAUDE.md reduced 77% in v5.0","Clear separation between always-loaded (CLAUDE.md) and on-demand (agent_docs/) content"]}
{"type":"strength","domain":"documentation","description":"Excellent documentation automation - auto-generated index, cross-doc dependency checking, header validation, archive system","evidence":["DOCUMENTATION_INDEX.md auto-generated on commit","npm run crossdoc:check validates cross-document dependencies","Pre-commit hook validates document headers"]}
{"type":"strength","domain":"documentation","description":"Active documentation maintenance with versioning, consolidation tracking, and archival preventing doc sprawl","evidence":["Completed plans archived to docs/archive/completed-plans/","Version history tables in major documents","Consolidation trigger system in AI_REVIEW_LEARNINGS_LOG.md"]}
{"category":"infrastructure","title":"Enable Next.js experimental optimizations and bundle analysis","fingerprint":"nextjs-missing-bundle-config","impact":"I1","effort":"E0","confidence":85,"files":["next.config.mjs:12-19"],"current_approach":"Minimal next.config.mjs with only output:export and unoptimized images","proposed_outcome":"Add experimental.optimizePackageImports for heavy libraries (leaflet, recharts, framer-motion), enable bundle analyzer, configure modularizeImports for lucide-react","counter_argument":"Static export mode limits some Next.js optimizations; bundle analyzer adds dev dependency overhead; current build size may already be acceptable","why_it_matters":"Large map/chart libraries (leaflet, recharts) are imported but not tree-shaken optimally","evidence":"app/layout.tsx imports multiple heavy libraries, no dynamic imports detected, meeting-map.tsx imports entire leaflet"}
{"category":"infrastructure","title":"Add Content-Security-Policy header to Firebase hosting configuration","fingerprint":"firebase-missing-csp-header","impact":"I1","effort":"E1","confidence":75,"files":["firebase.json:6-57"],"current_approach":"Comprehensive security headers excluding CSP","proposed_outcome":"Add CSP header with directives for script-src, style-src, img-src, connect-src (Firebase domains + Google reCAPTCHA), frame-ancestors 'none'","counter_argument":"CSP can break functionality if misconfigured (reCAPTCHA, Firebase SDK, inline styles from Tailwind); requires extensive testing; existing headers provide strong baseline","why_it_matters":"CSP provides additional layer against XSS attacks; industry best practice for modern web apps","evidence":"firebase.json has X-Frame-Options, HSTS, X-Content-Type-Options but no CSP"}
{"category":"infrastructure","title":"Add engines field to root package.json for CI/CD consistency","fingerprint":"missing-node-engine-constraint","impact":"I1","effort":"E0","confidence":90,"files":["package.json:1-165","functions/package.json:13-15"],"current_approach":"Functions package.json specifies Node 20, root package.json has no engine constraint","proposed_outcome":"Add engines: {node: >=20.0.0} to root package.json matching functions runtime","counter_argument":"Lack of constraint hasn't caused issues; can be restrictive for contributors","why_it_matters":"Ensures consistent Node version across development, CI, and production","evidence":"functions/package.json:14 specifies node 20, root has no engines field"}
{"category":"infrastructure","title":"Firestore security rules file not found in repository","fingerprint":"missing-firestore-rules-file","impact":"I2","effort":"E0","confidence":70,"files":["firebase.json:72-74"],"current_approach":"firebase.json references firestore.rules but file not found in repo","proposed_outcome":"Ensure firestore.rules is tracked in repository, or confirm if managed via Firebase console","counter_argument":"Rules may be managed through Firebase console only; file might exist but search missed it","why_it_matters":"Security rules are critical infrastructure and should be version controlled for audit trail","evidence":"firebase.json:73 references firestore.rules, no .rules files found in glob search"}
{"category":"infrastructure","title":"Configure Next.js build cache and dependency caching for faster CI builds","fingerprint":"missing-ci-build-cache","impact":"I1","effort":"E1","confidence":80,"files":["next.config.mjs:12","package.json:6"],"current_approach":"No cache configuration for .next/cache or node_modules in CI","proposed_outcome":"Cache .next/cache, node_modules, and functions/lib directories; reduces build time 50-70%","counter_argument":"Cache invalidation can cause issues; storage costs; builds may already be fast enough","why_it_matters":"Faster feedback loops for PRs; reduced CI minutes consumption","evidence":"tsconfig.json:15 has incremental: true, no CI cache actions found"}
{"category":"infrastructure","title":"Lazy load Leaflet and Recharts with dynamic imports and Suspense","fingerprint":"heavy-libs-no-dynamic-import","impact":"I1","effort":"E2","confidence":75,"files":["components/maps/meeting-map.tsx:1-80"],"current_approach":"Direct synchronous imports of leaflet (500KB+) and recharts (400KB+)","proposed_outcome":"Use Next.js dynamic() with ssr: false for map components, React.lazy for charts","counter_argument":"Static export mode may limit code splitting benefits; components may be on initial page load; adds loading state complexity","why_it_matters":"Not all users visit map/chart pages; faster time-to-interactive for initial load","evidence":"meeting-map.tsx imports full leaflet synchronously, no dynamic imports for recharts"}
{"category":"infrastructure","title":"Upgrade Firebase Functions to Node.js 24 runtime","fingerprint":"functions-runtime-node20-upgrade","impact":"I0","effort":"E1","confidence":70,"files":["firebase.json:68","functions/package.json:14"],"current_approach":"Firebase Functions using Node.js 20 runtime","proposed_outcome":"Upgrade to nodejs24 runtime, update engines to node 24, test all functions","counter_argument":"Node 20 is still LTS until October 2026; no compelling features for this use case; risk of breaking changes","why_it_matters":"Longer LTS support window; aligns with bleeding-edge philosophy of the project","evidence":"firebase.json:68 shows nodejs24 available, functions uses node 20"}
{"category":"infrastructure","title":"Add composite index for userId + timestamp on security_logs collection","fingerprint":"security-logs-missing-user-timestamp-index","impact":"I1","effort":"E0","confidence":85,"files":["firestore.indexes.json:18-80"],"current_approach":"Indexes for severity+timestamp, type+functionName+timestamp, but no userId composite","proposed_outcome":"Add index for security_logs: [userId ASC, timestamp DESC] for efficient user-specific log queries","counter_argument":"Query may not exist yet; automatic indexing warnings will prompt when needed; adds storage overhead","why_it_matters":"Admin panel likely needs per-user security logs; composite index prevents full collection scans","evidence":"firestore.indexes.json has security_logs indexes but only severity/type/functionName composites"}
{"type":"strength","domain":"infrastructure","description":"Excellent security headers configuration in firebase.json - HSTS, X-Frame-Options, X-Content-Type-Options, Permissions-Policy, Referrer-Policy","evidence":["firebase.json implements comprehensive security headers","Only CSP is missing from a complete header set"]}
{"type":"strength","domain":"infrastructure","description":"Optimal Firebase configuration - Node.js 24 runtime available, proper rate limiting with Firestore persistence, comprehensive indexes","evidence":["firebase.json configured with latest runtimes","Firestore indexes cover all major query patterns"]}
{"type":"strength","domain":"infrastructure","description":"Strong TypeScript configuration - strict mode, incremental compilation, proper path aliases across all tsconfig files","evidence":["tsconfig.json with strict: true","incremental: true for faster builds","Path aliases configured"]}
{"type":"strength","domain":"infrastructure","description":"Modern build tooling - ESLint 9.x flat config, custom eslint-plugin-sonash, Prettier with sensible defaults","evidence":["eslint.config.mjs with flat config format","Custom sonash plugin for project-specific rules"]}
{"type":"strength","domain":"infrastructure","description":"Optimized font loading - self-hosted @fontsource (no Google Fonts CDN), only 2 essential fonts, font-display: swap","evidence":["@fontsource packages in dependencies","Reduced from 20+ to 2 fonts"]}
{"type":"strength","domain":"infrastructure","description":"Well-architected pre-commit hooks with smart doc-only commit detection to skip tests, comprehensive escape hatches","evidence":["pre-commit detects doc-only commits and skips test run","Environment variable overrides for each check"]}
{"category":"testing-strategy","title":"Missing Cloud Functions integration tests - only 1 skipped test exists","fingerprint":"testing-cf-integration-missing","impact":"I2","effort":"E2","confidence":85,"files":["tests/:multiple","functions/src/:multiple"],"current_approach":"Cloud Functions are tested only via mocked httpsCallable; only 1 skipped integration test exists","proposed_outcome":"Add integration tests using Firebase emulator that verify actual Cloud Function behavior, security rules enforcement, and Firestore triggers","counter_argument":"Mock-based tests are faster and more reliable in CI; emulator setup adds complexity; current mocks cover the API contract; integration tests are expensive to maintain","why_it_matters":"Mock-only testing misses real Firestore query behavior, security rules, rate limiting, and function-to-function interactions","evidence":"1 skipped integration test found; all other Cloud Function tests use mocked httpsCallable"}
{"category":"testing-strategy","title":"No visual regression testing despite Playwright being installed","fingerprint":"testing-visual-regression-missing","impact":"I2","effort":"E3","confidence":75,"files":["package.json:1",".claude/skills/test-suite/SKILL.md:1"],"current_approach":"Playwright is installed and used for protocol-based UI testing but not for visual regression (screenshot comparison)","proposed_outcome":"Add visual regression tests for key UI states (dashboard, journal entry, mood selector) using Playwright screenshot comparison","counter_argument":"Visual regression tests are brittle, require baseline maintenance, and break on intentional design changes; protocol tests already verify UI behavior; overhead may not be worth it for a small team","why_it_matters":"Catches unintended CSS/layout regressions that functional tests miss; especially important with Tailwind utility classes that can have subtle side effects","evidence":"Playwright in dependencies; 28 .protocol.json files exist but no screenshot comparison tests"}
{"category":"testing-strategy","title":"Coverage thresholds not enforced despite c8 being available","fingerprint":"testing-coverage-not-enforced","impact":"I1","effort":"E1","confidence":90,"files":["package.json:10-12"],"current_approach":"c8 coverage tool is configured (npm run test:coverage) but no minimum thresholds are set or enforced in CI","proposed_outcome":"Add c8 configuration with minimum thresholds (e.g., 60% lines, 50% branches) and enforce in CI pipeline","counter_argument":"Arbitrary coverage thresholds encourage writing low-value tests to hit numbers; current test suite focuses on critical paths which is more valuable; enforcing could slow development","why_it_matters":"Without thresholds, coverage can silently decrease as new code is added without tests","evidence":"npm run test:coverage exists but no --check-coverage flags or .c8rc configuration found"}
{"category":"testing-strategy","title":"Limited script testing - 5 test files for 60+ npm scripts","fingerprint":"testing-script-coverage-low","impact":"I2","effort":"E2","confidence":80,"files":["tests/:multiple","scripts/:multiple"],"current_approach":"Only ~5 test files cover scripts functionality despite 60+ npm scripts and 85+ script files","proposed_outcome":"Add targeted tests for high-risk scripts (pattern checker, security checker, debt intake) that run in pre-commit pipeline","counter_argument":"Scripts are validated by the pre-commit/pre-push pipeline itself; adding unit tests for scripts creates a meta-testing problem; scripts change frequently making tests a maintenance burden","why_it_matters":"Script bugs cause cascading failures in the entire development pipeline; the pattern checker and security checker are critical infrastructure","evidence":"85 files in scripts/, 60+ npm scripts, only ~5 test files covering script behavior"}
{"category":"testing-strategy","title":"No performance benchmarks for pagination and data loading","fingerprint":"testing-performance-benchmarks-missing","impact":"I1","effort":"E2","confidence":75,"files":["components/:multiple","lib/firestore-service.ts:1"],"current_approach":"Performance testing is manual only; no automated benchmarks for pagination, data loading, or render times","proposed_outcome":"Add performance benchmarks for critical paths: Firestore query times, component render times for large datasets, pagination performance","counter_argument":"Performance benchmarks are environment-dependent and flaky in CI; manual testing catches major regressions; premature optimization without data","why_it_matters":"Performance regressions are hard to detect in code review; automated benchmarks catch them before users notice","evidence":"Pagination and data loading mentioned in ROADMAP as P0 concerns but no automated performance tests exist"}
{"category":"testing-strategy","title":"Error boundary and Sentry integration not tested","fingerprint":"testing-error-boundaries-untested","impact":"I2","effort":"E1","confidence":85,"files":["components/:multiple","lib/sentry.ts:1"],"current_approach":"Error boundaries and Sentry integration exist but have no test coverage verifying they catch and report errors correctly","proposed_outcome":"Add tests that trigger errors within error boundaries and verify Sentry capture is called with correct context","counter_argument":"Error boundaries are simple React patterns that rarely break; Sentry SDK is well-tested; testing error paths is hard to do meaningfully","why_it_matters":"If error boundaries fail silently, users see white screens instead of graceful fallbacks; if Sentry breaks, errors go unreported","evidence":"Sentry integration in lib/sentry.ts, error boundaries in components, no test coverage for either"}
{"category":"testing-strategy","title":"Flaky timing in rate limiter tests using real setTimeout","fingerprint":"testing-rate-limiter-flaky-timing","impact":"I1","effort":"E1","confidence":90,"files":["tests/rate-limiter.test.ts:1"],"current_approach":"Rate limiter tests use real setTimeout with actual wall-clock delays (30ms, 72ms, 110ms waits)","proposed_outcome":"Use fake timers (node:test mock timers or sinon) to make tests deterministic and faster","counter_argument":"Real timers test actual behavior; fake timers can mask real timing bugs; current tests pass consistently; the delays are small enough","why_it_matters":"Real timer tests are inherently flaky under CI load and slow down the test suite unnecessarily","evidence":"Rate limiter test has explicit setTimeout waits: 30ms, 72ms, 110ms observed in test output"}
{"category":"testing-strategy","title":"msw installed but unused for API mocking","fingerprint":"testing-msw-unused","impact":"I1","effort":"E2","confidence":75,"files":["package.json:1","tests/:multiple"],"current_approach":"msw (Mock Service Worker) is in dependencies but not used; tests mock at the module level instead","proposed_outcome":"Use msw for API mocking in integration tests to verify actual HTTP request/response patterns","counter_argument":"Module-level mocking is simpler and sufficient for unit tests; msw adds setup complexity; the app uses Firebase SDK not REST APIs; msw may not integrate well with Firebase","why_it_matters":"msw provides more realistic API mocking that catches serialization and request format issues","evidence":"msw in package.json dependencies but no msw handlers or setup files found in tests/"}
{"type":"strength","domain":"testing","description":"Zero-dependency testing with Node.js built-in test runner - 293 passing tests across 80 suites","evidence":["Uses node --test natively","No test framework dependencies (jest, vitest, mocha)","Fast execution: ~10s for full suite"]}
{"type":"strength","domain":"testing","description":"Strong security test coverage for Cloud Functions - comprehensive tests for firestore-validation, callable-errors, secure-caller","evidence":["Dedicated security test files","Tests cover rate limiting, auth validation, input sanitization","Critical security paths well-tested"]}
{"type":"strength","domain":"testing","description":"Protocol-based UI testing with 28 .protocol.json files covering 195+ test steps","evidence":["28 protocol files in test-suite system","Structured test definitions for UI workflows","Covers journal, meetings, mood tracking, admin flows"]}
{"type":"strength","domain":"testing","description":"Solid test compilation pipeline with TypeScript strict mode and proper path aliasing","evidence":["tsconfig.test.json with strict mode","tsc-alias for path resolution in compiled tests","Separate dist-tests output directory"]}
{"category":"product-ux","title":"Missing ARIA labels on critical navigation tabs","fingerprint":"ux-missing-aria-nav-tabs","impact":"I1","effort":"E0","confidence":88,"files":["components/navigation/:multiple"],"current_approach":"Navigation tabs lack aria-label or aria-current attributes for screen reader users","proposed_outcome":"Add aria-label to tab buttons and aria-current='page' to active tab for screen reader navigation","counter_argument":"Current tab styling provides visual indication; screen reader user base may be small; existing focus styles may be sufficient","why_it_matters":"Navigation is the primary interaction pattern; missing ARIA labels make the app unusable for screen reader users","evidence":"Tab components found without aria-label attributes in navigation components"}
{"category":"product-ux","title":"Small touch targets on mobile - tabs only 8-10px padding","fingerprint":"ux-small-touch-targets","impact":"I1","effort":"E1","confidence":85,"files":["components/navigation/:multiple"],"current_approach":"Navigation tabs have minimal padding (8-10px) resulting in touch targets below the recommended 44x44px minimum","proposed_outcome":"Increase tab padding to ensure minimum 44x44px touch targets on mobile, use Tailwind responsive classes","counter_argument":"Current styling may be intentional for compact layout; increasing size could break layout on small screens; most users may not have difficulty","why_it_matters":"WCAG 2.5.8 requires minimum 44x44px touch targets; small targets cause frustration and errors on mobile","evidence":"Tab components with p-2 (8px) padding observed"}
{"category":"product-ux","title":"No focus trap management in modals and dialogs","fingerprint":"ux-modal-focus-trap-missing","impact":"I1","effort":"E2","confidence":82,"files":["components/:multiple"],"current_approach":"Modal and dialog components don't trap focus, allowing Tab key to navigate to elements behind the modal","proposed_outcome":"Add focus trap to modal components using a lightweight focus-trap library or custom implementation","counter_argument":"Adding focus trap adds complexity; most users don't tab through modals; could interfere with custom keyboard shortcuts","why_it_matters":"Focus escaping modals is a WCAG 2.4.3 violation and confusing for keyboard and screen reader users","evidence":"Modal components without focus trap implementation or aria-modal attribute"}
{"category":"product-ux","title":"Missing error state illustrations - plain text errors only","fingerprint":"ux-error-state-illustrations","impact":"I2","effort":"E2","confidence":78,"files":["components/:multiple"],"current_approach":"Error states display plain text messages without visual indication (icons, illustrations, or color coding)","proposed_outcome":"Add error illustration components with clear visual hierarchy: icon + message + action button","counter_argument":"Plain text errors are clear and accessible; illustrations add bundle size; recovery domain may benefit from minimal, calm error states","why_it_matters":"Visual error states are more noticeable and help users understand what went wrong faster","evidence":"Error handling in components uses plain text without icons or illustrations"}
{"category":"product-ux","title":"Missing loading skeletons on data-heavy pages","fingerprint":"ux-loading-skeletons-inconsistent","impact":"I2","effort":"E2","confidence":80,"files":["app/:multiple"],"current_approach":"Some pages use skeleton loading screens while others show spinners or plain Loading... text","proposed_outcome":"Standardize on skeleton loading for all data-heavy pages (journal, meetings, admin) to match existing skeleton infrastructure","counter_argument":"Skeleton screens are more complex to build and maintain; spinners are universally understood; loading times may be short enough that skeletons flash","why_it_matters":"Consistent loading patterns reduce perceived wait time and create a more polished experience","evidence":"Mix of skeleton, spinner, and text loading states across app pages"}
{"category":"product-ux","title":"No optimistic updates for form submissions","fingerprint":"ux-optimistic-updates-missing","impact":"I2","effort":"E2","confidence":75,"files":["components/journal/:multiple","components/meetings/:multiple"],"current_approach":"Form submissions show loading state and wait for server response before updating UI","proposed_outcome":"Implement optimistic updates for common actions (journal entry save, mood logging) with rollback on error","counter_argument":"Optimistic updates add complexity and can show incorrect state if the server rejects; recovery domain may benefit from confirmation that data was truly saved","why_it_matters":"Optimistic updates make the app feel instant and responsive, improving perceived performance","evidence":"Form components use loading state and await server response before UI update"}
{"category":"product-ux","title":"Missing keyboard shortcuts for power users","fingerprint":"ux-keyboard-shortcuts-missing","impact":"I3","effort":"E2","confidence":72,"files":["app/:multiple"],"current_approach":"No keyboard shortcuts for common actions like creating journal entries or navigating between sections","proposed_outcome":"Add keyboard shortcuts for top 5 actions: new journal entry (Ctrl+N), save (Ctrl+S), navigate tabs (Ctrl+1-5)","counter_argument":"Keyboard shortcuts add complexity and can conflict with browser/OS shortcuts; discovery is poor; few users use them; mobile users can't benefit","why_it_matters":"Power users who journal daily benefit significantly from keyboard shortcuts for repetitive actions","evidence":"No keyboard event handlers or shortcut system found in app code"}
{"category":"product-ux","title":"Form validation shows errors only on submit, not inline","fingerprint":"ux-inline-validation-missing","impact":"I2","effort":"E2","confidence":78,"files":["components/journal/:multiple","components/meetings/:multiple"],"current_approach":"Form validation errors appear only after submission attempt, not as the user types","proposed_outcome":"Add inline validation for required fields and format constraints using Zod schemas already defined","counter_argument":"Inline validation can be annoying if too aggressive; on-submit validation is simpler; Zod schemas are for server-side validation","why_it_matters":"Inline validation prevents form submission failures and helps users correct mistakes in real-time","evidence":"Form components use Zod validation on submit but don't show field-level errors during input"}
{"type":"strength","domain":"ux","description":"Comprehensive skeleton loading states already implemented in several key components","evidence":["Skeleton components found in loading.tsx files","Infrastructure exists for consistent loading patterns"]}
{"type":"strength","domain":"ux","description":"WCAG-compliant viewport settings that allow zoom - good mobile accessibility baseline","evidence":["Viewport meta tag allows user scaling","No maximum-scale restriction found"]}
{"type":"strength","domain":"ux","description":"Good use of sonner toast notifications for user feedback on actions","evidence":["Toast notifications for save, delete, error actions","Consistent feedback pattern across the app"]}
{"category":"workflow-lifecycle","title":"Session-start timeout risks in low-bandwidth environments","fingerprint":"workflow-session-start-timeout","impact":"I2","effort":"E1","confidence":78,"files":[".claude/hooks/session-start.js:1"],"current_approach":"Session-start hook runs multiple npm commands and checks synchronously without timeout guards","proposed_outcome":"Add per-step timeouts (e.g., 10s for dependency checks, 30s for builds) with graceful fallback on timeout","counter_argument":"Session-start works reliably in practice; adding timeout logic adds complexity; failures are already handled with try/catch","why_it_matters":"In slow network environments, npm commands can hang indefinitely, blocking the entire session start","evidence":"Session-start hook runs npm install, tsc builds, and multiple checks without timeout guards"}
{"category":"workflow-lifecycle","title":"Duplicate hook validation for Write+Edit+MultiEdit tools","fingerprint":"workflow-duplicate-hook-validation","impact":"I1","effort":"E2","confidence":82,"files":[".claude/hooks/:multiple"],"current_approach":"Some PostToolUse hooks run the same validation for Write, Edit, and MultiEdit events, tripling execution","proposed_outcome":"Consolidate into single handler that triggers on any file-modifying tool, deduplicating per-file checks","counter_argument":"Each tool type may need different validation logic; consolidation could miss tool-specific edge cases; current duplication is simple and reliable","why_it_matters":"Reduces hook execution time and prevents inconsistent behavior if one tool's handler is updated but others aren't","evidence":"Multiple hooks registered for Write, Edit, and MultiEdit with similar validation logic"}
{"category":"workflow-lifecycle","title":"Firebase deployment lacks rollback on partial failure","fingerprint":"workflow-firebase-deploy-no-rollback","impact":"I2","effort":"E2","confidence":75,"files":["firebase.json:1"],"current_approach":"Firebase deploy pushes hosting + functions together; if functions fail after hosting succeeds, app is in inconsistent state","proposed_outcome":"Deploy functions first (validate), then hosting. Add rollback script that reverts to previous version on failure","counter_argument":"Firebase hosting is versioned and supports instant rollback via console; partial failures are rare; adding rollback automation adds significant complexity","why_it_matters":"Inconsistent deployment state can cause runtime errors when frontend expects API endpoints that haven't deployed","evidence":"firebase.json configures both hosting and functions targets deployed together"}
{"category":"workflow-lifecycle","title":"CI runs full build twice - once for lint, once for test","fingerprint":"workflow-ci-duplicate-build","impact":"I1","effort":"E2","confidence":80,"files":[".github/workflows/ci.yml:1"],"current_approach":"CI pipeline builds the project for linting and then rebuilds for testing, duplicating the compilation step","proposed_outcome":"Build once, share artifacts between lint and test jobs using GitHub Actions cache or artifact upload","counter_argument":"Separate builds ensure isolation; shared artifacts add complexity; CI time may already be acceptable","why_it_matters":"Reduces CI pipeline duration by eliminating redundant compilation, faster PR feedback","evidence":"CI workflow has separate build steps for lint and test stages"}
{"category":"external-services","title":"SonarCloud not enforced in CI gates","fingerprint":"workflow-sonarcloud-not-enforced","impact":"I2","effort":"E1","confidence":85,"files":[".github/workflows/ci.yml:1"],"current_approach":"SonarCloud analysis runs in CI but results are not used as a gate - PRs can merge even with new issues","proposed_outcome":"Add SonarCloud quality gate check as required status check for PR merge","counter_argument":"SonarCloud quality gates can be overly strict and block PRs for minor issues; team may prefer advisory mode; gate thresholds need tuning first","why_it_matters":"Without enforcement, SonarCloud findings accumulate without accountability, reducing the tool's value","evidence":"SonarCloud integration exists but not configured as blocking CI check"}
{"category":"external-services","title":"Sentry disabled in dev mode by default","fingerprint":"workflow-sentry-disabled-dev","impact":"I1","effort":"E1","confidence":76,"files":["lib/sentry.ts:1"],"current_approach":"Sentry error tracking only active in production, dev errors go to console only","proposed_outcome":"Enable Sentry in dev mode with reduced sampling rate and dev-specific project/environment tag","counter_argument":"Dev errors are noisy and would pollute Sentry dashboard; console is sufficient for local debugging; adds API calls during development","why_it_matters":"Some errors only reproduce in specific conditions; having dev errors in Sentry helps identify patterns before they reach production","evidence":"Sentry initialization checks for production environment before enabling"}
{"category":"workflow-lifecycle","title":"Hook performance not tracked - no metrics on execution time","fingerprint":"workflow-hook-performance-untracked","impact":"I2","effort":"E2","confidence":72,"files":[".claude/hooks/:multiple"],"current_approach":"Hooks execute without performance tracking; no visibility into which hooks are slow or how total hook time trends","proposed_outcome":"Add lightweight timing wrapper that logs hook execution times to .claude/state/hook-metrics.jsonl for analysis","counter_argument":"Adding timing to every hook adds overhead; the data may not be actionable; hooks are already fast enough; more infrastructure to maintain","why_it_matters":"Without metrics, slow hooks accumulate unnoticed, gradually degrading developer experience","evidence":"20+ hooks in .claude/hooks/ with no execution time tracking"}
{"category":"external-services","title":"Firebase emulator not used in CI for integration tests","fingerprint":"workflow-firebase-emulator-ci","impact":"I2","effort":"E2","confidence":74,"files":[".github/workflows/ci.yml:1","firebase.json:1"],"current_approach":"CI tests mock Firebase entirely; no integration tests run against Firebase emulator","proposed_outcome":"Add Firebase emulator to CI pipeline for integration tests that verify actual Firestore queries and Cloud Functions","counter_argument":"Firebase emulator adds significant CI setup time (2-3 min); mocks are sufficient for unit tests; emulator can be flaky in CI; current test strategy works","why_it_matters":"Mock-only testing misses real Firestore query behavior, security rules enforcement, and Cloud Function integration issues","evidence":"Tests use mocked httpsCallable, no emulator configuration in CI workflow"}
{"category":"workflow-lifecycle","title":"Pre-push duplicates pre-commit pattern checks","fingerprint":"workflow-prepush-duplicate-patterns","impact":"I1","effort":"E0","confidence":88,"files":[".husky/pre-push:1",".husky/pre-commit:1"],"current_approach":"Pattern compliance check runs in both pre-commit (blocking) and pre-push (blocking), duplicating 1-2s of work","proposed_outcome":"Remove pattern check from pre-push; rely on pre-commit for pattern enforcement since it already blocks commits","counter_argument":"Pre-push is a safety net for --no-verify commits; defense in depth is valuable; 1-2s is negligible","why_it_matters":"Saves time per push and prevents graduated enforcement self-escalation (warned in pre-commit, blocked in pre-push)","evidence":"Both .husky/pre-commit and .husky/pre-push run npm run patterns:check"}
{"category":"workflow-lifecycle","title":"Session-start consolidation check blocks synchronously","fingerprint":"workflow-session-start-sync-consolidation","impact":"I2","effort":"E1","confidence":75,"files":[".claude/hooks/session-start.js:1"],"current_approach":"Auto-consolidation check runs synchronously during session-start, adding latency to every session","proposed_outcome":"Run consolidation check asynchronously or defer to first idle moment after session starts","counter_argument":"Consolidation check is fast (<1s usually); async execution could miss showing results to user; synchronous is simpler and more reliable","why_it_matters":"Every second added to session-start creates friction and delays the user from starting productive work","evidence":"Session-start hook runs consolidation check synchronously before yielding control"}
{"type":"strength","domain":"workflow","description":"Compaction-resilient state persistence with 4-layer approach (commit-tracker, compaction-handoff, pre-compaction-save, compact-restore)","evidence":["4 independent layers ensure no state loss across compaction","commit-log.jsonl as single source of truth","Successfully recovered from crashes in production use"]}
{"type":"strength","domain":"workflow","description":"Intelligent session-start hook with hash-based dependency caching skips unchanged installs","evidence":["Compares lockfile hash to skip npm install","Skips Firebase build if unchanged","Saves 30-60s per session when deps haven't changed"]}
{"type":"strength","domain":"workflow","description":"Well-structured pre-commit chain with granular escape hatches via environment variables","evidence":["SKIP_CROSS_DOC_CHECK, SKIP_AUDIT_VALIDATION, SKIP_TRIGGERS available","Each check independently skippable","Clear error messages with remediation guidance"]}
{"type":"strength","domain":"workflow","description":"Efficient GitHub Actions CI with proper job structure and artifact handling","evidence":["Separate lint, test, and deploy jobs","Proper dependency caching for node_modules","Status checks integrated with PR workflow"]}
