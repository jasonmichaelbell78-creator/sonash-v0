{"category":"testing-strategy","title":"Missing Cloud Functions integration tests - only 1 skipped test exists","fingerprint":"testing-cf-integration-missing","impact":"I2","effort":"E2","confidence":85,"files":["tests/:multiple","functions/src/:multiple"],"current_approach":"Cloud Functions are tested only via mocked httpsCallable; only 1 skipped integration test exists","proposed_outcome":"Add integration tests using Firebase emulator that verify actual Cloud Function behavior, security rules enforcement, and Firestore triggers","counter_argument":"Mock-based tests are faster and more reliable in CI; emulator setup adds complexity; current mocks cover the API contract; integration tests are expensive to maintain","why_it_matters":"Mock-only testing misses real Firestore query behavior, security rules, rate limiting, and function-to-function interactions","evidence":"1 skipped integration test found; all other Cloud Function tests use mocked httpsCallable"}
{"category":"testing-strategy","title":"No visual regression testing despite Playwright being installed","fingerprint":"testing-visual-regression-missing","impact":"I2","effort":"E3","confidence":75,"files":["package.json:1",".claude/skills/test-suite/SKILL.md:1"],"current_approach":"Playwright is installed and used for protocol-based UI testing but not for visual regression (screenshot comparison)","proposed_outcome":"Add visual regression tests for key UI states (dashboard, journal entry, mood selector) using Playwright screenshot comparison","counter_argument":"Visual regression tests are brittle, require baseline maintenance, and break on intentional design changes; protocol tests already verify UI behavior; overhead may not be worth it for a small team","why_it_matters":"Catches unintended CSS/layout regressions that functional tests miss; especially important with Tailwind utility classes that can have subtle side effects","evidence":"Playwright in dependencies; 28 .protocol.json files exist but no screenshot comparison tests"}
{"category":"testing-strategy","title":"Coverage thresholds not enforced despite c8 being available","fingerprint":"testing-coverage-not-enforced","impact":"I1","effort":"E1","confidence":90,"files":["package.json:10-12"],"current_approach":"c8 coverage tool is configured (npm run test:coverage) but no minimum thresholds are set or enforced in CI","proposed_outcome":"Add c8 configuration with minimum thresholds (e.g., 60% lines, 50% branches) and enforce in CI pipeline","counter_argument":"Arbitrary coverage thresholds encourage writing low-value tests to hit numbers; current test suite focuses on critical paths which is more valuable; enforcing could slow development","why_it_matters":"Without thresholds, coverage can silently decrease as new code is added without tests","evidence":"npm run test:coverage exists but no --check-coverage flags or .c8rc configuration found"}
{"category":"testing-strategy","title":"Limited script testing - 5 test files for 60+ npm scripts","fingerprint":"testing-script-coverage-low","impact":"I2","effort":"E2","confidence":80,"files":["tests/:multiple","scripts/:multiple"],"current_approach":"Only ~5 test files cover scripts functionality despite 60+ npm scripts and 85+ script files","proposed_outcome":"Add targeted tests for high-risk scripts (pattern checker, security checker, debt intake) that run in pre-commit pipeline","counter_argument":"Scripts are validated by the pre-commit/pre-push pipeline itself; adding unit tests for scripts creates a meta-testing problem; scripts change frequently making tests a maintenance burden","why_it_matters":"Script bugs cause cascading failures in the entire development pipeline; the pattern checker and security checker are critical infrastructure","evidence":"85 files in scripts/, 60+ npm scripts, only ~5 test files covering script behavior"}
{"category":"testing-strategy","title":"No performance benchmarks for pagination and data loading","fingerprint":"testing-performance-benchmarks-missing","impact":"I1","effort":"E2","confidence":75,"files":["components/:multiple","lib/firestore-service.ts:1"],"current_approach":"Performance testing is manual only; no automated benchmarks for pagination, data loading, or render times","proposed_outcome":"Add performance benchmarks for critical paths: Firestore query times, component render times for large datasets, pagination performance","counter_argument":"Performance benchmarks are environment-dependent and flaky in CI; manual testing catches major regressions; premature optimization without data","why_it_matters":"Performance regressions are hard to detect in code review; automated benchmarks catch them before users notice","evidence":"Pagination and data loading mentioned in ROADMAP as P0 concerns but no automated performance tests exist"}
{"category":"testing-strategy","title":"Error boundary and Sentry integration not tested","fingerprint":"testing-error-boundaries-untested","impact":"I2","effort":"E1","confidence":85,"files":["components/:multiple","lib/sentry.ts:1"],"current_approach":"Error boundaries and Sentry integration exist but have no test coverage verifying they catch and report errors correctly","proposed_outcome":"Add tests that trigger errors within error boundaries and verify Sentry capture is called with correct context","counter_argument":"Error boundaries are simple React patterns that rarely break; Sentry SDK is well-tested; testing error paths is hard to do meaningfully","why_it_matters":"If error boundaries fail silently, users see white screens instead of graceful fallbacks; if Sentry breaks, errors go unreported","evidence":"Sentry integration in lib/sentry.ts, error boundaries in components, no test coverage for either"}
{"category":"testing-strategy","title":"Flaky timing in rate limiter tests using real setTimeout","fingerprint":"testing-rate-limiter-flaky-timing","impact":"I1","effort":"E1","confidence":90,"files":["tests/rate-limiter.test.ts:1"],"current_approach":"Rate limiter tests use real setTimeout with actual wall-clock delays (30ms, 72ms, 110ms waits)","proposed_outcome":"Use fake timers (node:test mock timers or sinon) to make tests deterministic and faster","counter_argument":"Real timers test actual behavior; fake timers can mask real timing bugs; current tests pass consistently; the delays are small enough","why_it_matters":"Real timer tests are inherently flaky under CI load and slow down the test suite unnecessarily","evidence":"Rate limiter test has explicit setTimeout waits: 30ms, 72ms, 110ms observed in test output"}
{"category":"testing-strategy","title":"msw installed but unused for API mocking","fingerprint":"testing-msw-unused","impact":"I1","effort":"E2","confidence":75,"files":["package.json:1","tests/:multiple"],"current_approach":"msw (Mock Service Worker) is in dependencies but not used; tests mock at the module level instead","proposed_outcome":"Use msw for API mocking in integration tests to verify actual HTTP request/response patterns","counter_argument":"Module-level mocking is simpler and sufficient for unit tests; msw adds setup complexity; the app uses Firebase SDK not REST APIs; msw may not integrate well with Firebase","why_it_matters":"msw provides more realistic API mocking that catches serialization and request format issues","evidence":"msw in package.json dependencies but no msw handlers or setup files found in tests/"}
{"type":"strength","domain":"testing","description":"Zero-dependency testing with Node.js built-in test runner - 293 passing tests across 80 suites","evidence":["Uses node --test natively","No test framework dependencies (jest, vitest, mocha)","Fast execution: ~10s for full suite"]}
{"type":"strength","domain":"testing","description":"Strong security test coverage for Cloud Functions - comprehensive tests for firestore-validation, callable-errors, secure-caller","evidence":["Dedicated security test files","Tests cover rate limiting, auth validation, input sanitization","Critical security paths well-tested"]}
{"type":"strength","domain":"testing","description":"Protocol-based UI testing with 28 .protocol.json files covering 195+ test steps","evidence":["28 protocol files in test-suite system","Structured test definitions for UI workflows","Covers journal, meetings, mood tracking, admin flows"]}
{"type":"strength","domain":"testing","description":"Solid test compilation pipeline with TypeScript strict mode and proper path aliasing","evidence":["tsconfig.test.json with strict mode","tsc-alias for path resolution in compiled tests","Separate dist-tests output directory"]}
