{"category":"app-architecture","title":"Consolidate duplicate mood selector components - 3 implementations with diverging mood options","fingerprint":"arch-mood-selector-consolidation","impact":"I1","effort":"E1","confidence":85,"files":["components/mood-selector.tsx:1","components/daily-log/mood-selector.tsx:1"],"current_approach":"3 separate mood selector implementations exist with different emoji sets and mood option arrays. Each has diverged over time","proposed_outcome":"Single configurable MoodSelector component with props for mood options, allowing each usage to specify its variant while sharing core selection logic","counter_argument":"Each selector may serve a different UX context with intentionally different mood options. Consolidation could create an overly complex component that is harder to maintain than 3 simple ones","why_it_matters":"Duplicate components diverge over time, creating inconsistent user experience and tripling the maintenance burden for mood-related features","evidence":"3 mood selector implementations found with different emoji sets across components/"}
{"category":"app-architecture","title":"Extract meeting time parsing logic - ~80 lines duplicated between 2 files","fingerprint":"arch-meeting-time-parsing-dedup","impact":"I1","effort":"E1","confidence":88,"files":["components/meetings/meeting-form.tsx:1","components/meetings/meeting-list.tsx:1"],"current_approach":"Meeting time parsing logic (~80 lines) is duplicated between meeting-form.tsx and meeting-list.tsx with slightly different implementations","proposed_outcome":"Extract into a shared parseMeetingTime utility in lib/ or hooks/, used by both components","counter_argument":"The duplication is small (~80 lines) and each version may have context-specific edge cases. Extracting could create coupling between unrelated components","why_it_matters":"Duplicated parsing logic is a bug magnet - fixes applied to one copy but not the other create subtle inconsistencies","evidence":"~80 lines of time parsing duplicated between 2 meeting component files"}
{"category":"app-architecture","title":"Migrate useAuth consumers to focused hooks - 16 components still using deprecated hook","fingerprint":"arch-useauth-migration","impact":"I1","effort":"E2","confidence":82,"files":["hooks/useAuth.ts:1"],"current_approach":"16 components still use the deprecated useAuth() hook which returns the full auth context, while 2 focused hooks (useUser, useTodayLog) exist but are underutilized","proposed_outcome":"Migrate all 16 components to use focused hooks (useUser for stable user data, useTodayLog for volatile daily data), reducing unnecessary re-renders","counter_argument":"The migration requires touching 16 files with potential for regressions. The deprecated hook still works correctly, just triggers extra re-renders. The performance impact may be negligible","why_it_matters":"Focused hooks prevent unnecessary re-renders when only user or only todayLog changes, improving perceived performance especially on mobile","evidence":"16 components import useAuth vs 2 using focused hooks. Auth context is split into AuthProvider (stable) and TodayLogProvider (volatile)"}
{"category":"app-architecture","title":"Extract common form state logic - ~150 lines of duplicate submission handling","fingerprint":"arch-form-state-extraction","impact":"I2","effort":"E2","confidence":78,"files":["components/journal/journal-entry-form.tsx:1","components/meetings/meeting-form.tsx:1","components/daily-log/daily-log-form.tsx:1"],"current_approach":"Multiple form components duplicate submission handling logic (~150 lines): loading state, error state, validation, toast notifications, and optimistic updates","proposed_outcome":"Create a useFormSubmission hook encapsulating common patterns: loading/error state, validation, toast feedback, and retry logic","counter_argument":"Each form has unique validation and submission logic. A generic hook could become overly abstract and harder to debug than straightforward per-form code","why_it_matters":"Reduces boilerplate in form components and ensures consistent error handling and user feedback patterns","evidence":"~150 lines of similar submission handling found across 3+ form components"}
{"category":"app-architecture","title":"Create barrel exports for component directories - only 1 exists","fingerprint":"arch-barrel-exports","impact":"I1","effort":"E1","confidence":75,"files":["components/features/index.ts:1"],"current_approach":"Only 1 barrel export file exists (features/index.ts). Other directories use direct file imports creating long import paths","proposed_outcome":"Add index.ts barrel exports to major component directories (components/journal/, components/meetings/, components/daily-log/) for cleaner imports","counter_argument":"Barrel exports can cause larger bundle sizes if tree-shaking is not configured properly. They also create circular dependency risks and can slow down IDE auto-imports","why_it_matters":"Cleaner imports improve code readability and make refactoring easier since internal file moves don't break external imports","evidence":"Only 1 barrel export found. 38 default exports vs 69 named exports showing no consistent convention"}
{"category":"app-architecture","title":"Collocate related quote components - 3 variants scattered across 2 directories","fingerprint":"arch-quote-collocation","impact":"I2","effort":"E3","confidence":72,"files":["components/quotes/:1","components/daily-log/:1"],"current_approach":"3 quote component variants are scattered across 2 different directories (components/quotes/ and components/daily-log/)","proposed_outcome":"Collocate all quote-related components in a single components/quotes/ directory with clear naming for each variant","counter_argument":"Components may be intentionally placed near their primary consumers. Moving them could break the intuitive colocation-by-usage pattern","why_it_matters":"Scattered related components make it harder to understand the full quote feature surface area and increase risk of unintentional divergence","evidence":"3 quote variants found across 2 directories"}
{"category":"app-architecture","title":"Standardize export style - 38 default vs 69 named exports with no convention","fingerprint":"arch-export-style-standardize","impact":"I0","effort":"E1","confidence":70,"files":["components/:multiple"],"current_approach":"Mixed export styles: 38 default exports and 69 named exports in component files with no documented convention","proposed_outcome":"Adopt named exports as the standard (better refactoring support, explicit imports) and add ESLint rule to enforce","counter_argument":"This is largely a stylistic preference with minimal functional impact. The refactor touches many files for cosmetic benefit and could conflict with Next.js page conventions","why_it_matters":"Consistent exports improve IDE support (auto-imports work better with named exports) and prevent the common default-export renaming issue","evidence":"38 default exports vs 69 named exports found across components/"}
{"category":"app-architecture","title":"Inconsistent loading states - spinners vs text vs skeletons across components","fingerprint":"arch-loading-states-consistency","impact":"I2","effort":"E2","confidence":76,"files":["components/:multiple"],"current_approach":"Loading states are inconsistent: some components use skeleton screens, others use spinner icons, and some show plain Loading... text","proposed_outcome":"Standardize on skeleton loading states (already have infrastructure) with a shared LoadingSkeleton component library for common patterns","counter_argument":"Different loading patterns may be intentional for different contexts (brief loads vs long loads vs initial page loads). Forcing uniformity could worsen UX in some cases","why_it_matters":"Consistent loading patterns create a more polished, professional feel and reduce perceived load times when users know what to expect","evidence":"Mix of skeleton, spinner, and text loading states found across components"}
{"category":"app-architecture","title":"useDailyQuote hook has smart module-level caching preventing duplicate fetches","fingerprint":"arch-daily-quote-caching","impact":"I3","effort":"E0","confidence":90,"files":["hooks/useDailyQuote.ts:1"],"current_approach":"useDailyQuote uses module-level caching to prevent duplicate fetches across 3 component variants that all need the daily quote","proposed_outcome":"No change needed - this is a strength. Consider documenting this pattern for reuse in other hooks","counter_argument":"N/A - strength finding","why_it_matters":"Prevents unnecessary API calls and ensures consistent data across components","evidence":"Module-level cache variable in useDailyQuote.ts shared across 3 consumers"}
{"type":"strength","domain":"architecture","description":"Split auth contexts separating stable (user) from volatile (todayLog) state - excellent performance optimization","evidence":["AuthProvider for stable user data","TodayLogProvider for volatile daily data","425 total lines across 4 well-organized auth context files"]}
{"type":"strength","domain":"architecture","description":"Consolidated useDailyQuote hook with module-level caching prevents duplicate fetches across 3 variants","evidence":["Module-level cache in useDailyQuote.ts","3 quote component variants share single fetch"]}
{"type":"strength","domain":"architecture","description":"Clean repository pattern in firestore-service.ts with security validation and rate limiting","evidence":["firestore-service.ts with structured data access","Rate limiting integration","Security validation on queries"]}
{"type":"strength","domain":"architecture","description":"AdminTabContext with smart 30-second refresh throttling prevents excessive API calls","evidence":["30-second throttle on admin tab refresh","Prevents API hammering during rapid tab switches"]}
