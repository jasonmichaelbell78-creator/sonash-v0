{"canonical_id":"CANON-0001","severity":"S1","title":"Regex Pattern State Leak in sanitize-error.js","category":"OWASP-A05","file":"scripts/lib/sanitize-error.js","line":89,"description":"In the sanitizeError function, regex patterns with the /g flag are reused in a loop without proper state reset. While lastIndex IS reset on line 90, there is a critical issue: if any pattern match fails or the loop is interrupted, subsequent patterns in the iteration may see an invalid lastIndex state.","cwe":["CWE-1321"],"owasp_top_10":["A05:2021-Broken Access Control"],"risk":"An attacker providing crafted error messages with specific Unicode patterns could cause pattern state corruption, leading to failed sanitization of subsequent error messages, exposing sensitive paths in logs.","affected_input":"error parameter with specific pattern sequences","impact":"Information disclosure through error message leakage","proof_of_concept":"Error with multiple paths: 'Error at /home/user/project: /etc/passwd access denied' - the regex lastIndex reset may not properly reset between patterns if patterns have state modifications.","pattern_reference":"CODE_PATTERNS.md #44 - Regex state leak reset lastIndex before each iteration","remediation":"The current implementation correctly resets lastIndex on line 90 before each pattern.replace(). STATUS: RESOLVED - No finding.","status":"RESOLVED","confidence":"HIGH"}
{"canonical_id":"CANON-0002","severity":"S2","title":"Overly Broad Error Sanitization in security-helpers.js","category":"General","file":"scripts/lib/security-helpers.js","line":"26-31","description":"The sanitizeError function uses aggressive regex replacements that match file paths using /g flag with patterns like /\\/g and /^[^\\s]*\/[^\\s]+/g. These patterns are not properly anchored and may match legitimate error content that should be preserved.","cwe":["CWE-176"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Overly sanitized error messages may make debugging difficult and hide important error context. The pattern /\\/[^\\s]*\\/[^\\s]+/g is too broad and may match URLs, regular expressions in error messages, or other content.","affected_input":"Any error message containing Unix paths or forward slashes","impact":"Reduced debugging capability, information loss in error logging","proof_of_concept":"Error message: 'Failed to parse file:/etc/config.json at /home/user' becomes 'Failed to parse [PATH] at [PATH]' - losing the file:// URL context that might be important.","pattern_reference":"CODE_PATTERNS.md #34 - Relative path logging should be targeted, not overly broad","remediation":"Review sanitization patterns to be more targeted. Current patterns in line 26-31 are too broad. Recommend using more specific patterns that target only known sensitive paths (/home/, /Users/, C:\\\\Users\\\\) rather than general Unix path matching.","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0003","severity":"S1","title":"Missing NUL Byte Validation in security-helpers.js validatePathInDir","category":"CWE-158","file":"scripts/lib/security-helpers.js","line":"104-118","description":"The validatePathInDir function does not validate for NUL bytes (\\x00) before path operations. NUL bytes can cause path resolution to be silently truncated in some contexts, leading to path traversal vulnerabilities.","cwe":["CWE-158","CWE-22"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"A path like 'valid/path\\x00../../../etc/passwd' may be partially validated and then truncated, allowing traversal outside the base directory.","affected_input":"userPath parameter with embedded NUL bytes","impact":"Path traversal leading to unauthorized file access","proof_of_concept":"validatePathInDir('/project', 'docs\\x00../../../etc/passwd') may pass validation and then path.resolve() would operate on 'docs' after truncation.","pattern_reference":"CODE_PATTERNS.md #108 - Security: Reject NUL bytes","remediation":"Add NUL byte check: if (userPath.includes('\\x00')) { throw new Error(...); } before path resolution.","status":"OPEN","confidence":"HIGH"}
{"canonical_id":"CANON-0004","severity":"S2","title":"Insufficient CLI Argument Validation in security-helpers.js parseCliArgs","category":"CWE-89","file":"scripts/lib/security-helpers.js","line":"287-292","description":"In parseCliArgs, the number parsing uses parseInt(next, 10) without proper radix parameter consistency. More critically, there is no validation that the parsed number is finite or checking for Infinity/NaN results before range validation.","cwe":["CWE-89","CWE-1025"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Inputs like 'Infinity', 'NaN', or very large numbers could bypass range validation. Example: parseInt('1e10', 10) returns 1, but 'Infinity' returns NaN which would fail the isNaN check correctly, but 'null' or undefined in parseInt edge cases.","affected_input":"--count argument with special numeric strings","impact":"Potential for argument validation bypass","proof_of_concept":"parseCliArgs(['--count', '1e10']) with min:1 max:100 - parseInt('1e10', 10) returns 1 (correct), but needs Number.isFinite() check.","pattern_reference":"CODE_PATTERNS.md #332 - Number.parseInt radix parameter","remediation":"Change to: if (!Number.isFinite(num)) { errors.push(...); continue; } after parseInt.","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0005","severity":"S1","title":"Path Traversal in validate-paths.js validateFilePath - Insufficient Control Character Filtering","category":"CWE-22","file":"scripts/lib/validate-paths.js","line":"88","description":"The control character validation excludes tab (0x09), newline (0x0A), and carriage return (0x0D) per comment on line 86. However, this creates a gap: newline characters can be used in path traversal when combined with specific filesystem behaviors. The validation does check for \\n and \\r on lines 100-104, which is good, but the comment is misleading about what's being checked.","cwe":["CWE-22","CWE-158"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Low - the subsequent explicit check for \\n and \\r on line 100 catches this. However, the code is confusing and could be misinterpreted by future maintainers.","affected_input":"filePath with newline characters","impact":"Code clarity issue, not a direct vulnerability due to explicit newline checks","proof_of_concept":"Path like 'file.txt\\nmalicious' is correctly rejected by lines 100-104.","pattern_reference":"CODE_PATTERNS.md #98 - Multiline path rejection","remediation":"Simplify by removing the misleading comment on line 86 and consolidating control character rejection into a single clear block.","status":"OPEN","confidence":"LOW"}
{"canonical_id":"CANON-0006","severity":"S2","title":"TOCTOU Race Condition in validate-paths.js verifyContainment","category":"CWE-367","file":"scripts/lib/validate-paths.js","line":"160-162","description":"The verifyContainment function calls fs.realpathSync() on both fullPath and projectDir separately. Between these two calls, symlinks or permissions could change, causing a TOCTOU (Time-of-check-time-of-use) race condition where the first path is validated as contained, but the second realpath call results in a different base directory.","cwe":["CWE-367"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"In scenarios with rapidly changing symlinks or permissions, the containment check could be bypassed.","affected_input":"File paths in directories with changing symlink structure","impact":"Path traversal via race condition","proof_of_concept":"Attacker modifies symlinks between realpathSync(fullPath) on line 161 and realpathSync(projectDir) on line 162, causing projectDir to resolve to a different location.","pattern_reference":"CODE_PATTERNS.md #22 - Fail-closed realpath and #367 TOCTOU races","remediation":"Resolve projectDir once at function entry and cache it. Document that projectDir must be stable during the call. Alternative: use stat() to detect changes, or accept the TOCTOU window as acceptable for hook/CI operations (document this decision).","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0007","severity":"S2","title":"Information Disclosure in sanitizeFilesystemError - Incomplete Path Sanitization","category":"CWE-532","file":"scripts/lib/validate-paths.js","line":"22-46","description":"The sanitizeFilesystemError function attempts to redact system paths but has incomplete coverage. Notably, paths containing dots in directory names (e.g., /home/user.old/project) may not be properly redacted if the user name contains special characters. The regex /C:\\\\Users\\\\[^\\n\\r]+/g will match, but the subsequent general patterns may re-expose parts.","cwe":["CWE-532"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Sensitive filesystem paths may still appear in logs.","affected_input":"Error messages with user home directories containing dots or special chars","impact":"Information disclosure of directory structure","proof_of_concept":"Path: 'C:\\\\Users\\\\first.last' is sanitized to '[HOME]', but complex nested paths might leave partial information.","pattern_reference":"CODE_PATTERNS.md #321 - Windows path sanitize with gi flag","remediation":"Add gi flags to Windows path patterns for case-insensitive matching. Verify all sensitive base directories are covered (add /var/lib, /srv, /opt patterns).","status":"OPEN","confidence":"LOW"}
{"canonical_id":"CANON-0008","severity":"S1","title":"Command Injection in safeGitAdd - Arguments Array Properly Used but No Deep Validation","category":"CWE-78","file":"scripts/lib/security-helpers.js","line":"171-182","description":"While safeGitAdd correctly uses execFileSync with argument arrays (preventing shell interpolation on line 181), it does not validate the git binary path or verify that git is actually being executed. An attacker who can modify PATH could cause a different 'git' executable to be invoked.","cwe":["CWE-78"],"owasp_top_10":["A03:2021-Injection"],"risk":"Low-medium if PATH can be controlled by unprivileged users in the hook execution environment.","affected_input":"repoRoot parameter and system PATH","impact":"Arbitrary code execution as the hook user if PATH is controlled","proof_of_concept":"If a hook runs with an attacker-controlled environment where /tmp/git is a malicious script, and /tmp is in PATH before /usr/bin, the fake git would be invoked.","pattern_reference":"CODE_PATTERNS.md #244 - execFileSync should use full path for untrusted systems","remediation":"Consider using the full path to git (e.g., '/usr/bin/git' on Unix, 'C:\\\\Program Files\\\\Git\\\\bin\\\\git.exe' on Windows) or document that this function expects PATH to be clean. Alternatively, use 'where.cmd git' on Windows or 'which git' on Unix to resolve the git binary path.","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0009","severity":"S3","title":"Magic String in safeGitCommit - Hardcoded PID/Timestamp Format","category":"General","file":"scripts/lib/security-helpers.js","line":"193","description":"The temporary filename construction uses process.pid and Date.now() but does not validate the temp directory is actually writable or that collisions are impossible. On systems with PID reuse and high concurrency, multiple processes could generate identical filenames simultaneously.","cwe":[],"owasp_top_10":[],"risk":"Low - the wx flag will catch collisions with EEXIST error, but the error handling could be clearer.","affected_input":"Concurrent invocations of safeGitCommit","impact":"Possible temporary file collision leading to commit failure (not data loss due to wx flag)","proof_of_concept":"Two processes with the same PID after wraparound + same Date.now() millisecond precision collision (extremely unlikely but theoretically possible).","pattern_reference":"General - Temporary file naming collision avoidance","remediation":"Use crypto.randomUUID() in the filename: `COMMIT_MSG_${crypto.randomUUID()}.txt` for guaranteed uniqueness.","status":"OPEN","confidence":"LOW"}
{"canonical_id":"CANON-0010","severity":"S2","title":"Regex DoS (ReDoS) Potential in maskEmail - Unbounded Domain Splitting","category":"CWE-1333","file":"scripts/lib/security-helpers.js","line":"436-459","description":"The maskEmail function splits on '@' and then '.' without length limits. If an attacker provides an email with thousands of dots in the domain part, the split arrays could be large, and subsequent array operations could be inefficient.","cwe":["CWE-1333"],"owasp_top_10":["A05:2021-Broken Access Control"],"risk":"Moderate - not a ReDoS in the regex sense, but algorithmic DoS through unbounded array operations.","affected_input":"email parameter with many dots, e.g., 'user@a.b.c.d.e....(4000 more)....z'","impact":"CPU exhaustion from large email processing","proof_of_concept":"maskEmail('user@' + '.'.repeat(5000) + '.com') would create a 5000+ element array.","pattern_reference":"CODE_PATTERNS.md #245 - Large input guards to prevent DoS/UI freeze","remediation":"Add a length check: if (email.length > 254) { return '[REDACTED]'; } Email RFC 5321 specifies maximum lengths.","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0011","severity":"S3","title":"Missing Error Handling in refuseSymlinkWithParents - Potential Null Reference","category":"CWE-476","file":"scripts/lib/security-helpers.js","line":"78-93","description":"The refuseSymlinkWithParents function uses path.dirname() in a loop but does not validate that existsSync() is correctly checking permissions. If a directory exists but cannot be read due to permissions, lstatSync() on line 83 could throw EACCES, which is not caught.","cwe":["CWE-476"],"owasp_top_10":[],"risk":"Low - the function is designed to reject symlinks, and permission errors would cause the function to throw (fail-safe), preventing unsafe writes. However, the error message would not be sanitized.","affected_input":"Symlink paths in restricted permission directories","impact":"Unsanitized error messages containing full paths in exceptions","proof_of_concept":"Directory /root/.config (if running as non-root) would throw 'EACCES: permission denied' with full path in error.","pattern_reference":"CODE_PATTERNS.md #105 - lstatSync wrapped in try-catch for permission denied","remediation":"Wrap the lstatSync call in try-catch: try { const st = lstatSync(current); ... } catch(e) { if (e.code === 'EACCES') throw new Error('Permission denied'); else throw e; }","status":"OPEN","confidence":"LOW"}
{"canonical_id":"CANON-0012","severity":"S1","title":"Input Length DoS in validateFilePath - No Maximum Enforcement for Large Inputs","category":"CWE-400","file":"scripts/lib/validate-paths.js","line":"62-75","description":"While the code does cap projectDir and filePath at 4096 characters (lines 62-75), there is no validation that these are reasonable defaults for actual filesystem paths. More critically, if this function is called in a loop (e.g., validating 1000 files), 4096 * 1000 = 4MB of memory could be consumed. On line 78, filePath.trim() is called which creates a copy.","cwe":["CWE-400"],"owasp_top_10":["A05:2021-Broken Access Control"],"risk":"Moderate - in a loop context, attackers could cause memory exhaustion.","affected_input":"Multiple calls to validateFilePath with maximum length paths","impact":"Memory exhaustion leading to DoS","proof_of_concept":"Loop calling validateFilePath 100,000 times with 4096-char paths = 400MB+ memory allocation.","pattern_reference":"CODE_PATTERNS.md #256 - Input length DoS cap projectDir and filePath at 4096","remediation":"Code is already compliant. Consider documenting that callers should not use this in tight loops without batching. Add a note in comments.","status":"RESOLVED","confidence":"MEDIUM"}
{"canonical_id":"CANON-0013","severity":"S2","title":"Incomplete URL Validation in validateUrl - Port Bypass Vulnerability","category":"CWE-94","file":"scripts/lib/security-helpers.js","line":"352-389","description":"The validateUrl function validates the hostname and protocol but does not check the port. A URL like 'https://api.github.com:6379' (pointing to attacker-controlled Redis on a hijacked port) would be allowed. The function also doesn't validate query parameters or fragments which could contain command injection payloads.","cwe":["CWE-94"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Moderate - if URL is used to make HTTP requests, attacker could redirect to internal services on different ports.","affected_input":"urlString parameter with malicious port or query string","impact":"SSRF (Server-Side Request Forgery) to internal services, parameter injection","proof_of_concept":"validateUrl('https://api.github.com:6379?cmd=flushdb', ['api.github.com']) returns valid despite port 6379 being Redis.","pattern_reference":"CODE_PATTERNS.md #241 - URL protocol allowlist - validates protocol + host but PORT should also be checked","remediation":"Add port validation: if (url.port && url.port !== '443') { return { valid: false, error: 'Custom ports not allowed' }; }","status":"OPEN","confidence":"HIGH"}
{"canonical_id":"CANON-0014","severity":"S2","title":"Regex Pattern Injection in validateUrl - Hostname Pattern Mismatch","category":"CWE-1025","file":"scripts/lib/security-helpers.js","line":"376","description":"The IP address validation regex on line 376 uses /^(\\d{1,3}\\.){3}\\d{1,3}$/ which is intended to match IPv4 but is incomplete. It does not validate that each octet is 0-255, so 999.999.999.999 would pass and only fail at network layer. More critically, hostname.startsWith('[') on the same line is a poor check for IPv6.","cwe":["CWE-1025"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Low-medium - the subsequent network layer will reject invalid IPs, but the intent of blocking IPs should be more robust.","affected_input":"URL with invalid IP-like hostnames or IPv6 addresses","impact":"Bypassed IP validation, potential internal network access","proof_of_concept":"validateUrl('https://999.999.999.999', ['example.com']) would pass validation but fail at HTTP level. IPv6 URLs like 'https://[::ffff:127.0.0.1]' might have parsing issues.","pattern_reference":"CODE_PATTERNS.md #235 - IPv6-safe IP parsing","remediation":"Replace IP check with: function isIPAddress(hostname) { try { new URL('http://' + hostname); } catch { return false; } return /^\\d+\\.\\d+\\.\\d+\\.\\d+$/.test(hostname) || /^\\[.*:\\.*\\]$/.test(hostname); }","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0015","severity":"S3","title":"Markdown Escaping in sanitizeDisplayString - Backtick Injection Possible","category":"CWE-94","file":"scripts/lib/security-helpers.js","line":"46-47","description":"The sanitizeDisplayString function removes code blocks with backticks but does not account for template literal backticks (`) in the final escaped output. If a string contains backticks within it, the escapeMd function on line 68 will escape them, but sanitizeDisplayString is called first, potentially losing context.","cwe":["CWE-94"],"owasp_top_10":["A03:2021-Injection"],"risk":"Low - the escapeMd function does include backticks in its character set (line 68), so this is mitigated. However, the order of operations could be clearer.","affected_input":"Display strings with backticks or template literal markers","impact":"Markdown injection if escapeMd is not called after sanitizeDisplayString","proof_of_concept":"sanitizeDisplayString('User: `whoami`') returns 'User: [CODE]', then escapeMd is called by caller, so backticks are lost. If caller only calls sanitizeDisplayString, injection is possible.","pattern_reference":"CODE_PATTERNS.md #268 - Markdown char escaping - create escapeMd()","remediation":"Document that sanitizeDisplayString should be followed by escapeMd, or combine them into a single function: sanitizeAndEscapeMd(str) { return escapeMd(sanitizeDisplayString(str)); }","status":"OPEN","confidence":"LOW"}
