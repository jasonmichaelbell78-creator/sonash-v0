{"id":"EH-001","severity":"S1","category":"Error Handling","file":"scripts/debt/intake-audit.js","line":334,"title":"Silent failure in execFileSync - generate-views failure not propagated","description":"The generate-views.js execution is wrapped in try-catch that swallows errors with only a warning. If generate-views.js fails, this critical step silently continues, leaving views stale and allowing corrupted state to persist.","recommendation":"Either make view regeneration blocking with exit(1) on error, or validate that views were successfully generated before returning.","evidence":["execFileSync call at line 333 without proper error handling","console.warn used at line 335-337 instead of propagating error","Function returns normally at line 341 even if views generation failed"],"confidence":"HIGH","cross_ref":"CLAUDE.md Security Rules"}

{"id":"EH-002","severity":"S1","category":"Error Handling","file":"scripts/debt/intake-manual.js","line":335,"title":"Silent failure in execSync for view regeneration","description":"View regeneration wraps execSync in try-catch with only a warning. Script continues successfully even if critical views become stale. This masks failures and allows downstream corruption.","recommendation":"Add exit(1) in catch block when regenerate-views fails, or implement validation that views match expected state before returning.","evidence":["execSync call at line 335 without error propagation","Catch block at line 336 contains only console.warn","Script exits 0 at line 342 regardless of whether catch executed"],"confidence":"HIGH","cross_ref":"Pattern repeated in sync-sonarcloud.js and intake-audit.js"}

{"id":"EH-003","severity":"S1","category":"Error Handling","file":"scripts/debt/sync-sonarcloud.js","line":469,"title":"Silent catch block in view regeneration - critical step masked","description":"execFileSync wrapped in try-catch with only console.warn. If views fail to regenerate after syncing SonarCloud issues, script exits with 0 (success) anyway. This allows corrupted state where MASTER_DEBT.jsonl is updated but views are stale.","recommendation":"Fail with exit(1) on view regeneration error, or validate views match current state before allowing successful completion.","evidence":["execFileSync at line 466 for view generation","catch block at line 469 contains only warn message, no error propagation","Script summary at line 476 printed regardless of error status"],"confidence":"HIGH","cross_ref":"Critical file operation pattern"}

{"id":"EH-004","severity":"S1","category":"Error Handling","file":".husky/pre-commit","line":333,"title":"Missing error propagation in pre-commit hook - view regeneration silently fails","description":"execFileSync call wrapped in try-catch at line 333-337 warns and continues instead of failing pre-commit. This is a critical gate that should block commits when infrastructure failures occur.","recommendation":"Exit with code 1 in catch block to block commit when views regeneration fails. Pre-commit hooks are automated gates that cannot silently fail.","evidence":["execFileSync call at line 333 in try-catch","console.warn at line 335-337 instead of exit(1)","Pre-commit allows commits to proceed at line 273 despite possible catch block execution"],"confidence":"HIGH","cross_ref":"Husky hook best practices"}

{"id":"EH-005","severity":"S1","category":"Error Handling","file":"scripts/check-pattern-compliance.js","line":576,"title":"Overly broad exception handling in git diff call","description":"execSync for git diff wrapped in try-catch that logs warning and returns empty array for any error. This conflates 'not a git repo' (acceptable) with actual git errors (should surface). Caller cannot distinguish cases.","recommendation":"Separate error types: (1) If 'not a git repo' message, return empty silently, (2) If other git error, re-throw or return error state so caller can decide.","evidence":["execSync at line 567 with git diff command","catch block at line 576 logs warning and returns []","No error differentiation between different failure modes"],"confidence":"MEDIUM","cross_ref":"CODE_PATTERNS.md#error-sanitization"}

{"id":"EH-006","severity":"S1","category":"Exit Code","file":"scripts/debt/intake-audit.js","line":295,"title":"Incorrect exit code semantics - cannot distinguish empty input from valid no-op","description":"When input file is empty (validation error at line 221) vs when all items are duplicates (valid state at line 295), both exit 0. Caller cannot distinguish error from success.","recommendation":"Exit(1) when input is invalid/empty, exit(0) when valid but no new items. Document exit code semantics in header.","evidence":["Line 221: process.exit(0) when inputLines.length === 0 (ERROR - empty input)","Line 295: process.exit(0) when newItems.length === 0 (OK - all duplicates)","Both treated identically by exit code"],"confidence":"HIGH","cross_ref":"scripts/debt/intake-manual.js has same issue"}

{"id":"EH-007","severity":"S1","category":"Error Handling","file":"scripts/debt/intake-manual.js","line":273,"title":"Exit 0 on duplicate found - success exit for error condition","description":"When duplicate is detected (validation failure), script exits with 0. Client sees success status when item was NOT added. This makes error handling ambiguous.","recommendation":"Exit with code 2 for validation failures (item not added). Document that exit(0) = item added, exit(1) = error, exit(2) = validation skip.","evidence":["Line 271-273: Duplicate detected, item not added, exit(0) called","Caller cannot distinguish 'added successfully' from 'skipped as duplicate'"],"confidence":"MEDIUM","cross_ref":"intake-audit.js has different handling - inconsistent"}

{"id":"EH-008","severity":"S1","category":"Error Handling","file":"scripts/validate-audit.js","line":743,"title":"Silent catch block in cross-reference check - eslint validation fails silently","description":"crossReferenceEslint try-catch at line 743 catches all errors and returns unvalidated findings without warning to caller. If npm lint fails, entire cross-reference phase silently skipped.","recommendation":"Log the specific error to console.warn so user knows eslint check failed. Consider failing validation if cross-reference tools are unavailable.","evidence":["Line 743: catch block with only comment","Line 745: returns empty unvalidated array when eslint fails","User has no way to know eslint cross-check was skipped"],"confidence":"MEDIUM","cross_ref":"crossReferenceNpmAudit uses similar pattern at line 662"}

{"id":"EH-009","severity":"S1","category":"Shell Script","file":".husky/pre-commit","line":101,"title":"Shell script swallows errors from append-hook-warning with 2>/dev/null || true","description":"Line 101: node scripts/append-hook-warning.js wrapped with '2>/dev/null || true' silently suppresses all errors. If script fails, pre-commit gate has no visibility into warning capture failures.","recommendation":"Capture stderr to variable, check exit code, and warn user if append-hook-warning fails, but don't block commit (it's informational).","evidence":["Line 101: 'node scripts/append-hook-warning.js ... 2>/dev/null || true'","Lines 113, 238, 269 have similar error suppression patterns"],"confidence":"MEDIUM","cross_ref":"4 instances in pre-commit hook"}

{"id":"EH-010","severity":"S1","category":"Error Handling","file":"scripts/debt/validate-schema.js","line":285,"title":"All errors caught with single exit code - cannot distinguish error types","description":"main().catch() at line 285 treats all errors identically with exit(2). File not found errors are conflated with validation logic errors or file permission issues.","recommendation":"Distinguish error types: file access errors exit(2), validation errors exit(1), logic errors exit(3). Document exit codes.","evidence":["Line 285-288: Single catch block for all exceptions","Exit code 2 for all failures per header L16-17","No error type discrimination"],"confidence":"MEDIUM","cross_ref":"EXIT_CODE documentation"}

{"id":"EH-011","severity":"S2","category":"Workflow Configuration","file":".github/workflows/ci.yml","line":39","title":"Excessive continue-on-error usage reduces CI signal quality","description":"Lines 39, 75, 80, 90, 101, 107: Six instances of 'continue-on-error: true' allow legitimate failures to be silenced. While intended as 'non-blocking', this creates false confidence in CI results.","recommendation":"Evaluate each continue-on-error: (1) Is failure truly acceptable? (2) Can test be made less strict? (3) Should this be separate workflow? (4) Should this fail but not block merge?","evidence":["L39: deps:unused marked non-blocking","L75: patterns:check-all marked non-blocking","L80: docs:check marked non-blocking","L90: audit:validate marked non-blocking","L101, 107: debt checks marked non-blocking"],"confidence":"LOW","cross_ref":"CLAUDE.md Section 4: continueOnError overuse"}

{"id":"EH-012","severity":"S2","category":"Error Handling","file":"scripts/debt/extract-audits.js","line":150,"title":"JSON parse error in file read loop - error message not included in output","description":"At line 150 and similar locations, JSON.parse failures are caught but error.message not included in logged errors. Makes debugging malformed JSONL difficult.","recommendation":"Include full error message from catch block in validation output so users can identify which line is malformed.","evidence":["Line 150: catch block logs error but filtering/processing may lose details"],"confidence":"LOW","cross_ref":"loadFalsePositives pattern shows better error handling"}

{"id":"EH-013","severity":"S1","category":"Error Handling","file":"scripts/check-pattern-compliance.js","line":770,"title":"existsSync check gives false security - doesn't prevent race conditions","description":"Pattern at line 771: existsSync check before readFileSync creates false confidence about file safety. Race condition can still occur where file is deleted between check and read.","recommendation":"Remove existsSync check - rely entirely on try-catch. Document that try-catch handles all file access failures including TOCTOU races.","evidence":["Line 771: existsSync check before read","Line 774-781: readFileSync in try-catch is actual protection","Redundant check creates dangerous false security"],"confidence":"MEDIUM","cross_ref":"CODE_PATTERNS.md warns about readfilesync without try"}

{"id":"EH-014","severity":"S1","category":"Error Handling","file":"scripts/debt/intake-pr-deferred.js","line":334,"title":"execSync error handling missing in view regeneration","description":"Line 335: execSync call for generate-views.js has no error handling. If it fails, script exits with non-zero but error context is lost.","recommendation":"Wrap in try-catch with proper error message, or use try-finally to ensure cleanup happens.","evidence":["Line 335: execSync('node scripts/debt/generate-views.js', { stdio: 'inherit' })","No try-catch wrapper around this critical call"],"confidence":"HIGH","cross_ref":"Similar to EH-002 but missing try-catch entirely"}

{"id":"EH-015","severity":"S1","category":"Error Handling","file":".husky/pre-commit","line":199,"title":"Pipe in shell script creates subshell - variable assignment not propagated","description":"Line 197-211: Comment at L198 correctly identifies subshell issue from pipes, but solution uses temp file. However, AUDIT_TMPFILE cleanup at line 201 overwrites existing trap, risking file leak if earlier trap already set.","recommendation":"Use trap chaining: append new trap commands to existing trap rather than overwriting with new trap statement.","evidence":["Line 200: mktemp creates AUDIT_TMPFILE","Line 201: trap 'rm -f ... overwrites line 57 trap for TEST_TMPFILE","If trap at 57 executes, AUDIT_TMPFILE won't be cleaned"],"confidence":"MEDIUM","cross_ref":"Shell script best practices - Review #204 mentions this"}

EOF
