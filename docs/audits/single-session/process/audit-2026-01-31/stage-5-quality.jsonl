{"id":"EH-001","severity":"S1","category":"Error Handling","file":"scripts/debt/intake-audit.js","line":334,"title":"Silent failure in execFileSync - generate-views failure not propagated","description":"The generate-views.js execution is wrapped in try-catch that swallows errors with only a warning. If generate-views.js fails, this critical step silently continues, leaving views stale and allowing corrupted state to persist.","recommendation":"Either make view regeneration blocking with exit(1) on error, or validate that views were successfully generated before returning.","evidence":["execFileSync call at line 333 without proper error handling","console.warn used at line 335-337 instead of propagating error","Function returns normally at line 341 even if views generation failed"],"confidence":"HIGH","cross_ref":"CLAUDE.md Security Rules"}
{"id":"EH-002","severity":"S1","category":"Error Handling","file":"scripts/debt/intake-manual.js","line":335,"title":"Silent failure in execSync for view regeneration","description":"View regeneration wraps execSync in try-catch with only a warning. Script continues successfully even if critical views become stale. This masks failures and allows downstream corruption.","recommendation":"Add exit(1) in catch block when regenerate-views fails, or implement validation that views match expected state before returning.","evidence":["execSync call at line 335 without error propagation","Catch block at line 336 contains only console.warn","Script exits 0 at line 342 regardless of whether catch executed"],"confidence":"HIGH","cross_ref":"Pattern repeated in sync-sonarcloud.js and intake-audit.js"}
{"id":"EH-003","severity":"S1","category":"Error Handling","file":"scripts/debt/sync-sonarcloud.js","line":469,"title":"Silent catch block in view regeneration - critical step masked","description":"execFileSync wrapped in try-catch with only console.warn. If views fail to regenerate after syncing SonarCloud issues, script exits with 0 (success) anyway. This allows corrupted state where MASTER_DEBT.jsonl is updated but views are stale.","recommendation":"Fail with exit(1) on view regeneration error, or validate views match current state before allowing successful completion.","evidence":["execFileSync at line 466 for view generation","catch block at line 469 contains only warn message, no error propagation","Script summary at line 476 printed regardless of error status"],"confidence":"HIGH","cross_ref":"Critical file operation pattern"}
{"id":"EH-004","severity":"S1","category":"Error Handling","file":".husky/pre-commit","line":333,"title":"Missing error propagation in pre-commit hook - view regeneration silently fails","description":"execFileSync call wrapped in try-catch at line 333-337 warns and continues instead of failing pre-commit. This is a critical gate that should block commits when infrastructure failures occur.","recommendation":"Exit with code 1 in catch block to block commit when views regeneration fails. Pre-commit hooks are automated gates that cannot silently fail.","evidence":["execFileSync call at line 333 in try-catch","console.warn at line 335-337 instead of exit(1)","Pre-commit allows commits to proceed at line 273 despite possible catch block execution"],"confidence":"HIGH","cross_ref":"Husky hook best practices"}
{"id":"EH-005","severity":"S1","category":"Error Handling","file":"scripts/check-pattern-compliance.js","line":576,"title":"Overly broad exception handling in git diff call","description":"execSync for git diff wrapped in try-catch that logs warning and returns empty array for any error. This conflates 'not a git repo' (acceptable) with actual git errors (should surface). Caller cannot distinguish cases.","recommendation":"Separate error types: (1) If 'not a git repo' message, return empty silently, (2) If other git error, re-throw or return error state so caller can decide.","evidence":["execSync at line 567 with git diff command","catch block at line 576 logs warning and returns []","No error differentiation between different failure modes"],"confidence":"MEDIUM","cross_ref":"CODE_PATTERNS.md#error-sanitization"}
{"id":"EH-006","severity":"S1","category":"Exit Code","file":"scripts/debt/intake-audit.js","line":295,"title":"Incorrect exit code semantics - cannot distinguish empty input from valid no-op","description":"When input file is empty (validation error at line 221) vs when all items are duplicates (valid state at line 295), both exit 0. Caller cannot distinguish error from success.","recommendation":"Exit(1) when input is invalid/empty, exit(0) when valid but no new items. Document exit code semantics in header.","evidence":["Line 221: process.exit(0) when inputLines.length === 0 (ERROR - empty input)","Line 295: process.exit(0) when newItems.length === 0 (OK - all duplicates)","Both treated identically by exit code"],"confidence":"HIGH","cross_ref":"scripts/debt/intake-manual.js has same issue"}
{"id":"EH-007","severity":"S1","category":"Error Handling","file":"scripts/debt/intake-manual.js","line":273,"title":"Exit 0 on duplicate found - success exit for error condition","description":"When duplicate is detected (validation failure), script exits with 0. Client sees success status when item was NOT added. This makes error handling ambiguous.","recommendation":"Exit with code 2 for validation failures (item not added). Document that exit(0) = item added, exit(1) = error, exit(2) = validation skip.","evidence":["Line 271-273: Duplicate detected, item not added, exit(0) called","Caller cannot distinguish 'added successfully' from 'skipped as duplicate'"],"confidence":"MEDIUM","cross_ref":"intake-audit.js has different handling - inconsistent"}
{"id":"EH-008","severity":"S1","category":"Error Handling","file":"scripts/validate-audit.js","line":743,"title":"Silent catch block in cross-reference check - eslint validation fails silently","description":"crossReferenceEslint try-catch at line 743 catches all errors and returns unvalidated findings without warning to caller. If npm lint fails, entire cross-reference phase silently skipped.","recommendation":"Log the specific error to console.warn so user knows eslint check failed. Consider failing validation if cross-reference tools are unavailable.","evidence":["Line 743: catch block with only comment","Line 745: returns empty unvalidated array when eslint fails","User has no way to know eslint cross-check was skipped"],"confidence":"MEDIUM","cross_ref":"crossReferenceNpmAudit uses similar pattern at line 662"}
{"id":"EH-009","severity":"S1","category":"Shell Script","file":".husky/pre-commit","line":101,"title":"Shell script swallows errors from append-hook-warning with 2>/dev/null || true","description":"Line 101: node scripts/append-hook-warning.js wrapped with '2>/dev/null || true' silently suppresses all errors. If script fails, pre-commit gate has no visibility into warning capture failures.","recommendation":"Capture stderr to variable, check exit code, and warn user if append-hook-warning fails, but don't block commit (it's informational).","evidence":["Line 101: 'node scripts/append-hook-warning.js ... 2>/dev/null || true'","Lines 113, 238, 269 have similar error suppression patterns"],"confidence":"MEDIUM","cross_ref":"4 instances in pre-commit hook"}
{"id":"EH-010","severity":"S1","category":"Error Handling","file":"scripts/debt/validate-schema.js","line":285,"title":"All errors caught with single exit code - cannot distinguish error types","description":"main().catch() at line 285 treats all errors identically with exit(2). File not found errors are conflated with validation logic errors or file permission issues.","recommendation":"Distinguish error types: file access errors exit(2), validation errors exit(1), logic errors exit(3). Document exit codes.","evidence":["Line 285-288: Single catch block for all exceptions","Exit code 2 for all failures per header L16-17","No error type discrimination"],"confidence":"MEDIUM","cross_ref":"EXIT_CODE documentation"}
{"id":"EH-011","severity":"S2","category":"Workflow Configuration","file":".github/workflows/ci.yml","line":39","title":"Excessive continue-on-error usage reduces CI signal quality","description":"Lines 39, 75, 80, 90, 101, 107: Six instances of 'continue-on-error: true' allow legitimate failures to be silenced. While intended as 'non-blocking', this creates false confidence in CI results.","recommendation":"Evaluate each continue-on-error: (1) Is failure truly acceptable? (2) Can test be made less strict? (3) Should this be separate workflow? (4) Should this fail but not block merge?","evidence":["L39: deps:unused marked non-blocking","L75: patterns:check-all marked non-blocking","L80: docs:check marked non-blocking","L90: audit:validate marked non-blocking","L101, 107: debt checks marked non-blocking"],"confidence":"LOW","cross_ref":"CLAUDE.md Section 4: continueOnError overuse"}
{"id":"EH-012","severity":"S2","category":"Error Handling","file":"scripts/debt/extract-audits.js","line":150,"title":"JSON parse error in file read loop - error message not included in output","description":"At line 150 and similar locations, JSON.parse failures are caught but error.message not included in logged errors. Makes debugging malformed JSONL difficult.","recommendation":"Include full error message from catch block in validation output so users can identify which line is malformed.","evidence":["Line 150: catch block logs error but filtering/processing may lose details"],"confidence":"LOW","cross_ref":"loadFalsePositives pattern shows better error handling"}
{"id":"EH-013","severity":"S1","category":"Error Handling","file":"scripts/check-pattern-compliance.js","line":770,"title":"existsSync check gives false security - doesn't prevent race conditions","description":"Pattern at line 771: existsSync check before readFileSync creates false confidence about file safety. Race condition can still occur where file is deleted between check and read.","recommendation":"Remove existsSync check - rely entirely on try-catch. Document that try-catch handles all file access failures including TOCTOU races.","evidence":["Line 771: existsSync check before read","Line 774-781: readFileSync in try-catch is actual protection","Redundant check creates dangerous false security"],"confidence":"MEDIUM","cross_ref":"CODE_PATTERNS.md warns about readfilesync without try"}
{"id":"EH-014","severity":"S1","category":"Error Handling","file":"scripts/debt/intake-pr-deferred.js","line":334,"title":"execSync error handling missing in view regeneration","description":"Line 335: execSync call for generate-views.js has no error handling. If it fails, script exits with non-zero but error context is lost.","recommendation":"Wrap in try-catch with proper error message, or use try-finally to ensure cleanup happens.","evidence":["Line 335: execSync('node scripts/debt/generate-views.js', { stdio: 'inherit' })","No try-catch wrapper around this critical call"],"confidence":"HIGH","cross_ref":"Similar to EH-002 but missing try-catch entirely"}
{"id":"EH-015","severity":"S1","category":"Error Handling","file":".husky/pre-commit","line":199,"title":"Pipe in shell script creates subshell - variable assignment not propagated","description":"Line 197-211: Comment at L198 correctly identifies subshell issue from pipes, but solution uses temp file. However, AUDIT_TMPFILE cleanup at line 201 overwrites existing trap, risking file leak if earlier trap already set.","recommendation":"Use trap chaining: append new trap commands to existing trap rather than overwriting with new trap statement.","evidence":["Line 200: mktemp creates AUDIT_TMPFILE","Line 201: trap 'rm -f ... overwrites line 57 trap for TEST_TMPFILE","If trap at 57 executes, AUDIT_TMPFILE won't be cleaned"],"confidence":"MEDIUM","cross_ref":"Shell script best practices - Review #204 mentions this"}
{"canonical_id":"CANON-0001","severity":"S1","title":"Regex Pattern State Leak in sanitize-error.js","category":"OWASP-A05","file":"scripts/lib/sanitize-error.js","line":89,"description":"In the sanitizeError function, regex patterns with the /g flag are reused in a loop without proper state reset. While lastIndex IS reset on line 90, there is a critical issue: if any pattern match fails or the loop is interrupted, subsequent patterns in the iteration may see an invalid lastIndex state.","cwe":["CWE-1321"],"owasp_top_10":["A05:2021-Broken Access Control"],"risk":"An attacker providing crafted error messages with specific Unicode patterns could cause pattern state corruption, leading to failed sanitization of subsequent error messages, exposing sensitive paths in logs.","affected_input":"error parameter with specific pattern sequences","impact":"Information disclosure through error message leakage","proof_of_concept":"Error with multiple paths: 'Error at /home/user/project: /etc/passwd access denied' - the regex lastIndex reset may not properly reset between patterns if patterns have state modifications.","pattern_reference":"CODE_PATTERNS.md #44 - Regex state leak reset lastIndex before each iteration","remediation":"The current implementation correctly resets lastIndex on line 90 before each pattern.replace(). STATUS: RESOLVED - No finding.","status":"RESOLVED","confidence":"HIGH"}
{"canonical_id":"CANON-0002","severity":"S2","title":"Overly Broad Error Sanitization in security-helpers.js","category":"General","file":"scripts/lib/security-helpers.js","line":"26-31","description":"The sanitizeError function uses aggressive regex replacements that match file paths using /g flag with patterns like /\\/g and /^[^\\s]*\/[^\\s]+/g. These patterns are not properly anchored and may match legitimate error content that should be preserved.","cwe":["CWE-176"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Overly sanitized error messages may make debugging difficult and hide important error context. The pattern /\\/[^\\s]*\\/[^\\s]+/g is too broad and may match URLs, regular expressions in error messages, or other content.","affected_input":"Any error message containing Unix paths or forward slashes","impact":"Reduced debugging capability, information loss in error logging","proof_of_concept":"Error message: 'Failed to parse file:/etc/config.json at /home/user' becomes 'Failed to parse [PATH] at [PATH]' - losing the file:// URL context that might be important.","pattern_reference":"CODE_PATTERNS.md #34 - Relative path logging should be targeted, not overly broad","remediation":"Review sanitization patterns to be more targeted. Current patterns in line 26-31 are too broad. Recommend using more specific patterns that target only known sensitive paths (/home/, /Users/, C:\\\\Users\\\\) rather than general Unix path matching.","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0003","severity":"S1","title":"Missing NUL Byte Validation in security-helpers.js validatePathInDir","category":"CWE-158","file":"scripts/lib/security-helpers.js","line":"104-118","description":"The validatePathInDir function does not validate for NUL bytes (\\x00) before path operations. NUL bytes can cause path resolution to be silently truncated in some contexts, leading to path traversal vulnerabilities.","cwe":["CWE-158","CWE-22"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"A path like 'valid/path\\x00../../../etc/passwd' may be partially validated and then truncated, allowing traversal outside the base directory.","affected_input":"userPath parameter with embedded NUL bytes","impact":"Path traversal leading to unauthorized file access","proof_of_concept":"validatePathInDir('/project', 'docs\\x00../../../etc/passwd') may pass validation and then path.resolve() would operate on 'docs' after truncation.","pattern_reference":"CODE_PATTERNS.md #108 - Security: Reject NUL bytes","remediation":"Add NUL byte check: if (userPath.includes('\\x00')) { throw new Error(...); } before path resolution.","status":"OPEN","confidence":"HIGH"}
{"canonical_id":"CANON-0004","severity":"S2","title":"Insufficient CLI Argument Validation in security-helpers.js parseCliArgs","category":"CWE-89","file":"scripts/lib/security-helpers.js","line":"287-292","description":"In parseCliArgs, the number parsing uses parseInt(next, 10) without proper radix parameter consistency. More critically, there is no validation that the parsed number is finite or checking for Infinity/NaN results before range validation.","cwe":["CWE-89","CWE-1025"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Inputs like 'Infinity', 'NaN', or very large numbers could bypass range validation. Example: parseInt('1e10', 10) returns 1, but 'Infinity' returns NaN which would fail the isNaN check correctly, but 'null' or undefined in parseInt edge cases.","affected_input":"--count argument with special numeric strings","impact":"Potential for argument validation bypass","proof_of_concept":"parseCliArgs(['--count', '1e10']) with min:1 max:100 - parseInt('1e10', 10) returns 1 (correct), but needs Number.isFinite() check.","pattern_reference":"CODE_PATTERNS.md #332 - Number.parseInt radix parameter","remediation":"Change to: if (!Number.isFinite(num)) { errors.push(...); continue; } after parseInt.","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0005","severity":"S1","title":"Path Traversal in validate-paths.js validateFilePath - Insufficient Control Character Filtering","category":"CWE-22","file":"scripts/lib/validate-paths.js","line":"88","description":"The control character validation excludes tab (0x09), newline (0x0A), and carriage return (0x0D) per comment on line 86. However, this creates a gap: newline characters can be used in path traversal when combined with specific filesystem behaviors. The validation does check for \\n and \\r on lines 100-104, which is good, but the comment is misleading about what's being checked.","cwe":["CWE-22","CWE-158"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Low - the subsequent explicit check for \\n and \\r on line 100 catches this. However, the code is confusing and could be misinterpreted by future maintainers.","affected_input":"filePath with newline characters","impact":"Code clarity issue, not a direct vulnerability due to explicit newline checks","proof_of_concept":"Path like 'file.txt\\nmalicious' is correctly rejected by lines 100-104.","pattern_reference":"CODE_PATTERNS.md #98 - Multiline path rejection","remediation":"Simplify by removing the misleading comment on line 86 and consolidating control character rejection into a single clear block.","status":"OPEN","confidence":"LOW"}
{"canonical_id":"CANON-0006","severity":"S2","title":"TOCTOU Race Condition in validate-paths.js verifyContainment","category":"CWE-367","file":"scripts/lib/validate-paths.js","line":"160-162","description":"The verifyContainment function calls fs.realpathSync() on both fullPath and projectDir separately. Between these two calls, symlinks or permissions could change, causing a TOCTOU (Time-of-check-time-of-use) race condition where the first path is validated as contained, but the second realpath call results in a different base directory.","cwe":["CWE-367"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"In scenarios with rapidly changing symlinks or permissions, the containment check could be bypassed.","affected_input":"File paths in directories with changing symlink structure","impact":"Path traversal via race condition","proof_of_concept":"Attacker modifies symlinks between realpathSync(fullPath) on line 161 and realpathSync(projectDir) on line 162, causing projectDir to resolve to a different location.","pattern_reference":"CODE_PATTERNS.md #22 - Fail-closed realpath and #367 TOCTOU races","remediation":"Resolve projectDir once at function entry and cache it. Document that projectDir must be stable during the call. Alternative: use stat() to detect changes, or accept the TOCTOU window as acceptable for hook/CI operations (document this decision).","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0007","severity":"S2","title":"Information Disclosure in sanitizeFilesystemError - Incomplete Path Sanitization","category":"CWE-532","file":"scripts/lib/validate-paths.js","line":"22-46","description":"The sanitizeFilesystemError function attempts to redact system paths but has incomplete coverage. Notably, paths containing dots in directory names (e.g., /home/user.old/project) may not be properly redacted if the user name contains special characters. The regex /C:\\\\Users\\\\[^\\n\\r]+/g will match, but the subsequent general patterns may re-expose parts.","cwe":["CWE-532"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Sensitive filesystem paths may still appear in logs.","affected_input":"Error messages with user home directories containing dots or special chars","impact":"Information disclosure of directory structure","proof_of_concept":"Path: 'C:\\\\Users\\\\first.last' is sanitized to '[HOME]', but complex nested paths might leave partial information.","pattern_reference":"CODE_PATTERNS.md #321 - Windows path sanitize with gi flag","remediation":"Add gi flags to Windows path patterns for case-insensitive matching. Verify all sensitive base directories are covered (add /var/lib, /srv, /opt patterns).","status":"OPEN","confidence":"LOW"}
{"canonical_id":"CANON-0008","severity":"S1","title":"Command Injection in safeGitAdd - Arguments Array Properly Used but No Deep Validation","category":"CWE-78","file":"scripts/lib/security-helpers.js","line":"171-182","description":"While safeGitAdd correctly uses execFileSync with argument arrays (preventing shell interpolation on line 181), it does not validate the git binary path or verify that git is actually being executed. An attacker who can modify PATH could cause a different 'git' executable to be invoked.","cwe":["CWE-78"],"owasp_top_10":["A03:2021-Injection"],"risk":"Low-medium if PATH can be controlled by unprivileged users in the hook execution environment.","affected_input":"repoRoot parameter and system PATH","impact":"Arbitrary code execution as the hook user if PATH is controlled","proof_of_concept":"If a hook runs with an attacker-controlled environment where /tmp/git is a malicious script, and /tmp is in PATH before /usr/bin, the fake git would be invoked.","pattern_reference":"CODE_PATTERNS.md #244 - execFileSync should use full path for untrusted systems","remediation":"Consider using the full path to git (e.g., '/usr/bin/git' on Unix, 'C:\\\\Program Files\\\\Git\\\\bin\\\\git.exe' on Windows) or document that this function expects PATH to be clean. Alternatively, use 'where.cmd git' on Windows or 'which git' on Unix to resolve the git binary path.","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0009","severity":"S3","title":"Magic String in safeGitCommit - Hardcoded PID/Timestamp Format","category":"General","file":"scripts/lib/security-helpers.js","line":"193","description":"The temporary filename construction uses process.pid and Date.now() but does not validate the temp directory is actually writable or that collisions are impossible. On systems with PID reuse and high concurrency, multiple processes could generate identical filenames simultaneously.","cwe":[],"owasp_top_10":[],"risk":"Low - the wx flag will catch collisions with EEXIST error, but the error handling could be clearer.","affected_input":"Concurrent invocations of safeGitCommit","impact":"Possible temporary file collision leading to commit failure (not data loss due to wx flag)","proof_of_concept":"Two processes with the same PID after wraparound + same Date.now() millisecond precision collision (extremely unlikely but theoretically possible).","pattern_reference":"General - Temporary file naming collision avoidance","remediation":"Use crypto.randomUUID() in the filename: `COMMIT_MSG_${crypto.randomUUID()}.txt` for guaranteed uniqueness.","status":"OPEN","confidence":"LOW"}
{"canonical_id":"CANON-0010","severity":"S2","title":"Regex DoS (ReDoS) Potential in maskEmail - Unbounded Domain Splitting","category":"CWE-1333","file":"scripts/lib/security-helpers.js","line":"436-459","description":"The maskEmail function splits on '@' and then '.' without length limits. If an attacker provides an email with thousands of dots in the domain part, the split arrays could be large, and subsequent array operations could be inefficient.","cwe":["CWE-1333"],"owasp_top_10":["A05:2021-Broken Access Control"],"risk":"Moderate - not a ReDoS in the regex sense, but algorithmic DoS through unbounded array operations.","affected_input":"email parameter with many dots, e.g., 'user@a.b.c.d.e....(4000 more)....z'","impact":"CPU exhaustion from large email processing","proof_of_concept":"maskEmail('user@' + '.'.repeat(5000) + '.com') would create a 5000+ element array.","pattern_reference":"CODE_PATTERNS.md #245 - Large input guards to prevent DoS/UI freeze","remediation":"Add a length check: if (email.length > 254) { return '[REDACTED]'; } Email RFC 5321 specifies maximum lengths.","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0011","severity":"S3","title":"Missing Error Handling in refuseSymlinkWithParents - Potential Null Reference","category":"CWE-476","file":"scripts/lib/security-helpers.js","line":"78-93","description":"The refuseSymlinkWithParents function uses path.dirname() in a loop but does not validate that existsSync() is correctly checking permissions. If a directory exists but cannot be read due to permissions, lstatSync() on line 83 could throw EACCES, which is not caught.","cwe":["CWE-476"],"owasp_top_10":[],"risk":"Low - the function is designed to reject symlinks, and permission errors would cause the function to throw (fail-safe), preventing unsafe writes. However, the error message would not be sanitized.","affected_input":"Symlink paths in restricted permission directories","impact":"Unsanitized error messages containing full paths in exceptions","proof_of_concept":"Directory /root/.config (if running as non-root) would throw 'EACCES: permission denied' with full path in error.","pattern_reference":"CODE_PATTERNS.md #105 - lstatSync wrapped in try-catch for permission denied","remediation":"Wrap the lstatSync call in try-catch: try { const st = lstatSync(current); ... } catch(e) { if (e.code === 'EACCES') throw new Error('Permission denied'); else throw e; }","status":"OPEN","confidence":"LOW"}
{"canonical_id":"CANON-0012","severity":"S1","title":"Input Length DoS in validateFilePath - No Maximum Enforcement for Large Inputs","category":"CWE-400","file":"scripts/lib/validate-paths.js","line":"62-75","description":"While the code does cap projectDir and filePath at 4096 characters (lines 62-75), there is no validation that these are reasonable defaults for actual filesystem paths. More critically, if this function is called in a loop (e.g., validating 1000 files), 4096 * 1000 = 4MB of memory could be consumed. On line 78, filePath.trim() is called which creates a copy.","cwe":["CWE-400"],"owasp_top_10":["A05:2021-Broken Access Control"],"risk":"Moderate - in a loop context, attackers could cause memory exhaustion.","affected_input":"Multiple calls to validateFilePath with maximum length paths","impact":"Memory exhaustion leading to DoS","proof_of_concept":"Loop calling validateFilePath 100,000 times with 4096-char paths = 400MB+ memory allocation.","pattern_reference":"CODE_PATTERNS.md #256 - Input length DoS cap projectDir and filePath at 4096","remediation":"Code is already compliant. Consider documenting that callers should not use this in tight loops without batching. Add a note in comments.","status":"RESOLVED","confidence":"MEDIUM"}
{"canonical_id":"CANON-0013","severity":"S2","title":"Incomplete URL Validation in validateUrl - Port Bypass Vulnerability","category":"CWE-94","file":"scripts/lib/security-helpers.js","line":"352-389","description":"The validateUrl function validates the hostname and protocol but does not check the port. A URL like 'https://api.github.com:6379' (pointing to attacker-controlled Redis on a hijacked port) would be allowed. The function also doesn't validate query parameters or fragments which could contain command injection payloads.","cwe":["CWE-94"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Moderate - if URL is used to make HTTP requests, attacker could redirect to internal services on different ports.","affected_input":"urlString parameter with malicious port or query string","impact":"SSRF (Server-Side Request Forgery) to internal services, parameter injection","proof_of_concept":"validateUrl('https://api.github.com:6379?cmd=flushdb', ['api.github.com']) returns valid despite port 6379 being Redis.","pattern_reference":"CODE_PATTERNS.md #241 - URL protocol allowlist - validates protocol + host but PORT should also be checked","remediation":"Add port validation: if (url.port && url.port !== '443') { return { valid: false, error: 'Custom ports not allowed' }; }","status":"OPEN","confidence":"HIGH"}
{"canonical_id":"CANON-0014","severity":"S2","title":"Regex Pattern Injection in validateUrl - Hostname Pattern Mismatch","category":"CWE-1025","file":"scripts/lib/security-helpers.js","line":"376","description":"The IP address validation regex on line 376 uses /^(\\d{1,3}\\.){3}\\d{1,3}$/ which is intended to match IPv4 but is incomplete. It does not validate that each octet is 0-255, so 999.999.999.999 would pass and only fail at network layer. More critically, hostname.startsWith('[') on the same line is a poor check for IPv6.","cwe":["CWE-1025"],"owasp_top_10":["A01:2021-Broken Access Control"],"risk":"Low-medium - the subsequent network layer will reject invalid IPs, but the intent of blocking IPs should be more robust.","affected_input":"URL with invalid IP-like hostnames or IPv6 addresses","impact":"Bypassed IP validation, potential internal network access","proof_of_concept":"validateUrl('https://999.999.999.999', ['example.com']) would pass validation but fail at HTTP level. IPv6 URLs like 'https://[::ffff:127.0.0.1]' might have parsing issues.","pattern_reference":"CODE_PATTERNS.md #235 - IPv6-safe IP parsing","remediation":"Replace IP check with: function isIPAddress(hostname) { try { new URL('http://' + hostname); } catch { return false; } return /^\\d+\\.\\d+\\.\\d+\\.\\d+$/.test(hostname) || /^\\[.*:\\.*\\]$/.test(hostname); }","status":"OPEN","confidence":"MEDIUM"}
{"canonical_id":"CANON-0015","severity":"S3","title":"Markdown Escaping in sanitizeDisplayString - Backtick Injection Possible","category":"CWE-94","file":"scripts/lib/security-helpers.js","line":"46-47","description":"The sanitizeDisplayString function removes code blocks with backticks but does not account for template literal backticks (`) in the final escaped output. If a string contains backticks within it, the escapeMd function on line 68 will escape them, but sanitizeDisplayString is called first, potentially losing context.","cwe":["CWE-94"],"owasp_top_10":["A03:2021-Injection"],"risk":"Low - the escapeMd function does include backticks in its character set (line 68), so this is mitigated. However, the order of operations could be clearer.","affected_input":"Display strings with backticks or template literal markers","impact":"Markdown injection if escapeMd is not called after sanitizeDisplayString","proof_of_concept":"sanitizeDisplayString('User: `whoami`') returns 'User: [CODE]', then escapeMd is called by caller, so backticks are lost. If caller only calls sanitizeDisplayString, injection is possible.","pattern_reference":"CODE_PATTERNS.md #268 - Markdown char escaping - create escapeMd()","remediation":"Document that sanitizeDisplayString should be followed by escapeMd, or combine them into a single function: sanitizeAndEscapeMd(str) { return escapeMd(sanitizeDisplayString(str)); }","status":"OPEN","confidence":"LOW"}
