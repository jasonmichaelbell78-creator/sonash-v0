{"category":"process","title":"Bug: check-review-needed.js - getNextDay() fails silently on invalid dates","fingerprint":"process::scripts/check-review-needed.js::getnextday-silent-failure","severity":"S2","effort":"E1","confidence":"MEDIUM","files":["scripts/check-review-needed.js:170","scripts/check-review-needed.js:534","scripts/check-review-needed.js:550"],"why_it_matters":"getNextDay() returns empty string on invalid date (line 176), but callers at lines 534 and 550 don't validate the result. This passes empty string to git commands as --since=\"\" which may not fail but could produce unexpected results, potentially causing incorrect review trigger calculations.","suggested_fix":"Add validation in getNextDay() callers to check for empty string return and handle gracefully: const afterDate = getNextDay(sinceDate); if (!afterDate) { return 0; } // or appropriate fallback","acceptance_tests":["Script handles invalid dates in audit tracker without silent failures","Git commands receive valid date parameters or operations fail explicitly"],"file":"scripts/check-review-needed.js","line":170,"description":"getNextDay() returns empty string on invalid date (line 176), but callers at lines 534 and 550 don't validate the result. This passes empty string to git commands as --since=\"\" which may not fail but could produce unexpected results, potentially causing incorrect review trigger calculations.","recommendation":"Add validation in getNextDay() callers to check for empty string return and handle gracefully: const afterDate = getNextDay(sinceDate); if (!afterDate) { return 0; } // or appropriate fallback","id":"process::scripts/check-review-needed.js::getnextday-silent-failure"}
{"category":"process","title":"Bug: check-cross-doc-deps.js - checkDiffPattern() silently skips rules on git errors","fingerprint":"process::scripts/check-cross-doc-deps.js::checkdiffpattern-silent-skip","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/check-cross-doc-deps.js:100"],"why_it_matters":"checkDiffPattern() catches all errors and returns false without warning (lines 110-118). If git diff fails (e.g., binary file, permission issue, corrupted file), the dependency check rule is silently skipped. This could miss required dependent document updates, defeating the purpose of cross-document enforcement.","suggested_fix":"Log errors when git diff fails in non-verbose mode, or collect failed checks and report them in summary. Consider: if (verbose) logVerbose(`Failed to check diff...`) should be if (verbose || diffCheckFailed) log(`Warning: Failed to check...`)","acceptance_tests":["Script reports when git diff operations fail","Dependency checks don't silently skip due to git errors"],"file":"scripts/check-cross-doc-deps.js","line":100,"description":"checkDiffPattern() catches all errors and returns false without warning (lines 110-118). If git diff fails (e.g., binary file, permission issue, corrupted file), the dependency check rule is silently skipped. This could miss required dependent document updates, defeating the purpose of cross-document enforcement.","recommendation":"Log errors when git diff fails in non-verbose mode, or collect failed checks and report them in summary. Consider: if (verbose) logVerbose(`Failed to check diff...`) should be if (verbose || diffCheckFailed) log(`Warning: Failed to check...`)","id":"process::scripts/check-cross-doc-deps.js::checkdiffpattern-silent-skip"}
{"category":"process","title":"Bug: check-cross-doc-deps.js - inconsistent behavior with empty dependency rules","fingerprint":"process::scripts/check-cross-doc-deps.js::empty-rules-inconsistent","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/check-cross-doc-deps.js:69"],"why_it_matters":"When config loads with empty rules (line 69), the script exits with error code 2 in normal mode (line 75) but continues in dry-run mode (line 73) and reports success. This inconsistency means --dry-run doesn't accurately simulate normal behavior, and empty config might go unnoticed in testing.","suggested_fix":"Remove the dry-run exemption: if (dependencyRules.length === 0) { log('Error: cross-doc dependency enforcement disabled due to empty rules.', colors.red); process.exit(2); } // No dry-run check","acceptance_tests":["Script fails consistently with empty rules in both normal and dry-run modes","Dry-run mode accurately simulates normal execution behavior"],"file":"scripts/check-cross-doc-deps.js","line":69,"description":"When config loads with empty rules (line 69), the script exits with error code 2 in normal mode (line 75) but continues in dry-run mode (line 73) and reports success. This inconsistency means --dry-run doesn't accurately simulate normal behavior, and empty config might go unnoticed in testing.","recommendation":"Remove the dry-run exemption: if (dependencyRules.length === 0) { log('Error: cross-doc dependency enforcement disabled due to empty rules.', colors.red); process.exit(2); } // No dry-run check","id":"process::scripts/check-cross-doc-deps.js::empty-rules-inconsistent"}
{"category":"process","title":"Bug: security-check.js - getStagedFiles() returns empty array on git failure without error","fingerprint":"process::scripts/security-check.js::getstagedfiles-silent-failure","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/security-check.js:310"],"why_it_matters":"getStagedFiles() catch block (line 321-323) returns empty array when git fails (not a git repo, git not installed, permission issues) without logging the error. Main function then prints 'No files to check' which is misleading - the issue is git failure, not absence of files. Users may think security check passed when it silently failed.","suggested_fix":"Log git errors before returning empty array: try { ... } catch (err) { if (!isQuiet) console.error(`Warning: Could not get staged files from git: ${err.message}`); return []; }","acceptance_tests":["Script reports git errors when failing to retrieve staged files","Users can distinguish between 'no staged files' and 'git command failed'"],"file":"scripts/security-check.js","line":310,"description":"getStagedFiles() catch block (line 321-323) returns empty array when git fails (not a git repo, git not installed, permission issues) without logging the error. Main function then prints 'No files to check' which is misleading - the issue is git failure, not absence of files. Users may think security check passed when it silently failed.","recommendation":"Log git errors before returning empty array: try { ... } catch (err) { if (!isQuiet) console.error(`Warning: Could not get staged files from git: ${err.message}`); return []; }","id":"process::scripts/security-check.js::getstagedfiles-silent-failure"}
{"category":"process","title":"Bug: validate-audit.js - wildcard file patterns not validated for existence","fingerprint":"process::scripts/validate-audit.js::wildcard-no-existence-check","severity":"S3","effort":"E1","confidence":"MEDIUM","files":["scripts/validate-audit.js:370"],"why_it_matters":"validateFilePath() checks wildcard patterns (line 370-383) by validating only the prefix path for containment, but doesn't verify if the pattern matches any actual files. A finding with file='src/*.js' passes validation even if no such files exist. This allows ineffective or typo'd patterns to pass validation, reducing audit quality.","suggested_fix":"After containment check for wildcards, optionally use glob library to check if pattern matches at least one file: const matches = glob.sync(finding.file, {cwd: repoRoot}); if (matches.length === 0) { issues.push({type: 'WILDCARD_NO_MATCH', ...}) }","acceptance_tests":["Script warns when wildcard patterns match zero files","Audit findings with typo'd wildcards are flagged during validation"],"file":"scripts/validate-audit.js","line":370,"description":"validateFilePath() checks wildcard patterns (line 370-383) by validating only the prefix path for containment, but doesn't verify if the pattern matches any actual files. A finding with file='src/*.js' passes validation even if no such files exist. This allows ineffective or typo'd patterns to pass validation, reducing audit quality.","recommendation":"After containment check for wildcards, optionally use glob library to check if pattern matches at least one file: const matches = glob.sync(finding.file, {cwd: repoRoot}); if (matches.length === 0) { issues.push({type: 'WILDCARD_NO_MATCH', ...}) }","id":"process::scripts/validate-audit.js::wildcard-no-existence-check"}
{"category":"process","title":"Enhancement: generate-documentation-index.js - no visibility into skipped links","fingerprint":"process::scripts/generate-documentation-index.js::skipped-links-invisible","severity":"S3","effort":"E1","confidence":"MEDIUM","files":["scripts/generate-documentation-index.js:417"],"why_it_matters":"extractLinks() silently skips links that fail path containment (line 422-424) or URL decoding (line 401-404). In verbose mode, there's no count or warning about how many links were skipped. Users can't tell if their documentation has broken links attempting path traversal or malformed URLs, reducing the index quality.","suggested_fix":"Add counter for skipped links and log in verbose mode: let skipped = 0; ... if (resolvedPath === null) { skipped++; if (verbose) logVerbose(`Skipped link in ${currentFile}: ${href} (path traversal)`); continue; } ... if (verbose && skipped > 0) log(`Skipped ${skipped} invalid links in ${currentFile}`)","acceptance_tests":["Script reports count of skipped links in verbose mode","Users can identify documents with path traversal or malformed link attempts"],"file":"scripts/generate-documentation-index.js","line":417,"description":"extractLinks() silently skips links that fail path containment (line 422-424) or URL decoding (line 401-404). In verbose mode, there's no count or warning about how many links were skipped. Users can't tell if their documentation has broken links attempting path traversal or malformed URLs, reducing the index quality.","recommendation":"Add counter for skipped links and log in verbose mode: let skipped = 0; ... if (resolvedPath === null) { skipped++; if (verbose) logVerbose(`Skipped link in ${currentFile}: ${href} (path traversal)`); continue; } ... if (verbose && skipped > 0) log(`Skipped ${skipped} invalid links in ${currentFile}`)","id":"process::scripts/generate-documentation-index.js::skipped-links-invisible"}
{"category":"process","title":"Enhancement: check-pattern-compliance.js - silent filtering of user-provided files","fingerprint":"process::scripts/check-pattern-compliance.js::silent-file-filtering","severity":"S3","effort":"E1","confidence":"MEDIUM","files":["scripts/check-pattern-compliance.js:494"],"why_it_matters":"getFilesToCheck() with explicit FILES argument (line 494-508) applies filtering (path validation, existence checks, global excludes) that can reduce the list to empty. If user provides 'node scripts/check-pattern-compliance.js file1.js file2.js' but both are excluded, the script exits with 'No files to check' without explaining why their specified files were ignored. This is confusing user experience.","suggested_fix":"Track filtering reasons and report them: const filtered = FILES.filter(...).map((f) => ({file: f, reason: null})); // Track reasons during filtering, then: if (filtered.length === 0 && FILES.length > 0) { console.log(`Warning: All ${FILES.length} specified files were excluded`); }","acceptance_tests":["Script explains why user-specified files were filtered out","Users understand difference between 'no files specified' and 'files excluded by rules'"],"file":"scripts/check-pattern-compliance.js","line":494,"description":"getFilesToCheck() with explicit FILES argument (line 494-508) applies filtering (path validation, existence checks, global excludes) that can reduce the list to empty. If user provides 'node scripts/check-pattern-compliance.js file1.js file2.js' but both are excluded, the script exits with 'No files to check' without explaining why their specified files were ignored. This is confusing user experience.","recommendation":"Track filtering reasons and report them: const filtered = FILES.filter(...).map((f) => ({file: f, reason: null})); // Track reasons during filtering, then: if (filtered.length === 0 && FILES.length > 0) { console.log(`Warning: All ${FILES.length} specified files were excluded`); }","id":"process::scripts/check-pattern-compliance.js::silent-file-filtering"}
{"category":"process","title":"Bug: aggregate-audit-findings.js - potential long-running operation with no progress indication","fingerprint":"process::scripts/aggregate-audit-findings.js::no-progress-feedback","severity":"S3","effort":"E2","confidence":"MEDIUM","files":["scripts/aggregate-audit-findings.js:1446"],"why_it_matters":"aggregate() performs complex multi-pass deduplication (lines 1344-1402), cross-referencing (lines 1518-1544), and markdown generation on potentially thousands of findings. In non-verbose mode, there's no progress indication. If processing takes minutes or hangs, users can't tell if the script is working or frozen, leading to premature cancellation or confusion.","suggested_fix":"Add progress indicators for long operations: console.log('Phase 3: Deduplicating findings...'); let passCount = 0; while (didMerge && passCount < MAX_PASSES) { passCount++; if (passCount % 2 === 0) process.stdout.write('.'); ... } console.log(` (${passCount} passes)`)","acceptance_tests":["Script provides progress feedback during long-running operations","Users can distinguish between hung script and slow processing"],"file":"scripts/aggregate-audit-findings.js","line":1446,"description":"aggregate() performs complex multi-pass deduplication (lines 1344-1402), cross-referencing (lines 1518-1544), and markdown generation on potentially thousands of findings. In non-verbose mode, there's no progress indication. If processing takes minutes or hangs, users can't tell if the script is working or frozen, leading to premature cancellation or confusion.","recommendation":"Add progress indicators for long operations: console.log('Phase 3: Deduplicating findings...'); let passCount = 0; while (didMerge && passCount < MAX_PASSES) { passCount++; if (passCount % 2 === 0) process.stdout.write('.'); ... } console.log(` (${passCount} passes)`)","id":"process::scripts/aggregate-audit-findings.js::no-progress-feedback"}
