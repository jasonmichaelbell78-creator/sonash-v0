{"category":"process","title":"Ineffective: audit-s0s1-validator defaults to WARN mode","fingerprint":"process::.claude/hooks/audit-s0s1-validator.js::always-warn","severity":"S2","effort":"E1","confidence":"HIGH","files":[".claude/hooks/audit-s0s1-validator.js:21"],"why_it_matters":"S0/S1 audit findings require strict validation but hook defaults to non-blocking WARN mode, allowing invalid findings to be written. The hook only blocks if AUDIT_S0S1_MODE=BLOCK is explicitly set, which is not the default.","suggested_fix":"Change default mode to BLOCK. Move to WARN mode as opt-out (AUDIT_S0S1_MODE=WARN) rather than opt-in blocking. Rationale: S0/S1 findings represent critical/high severity issues that must have proper verification_steps - this should be enforced by default.","acceptance_tests":["Default mode blocks invalid S0/S1 findings","Hook exits with code 1 when violations found","AUDIT_S0S1_MODE=WARN environment variable can opt-out to warnings"],"file":".claude/hooks/audit-s0s1-validator.js","line":21,"description":"S0/S1 audit findings require strict validation but hook defaults to non-blocking WARN mode, allowing invalid findings to be written. The hook only blocks if AUDIT_S0S1_MODE=BLOCK is explicitly set, which is not the default.","recommendation":"Change default mode to BLOCK. Move to WARN mode as opt-out (AUDIT_S0S1_MODE=WARN) rather than opt-in blocking. Rationale: S0/S1 findings represent critical/high severity issues that must have proper verification_steps - this should be enforced by default.","id":"process::.claude/hooks/audit-s0s1-validator.js::always-warn"}
{"category":"process","title":"Ineffective: pattern-check hook never blocks violations","fingerprint":"process::.claude/hooks/pattern-check.js::always-succeeds","severity":"S2","effort":"E1","confidence":"HIGH","files":[".claude/hooks/pattern-check.js:221"],"why_it_matters":"Pattern compliance hook always exits with 'ok' (line 221) even when violations are detected. Warnings are shown but violations don't prevent writes. This makes the hook informational noise rather than an enforcement mechanism.","suggested_fix":"Implement severity-based blocking: Block on critical (ðŸ”´) pattern violations, warn on non-critical. Add PATTERN_CHECK_MODE env var for gradual rollout (WARN/BLOCK), similar to audit-s0s1-validator but default to BLOCK for critical patterns. Update error message to indicate operation was blocked.","acceptance_tests":["Hook blocks writes containing critical pattern violations","Hook exits with code 1 for critical violations","Non-critical violations show warnings but don't block","PATTERN_CHECK_MODE=WARN allows opt-out"],"file":".claude/hooks/pattern-check.js","line":221,"description":"Pattern compliance hook always exits with 'ok' (line 221) even when violations are detected. Warnings are shown but violations don't prevent writes. This makes the hook informational noise rather than an enforcement mechanism.","recommendation":"Implement severity-based blocking: Block on critical (ðŸ”´) pattern violations, warn on non-critical. Add PATTERN_CHECK_MODE env var for gradual rollout (WARN/BLOCK), similar to audit-s0s1-validator but default to BLOCK for critical patterns. Update error message to indicate operation was blocked.","id":"process::.claude/hooks/pattern-check.js::always-succeeds"}
{"category":"process","title":"Ineffective: Small file bypass in pattern-check","fingerprint":"process::.claude/hooks/pattern-check.js::small-file-bypass","severity":"S3","effort":"E2","confidence":"HIGH","files":[".claude/hooks/pattern-check.js:138"],"why_it_matters":"Pattern check skips files under 100 lines (line 138-165). This creates perverse incentive to keep files artificially small to avoid pattern checks. Critical patterns like hardcoded secrets or auth bypasses can exist in small files.","suggested_fix":"Remove small file bypass or make it configurable. Alternative: Run lightweight pattern checks on all files, reserve expensive checks for large files. Critical security patterns (secrets, auth) should always run regardless of file size. Document rationale if bypass is intentional performance optimization.","acceptance_tests":["Critical security patterns checked on all file sizes","Performance acceptable for files under 100 lines","Pattern check completes in under 500ms for small files"],"file":".claude/hooks/pattern-check.js","line":138,"description":"Pattern check skips files under 100 lines (line 138-165). This creates perverse incentive to keep files artificially small to avoid pattern checks. Critical patterns like hardcoded secrets or auth bypasses can exist in small files.","recommendation":"Remove small file bypass or make it configurable. Alternative: Run lightweight pattern checks on all files, reserve expensive checks for large files. Critical security patterns (secrets, auth) should always run regardless of file size. Document rationale if bypass is intentional performance optimization.","id":"process::.claude/hooks/pattern-check.js::small-file-bypass"}
{"category":"process","title":"Ineffective: Pre-commit bypass conditions too easy","fingerprint":"process::.husky/pre-commit::excessive-bypasses","severity":"S2","effort":"E2","confidence":"HIGH","files":[".husky/pre-commit:46",".husky/pre-commit:122",".husky/pre-commit:137",".husky/pre-commit:158",".husky/pre-commit:193",".husky/pre-commit:245"],"why_it_matters":"Pre-commit hook has 6 easy bypass conditions via environment variables: SKIP_TESTS, SKIP_CROSS_DOC_CHECK, SKIP_DOC_HEADER_CHECK, SKIP_AUDIT_VALIDATION, SKIP_DEBT_VALIDATION, SKIP_DOC_INDEX_CHECK. No audit trail or rate limiting. Developers can habitually bypass checks without visibility.","suggested_fix":"1. Log all bypasses to .claude/hooks/bypass-audit.jsonl with timestamp, user, check type, reason. 2. Require SKIP_REASON environment variable for all bypasses. 3. Add bypass budget: warn if same user bypasses >3 times in 7 days. 4. Make some checks non-bypassable (e.g., SKIP_AUDIT_VALIDATION for S0/S1). 5. Pre-push hook should fail if too many pre-commit bypasses detected.","acceptance_tests":["All bypasses logged to bypass-audit.jsonl","SKIP_REASON required for bypass","Warning shown when bypass budget exceeded","S0/S1 audit validation cannot be bypassed"],"file":".husky/pre-commit","line":46,"description":"Pre-commit hook has 6 easy bypass conditions via environment variables: SKIP_TESTS, SKIP_CROSS_DOC_CHECK, SKIP_DOC_HEADER_CHECK, SKIP_AUDIT_VALIDATION, SKIP_DEBT_VALIDATION, SKIP_DOC_INDEX_CHECK. No audit trail or rate limiting. Developers can habitually bypass checks without visibility.","recommendation":"1. Log all bypasses to .claude/hooks/bypass-audit.jsonl with timestamp, user, check type, reason. 2. Require SKIP_REASON environment variable for all bypasses. 3. Add bypass budget: warn if same user bypasses >3 times in 7 days. 4. Make some checks non-bypassable (e.g., SKIP_AUDIT_VALIDATION for S0/S1). 5. Pre-push hook should fail if too many pre-commit bypasses detected.","id":"process::.husky/pre-commit::excessive-bypasses"}
{"category":"process","title":"Ineffective: Network failures treated as success in pre-push","fingerprint":"process::.husky/pre-push::network-failure-success","severity":"S3","effort":"E1","confidence":"HIGH","files":[".husky/pre-push:107"],"why_it_matters":"npm audit check (lines 92-118) treats network errors as success - if npm registry is unreachable, check is skipped silently. Attacker with network control could bypass vulnerability detection. Same pattern could exist in other network-dependent checks.","suggested_fix":"Distinguish between 'no vulnerabilities' and 'cannot verify'. For network failures: 1. Show clear warning that check was skipped. 2. Log to bypass audit trail. 3. Consider making network checks blocking by default (fail closed), with ALLOW_NETWORK_SKIP=1 opt-out. 4. Cache last successful audit result and warn if stale (>7 days).","acceptance_tests":["Network failures show prominent warning","Bypassed network checks logged to audit trail","Hook fails by default on network errors unless ALLOW_NETWORK_SKIP=1","Last successful audit timestamp cached"],"file":".husky/pre-push","line":107,"description":"npm audit check (lines 92-118) treats network errors as success - if npm registry is unreachable, check is skipped silently. Attacker with network control could bypass vulnerability detection. Same pattern could exist in other network-dependent checks.","recommendation":"Distinguish between 'no vulnerabilities' and 'cannot verify'. For network failures: 1. Show clear warning that check was skipped. 2. Log to bypass audit trail. 3. Consider making network checks blocking by default (fail closed), with ALLOW_NETWORK_SKIP=1 opt-out. 4. Cache last successful audit result and warn if stale (>7 days).","id":"process::.husky/pre-push::network-failure-success"}
{"category":"process","title":"Ineffective: check-write-requirements POST-TASK not enforced","fingerprint":"process::.claude/hooks/check-write-requirements.js::post-task-not-enforced","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".claude/hooks/check-write-requirements.js:72",".claude/hooks/check-write-requirements.js:80",".claude/hooks/check-write-requirements.js:86"],"why_it_matters":"Hook outputs 'POST-TASK: MUST run code-reviewer' and 'POST-TASK: SHOULD run test-engineer' but these are suggestions only. No enforcement mechanism. No tracking whether suggested agents actually ran. Messages become background noise that users ignore.","suggested_fix":"1. Track suggested agents in .claude/state/required-agents.json. 2. Pre-commit hook checks this file and warns/blocks if required agents not invoked. 3. Agent invocation hooks (track-agent-invocation.js) mark agents as completed. 4. MUST requirements block commit, SHOULD requirements warn. 5. Clear with AGENT_REVIEW_COMPLETE=1 override with reason logging.","acceptance_tests":["Required agents tracked in state file","Pre-commit blocks if MUST requirements not met","Agent completion marks requirements satisfied","Override requires reason and logs to audit trail"],"file":".claude/hooks/check-write-requirements.js","line":72,"description":"Hook outputs 'POST-TASK: MUST run code-reviewer' and 'POST-TASK: SHOULD run test-engineer' but these are suggestions only. No enforcement mechanism. No tracking whether suggested agents actually ran. Messages become background noise that users ignore.","recommendation":"1. Track suggested agents in .claude/state/required-agents.json. 2. Pre-commit hook checks this file and warns/blocks if required agents not invoked. 3. Agent invocation hooks (track-agent-invocation.js) mark agents as completed. 4. MUST requirements block commit, SHOULD requirements warn. 5. Clear with AGENT_REVIEW_COMPLETE=1 override with reason logging.","id":"process::.claude/hooks/check-write-requirements.js::post-task-not-enforced"}
{"category":"process","title":"Ineffective: component-size-check always succeeds","fingerprint":"process::.claude/hooks/component-size-check.js::always-ok","severity":"S3","effort":"E1","confidence":"HIGH","files":[".claude/hooks/component-size-check.js:142"],"why_it_matters":"Hook warns about oversized components (>300 lines) but always exits with 'ok' (line 142). Warnings are easily ignored. No escalation for egregiously large files (e.g., 1000+ lines). Size limits become suggestions rather than architectural constraints.","suggested_fix":"Implement tiered enforcement: 1. >300 lines: WARN (current behavior). 2. >500 lines: WARN with stronger message, add to tech debt tracker. 3. >750 lines: BLOCK unless ALLOW_LARGE_COMPONENT=1 with required explanation. 4. Track component sizes over time - warn if file growing rapidly (>50 lines/week). Form components keep higher limits but require Form suffix in filename.","acceptance_tests":["Files >750 lines blocked by default","Override requires ALLOW_LARGE_COMPONENT=1 and logs reason","Growing files detected and warned","Size metrics tracked for trends"],"file":".claude/hooks/component-size-check.js","line":142,"description":"Hook warns about oversized components (>300 lines) but always exits with 'ok' (line 142). Warnings are easily ignored. No escalation for egregiously large files (e.g., 1000+ lines). Size limits become suggestions rather than architectural constraints.","recommendation":"Implement tiered enforcement: 1. >300 lines: WARN (current behavior). 2. >500 lines: WARN with stronger message, add to tech debt tracker. 3. >750 lines: BLOCK unless ALLOW_LARGE_COMPONENT=1 with required explanation. 4. Track component sizes over time - warn if file growing rapidly (>50 lines/week). Form components keep higher limits but require Form suffix in filename.","id":"process::.claude/hooks/component-size-check.js::always-ok"}
{"category":"process","title":"Ineffective: agent-trigger-enforcer Phase 2/3 not implemented","fingerprint":"process::.claude/hooks/agent-trigger-enforcer.js::phase-not-implemented","severity":"S3","effort":"E3","confidence":"HIGH","files":[".claude/hooks/agent-trigger-enforcer.js:295"],"why_it_matters":"Hook shows phase transition notifications (lines 219-234) recommending upgrade to Phase 2 WARN or Phase 3 BLOCK modes, but these phases are not implemented. Hook always succeeds regardless of phase setting (line 295). Phase transitions are notification theater without actual behavior change.","suggested_fix":"Implement phase enforcement logic: Phase 1 (current): Suggest agents. Phase 2: Warn prominently if required agents not invoked, track to pending-reviews.json. Phase 3: Block Write/Edit if required agent not invoked this session, require SKIP_AGENT_CHECK=1 override with reason. Use state.phase to control behavior. Document phase upgrade process and rollback plan.","acceptance_tests":["Phase 2 creates prominent warnings and tracks violations","Phase 3 blocks operations until agent invoked","Phase config changeable via state file","Rollback to lower phase preserves existing state"],"file":".claude/hooks/agent-trigger-enforcer.js","line":295,"description":"Hook shows phase transition notifications (lines 219-234) recommending upgrade to Phase 2 WARN or Phase 3 BLOCK modes, but these phases are not implemented. Hook always succeeds regardless of phase setting (line 295). Phase transitions are notification theater without actual behavior change.","recommendation":"Implement phase enforcement logic: Phase 1 (current): Suggest agents. Phase 2: Warn prominently if required agents not invoked, track to pending-reviews.json. Phase 3: Block Write/Edit if required agent not invoked this session, require SKIP_AGENT_CHECK=1 override with reason. Use state.phase to control behavior. Document phase upgrade process and rollback plan.","id":"process::.claude/hooks/agent-trigger-enforcer.js::phase-not-implemented"}
{"category":"process","title":"Ineffective: large-context-warning warningShown flag prevents repeated warnings","fingerprint":"process::.claude/hooks/large-context-warning.js::warning-once","severity":"S4","effort":"E1","confidence":"HIGH","files":[".claude/hooks/large-context-warning.js:146"],"why_it_matters":"Hook warns when >15 files read in session (line 146-153) but sets warningShown flag to prevent repeated warnings. After first warning, can read 50+ more files without additional feedback. Warning effectiveness degrades over long sessions. State resets after 30 minutes, allowing warning suppression.","suggested_fix":"Change warning strategy: 1. Warn at thresholds: 15, 30, 50, 100 files (escalating urgency). 2. Show file count in status bar if available. 3. After 30 files, suggest /save-context every 5 files. 4. After 50 files, warn that compaction likely soon. 5. Track context pressure score (files + total lines) not just file count. Don't use warningShown flag for suppression.","acceptance_tests":["Multiple warnings at escalating thresholds","Warning shown every 5 files after 30 files","Context pressure score calculated from files + lines","No single warningShown flag suppressing all warnings"],"file":".claude/hooks/large-context-warning.js","line":146,"description":"Hook warns when >15 files read in session (line 146-153) but sets warningShown flag to prevent repeated warnings. After first warning, can read 50+ more files without additional feedback. Warning effectiveness degrades over long sessions. State resets after 30 minutes, allowing warning suppression.","recommendation":"Change warning strategy: 1. Warn at thresholds: 15, 30, 50, 100 files (escalating urgency). 2. Show file count in status bar if available. 3. After 30 files, suggest /save-context every 5 files. 4. After 50 files, warn that compaction likely soon. 5. Track context pressure score (files + total lines) not just file count. Don't use warningShown flag for suppression.","id":"process::.claude/hooks/large-context-warning.js::warning-once"}
{"category":"process","title":"Ineffective: check-remote-session-context always succeeds","fingerprint":"process::.claude/hooks/check-remote-session-context.js::informational-only","severity":"S4","effort":"E2","confidence":"MEDIUM","files":[".claude/hooks/check-remote-session-context.js:32",".claude/hooks/check-remote-session-context.js:179"],"why_it_matters":"Hook detects when remote branches have newer session context (higher session counter) but always exits with 'ok' even when mismatch found. Warning shown (lines 163-176) but no enforcement. Developers can ignore and work on stale context, leading to lost work or duplicate sessions.","suggested_fix":"Make blocking when session counter difference >5 (likely working on very stale branch): 1. Show warning and suggest merge for small differences (1-2 sessions). 2. Block session start for large differences (>5 sessions) unless ALLOW_STALE_CONTEXT=1. 3. Offer auto-merge or checkout options. 4. Track if user repeatedly ignores warnings (>3 times in 14 days) and escalate to block. 5. continueOnError: true in settings keeps non-blocking for fetch failures.","acceptance_tests":["Large session counter differences block session start","Small differences show actionable warning with merge command","Override requires ALLOW_STALE_CONTEXT=1 with reason","Repeated warning ignoring tracked and escalated"],"file":".claude/hooks/check-remote-session-context.js","line":32,"description":"Hook detects when remote branches have newer session context (higher session counter) but always exits with 'ok' even when mismatch found. Warning shown (lines 163-176) but no enforcement. Developers can ignore and work on stale context, leading to lost work or duplicate sessions.","recommendation":"Make blocking when session counter difference >5 (likely working on very stale branch): 1. Show warning and suggest merge for small differences (1-2 sessions). 2. Block session start for large differences (>5 sessions) unless ALLOW_STALE_CONTEXT=1. 3. Offer auto-merge or checkout options. 4. Track if user repeatedly ignores warnings (>3 times in 14 days) and escalate to block. 5. continueOnError: true in settings keeps non-blocking for fetch failures.","id":"process::.claude/hooks/check-remote-session-context.js::informational-only"}
{"category":"process","title":"Ineffective: audit-s0s1-validator allows parse errors","fingerprint":"process::.claude/hooks/audit-s0s1-validator.js::parse-error-evasion","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".claude/hooks/audit-s0s1-validator.js:84"],"why_it_matters":"When JSONL parsing fails (lines 79-86), malformed lines are marked with _parseError but validation continues. If S0/S1 finding is in a malformed line, it escapes validation. Attacker or lazy developer could intentionally malform S0/S1 entries to bypass strict verification requirements.","suggested_fix":"Fail validation if any parse errors found in audit file: 1. Count parse errors during JSONL parsing. 2. If parseErrorCount > 0, block with message: 'JSONL file has malformed entries - fix syntax before committing'. 3. Show first 3 malformed lines with line numbers. 4. No override - proper JSON is non-negotiable for audit data. 5. Validate that all S0/S1 findings were successfully parsed (cross-check line count of S0/S1 severity strings vs parsed S0/S1 objects).","acceptance_tests":["Hook blocks files with any JSONL parse errors","Malformed line numbers and content shown in error","All S0/S1 lines confirmed parseable","No bypass for malformed audit files"],"file":".claude/hooks/audit-s0s1-validator.js","line":84,"description":"When JSONL parsing fails (lines 79-86), malformed lines are marked with _parseError but validation continues. If S0/S1 finding is in a malformed line, it escapes validation. Attacker or lazy developer could intentionally malform S0/S1 entries to bypass strict verification requirements.","recommendation":"Fail validation if any parse errors found in audit file: 1. Count parse errors during JSONL parsing. 2. If parseErrorCount > 0, block with message: 'JSONL file has malformed entries - fix syntax before committing'. 3. Show first 3 malformed lines with line numbers. 4. No override - proper JSON is non-negotiable for audit data. 5. Validate that all S0/S1 findings were successfully parsed (cross-check line count of S0/S1 severity strings vs parsed S0/S1 objects).","id":"process::.claude/hooks/audit-s0s1-validator.js::parse-error-evasion"}
{"category":"process","title":"Ineffective: commit-tracker continueOnError makes failures silent","fingerprint":"process::.claude/hooks/commit-tracker.js::continue-on-error","severity":"S4","effort":"E1","confidence":"MEDIUM","files":[".claude/settings.json:251"],"why_it_matters":"commit-tracker.js has continueOnError: true (settings.json line 251) so failures are silent. If state files become corrupted or filesystem has issues, commit tracking silently breaks. Compaction resilience (Session #138) depends on this tracking but failures are invisible.","suggested_fix":"Keep continueOnError: true (appropriate for non-critical tracking) but add failure detection and alerting: 1. If commit-tracker fails 3+ times in session, show warning. 2. Log failures to .claude/hooks/hook-failures.jsonl with timestamp, hook name, error. 3. Session-start hook checks failure log and warns if recent failures (last 7 days). 4. Health check command to verify state files readable/writable. Document that continueOnError is intentional but monitored.","acceptance_tests":["Repeated failures trigger warning","Failures logged to hook-failures.jsonl","Session start checks recent hook failures","Health check command validates state files"],"file":".claude/settings.json","line":251,"description":"commit-tracker.js has continueOnError: true (settings.json line 251) so failures are silent. If state files become corrupted or filesystem has issues, commit tracking silently breaks. Compaction resilience (Session #138) depends on this tracking but failures are invisible.","recommendation":"Keep continueOnError: true (appropriate for non-critical tracking) but add failure detection and alerting: 1. If commit-tracker fails 3+ times in session, show warning. 2. Log failures to .claude/hooks/hook-failures.jsonl with timestamp, hook name, error. 3. Session-start hook checks failure log and warns if recent failures (last 7 days). 4. Health check command to verify state files readable/writable. Document that continueOnError is intentional but monitored.","id":"process::.claude/hooks/commit-tracker.js::continue-on-error"}
{"category":"process","title":"Ineffective: Pre-push SKIP_TRIGGERS bypass has no budget","fingerprint":"process::.husky/pre-push::skip-triggers","severity":"S3","effort":"E2","confidence":"HIGH","files":[".husky/pre-push:123"],"why_it_matters":"SKIP_TRIGGERS=1 bypasses event-based trigger checks (lines 123-152) including security audits. Override logged to scripts/log-override.js but no enforcement of bypass budget. Developer could use SKIP_TRIGGERS=1 on every push to avoid all trigger-based checks including security scans.","suggested_fix":"Implement bypass budget for SKIP_TRIGGERS: 1. Track bypass frequency in .claude/state/bypass-budget.json (user, timestamp, reason). 2. Allow 3 bypasses per 7 days without warning. 3. Warn at 4-5 bypasses in 7 days. 4. Block at 6+ bypasses in 7 days unless BYPASS_BUDGET_OVERRIDE=1 (requires escalation approval or explicit reason). 5. Reset budget weekly. 6. Distinguish security trigger bypasses (stricter budget: 1 per 7 days) from other triggers.","acceptance_tests":["Bypass budget tracked per user","Warnings at 4-5 bypasses in 7 days","Block at 6+ bypasses requires override","Security bypasses have stricter budget (1/week)"],"file":".husky/pre-push","line":123,"description":"SKIP_TRIGGERS=1 bypasses event-based trigger checks (lines 123-152) including security audits. Override logged to scripts/log-override.js but no enforcement of bypass budget. Developer could use SKIP_TRIGGERS=1 on every push to avoid all trigger-based checks including security scans.","recommendation":"Implement bypass budget for SKIP_TRIGGERS: 1. Track bypass frequency in .claude/state/bypass-budget.json (user, timestamp, reason). 2. Allow 3 bypasses per 7 days without warning. 3. Warn at 4-5 bypasses in 7 days. 4. Block at 6+ bypasses in 7 days unless BYPASS_BUDGET_OVERRIDE=1 (requires escalation approval or explicit reason). 5. Reset budget weekly. 6. Distinguish security trigger bypasses (stricter budget: 1 per 7 days) from other triggers.","id":"process::.husky/pre-push::skip-triggers"}
