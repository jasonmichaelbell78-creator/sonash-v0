{"category":"process","title":"Error handling: Empty catch blocks swallow errors in gsd-check-update.js","fingerprint":"process::.claude/hooks/global/gsd-check-update.js::empty-catch-blocks","severity":"S1","effort":"E1","confidence":"HIGH","files":[".claude/hooks/global/gsd-check-update.js:38",".claude/hooks/global/gsd-check-update.js:43"],"why_it_matters":"Silent failures in version checking hide network issues and file read errors, preventing users from knowing updates are available","suggested_fix":"Log errors to stderr or a debug log file. Example: catch (e) { console.error('Failed to check GSD version:', e.message); }","acceptance_tests":["Errors are logged when version file is unreadable","Errors are logged when npm registry is unreachable","Debug information helps troubleshoot update check failures"],"file":".claude/hooks/global/gsd-check-update.js","line":38,"description":"Silent failures in version checking hide network issues and file read errors, preventing users from knowing updates are available","recommendation":"Log errors to stderr or a debug log file. Example: catch (e) { console.error('Failed to check GSD version:', e.message); }","id":"process::.claude/hooks/global/gsd-check-update.js::empty-catch-blocks","evidence":[{"type":"code_reference","detail":".claude/hooks/global/gsd-check-update.js:38"},{"type":"description","detail":"Silent failures in version checking hide network issues and file read errors, preventing users from knowing updates are available"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".claude/hooks/global/gsd-check-update.js:38"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".claude/hooks/global/gsd-check-update.js:38"}}}
{"category":"process","title":"Error handling: 200+ empty catch blocks across hooks and scripts","fingerprint":"process::hooks-scripts::empty-catch-pattern","severity":"S1","effort":"E3","confidence":"HIGH","files":[".claude/hooks/component-size-check.js:47",".claude/hooks/component-size-check.js:111",".claude/hooks/typescript-strict-check.js:45",".claude/hooks/typescript-strict-check.js:109",".claude/hooks/track-agent-invocation.js:48",".claude/hooks/track-agent-invocation.js:81",".claude/hooks/compaction-handoff.js:66",".claude/hooks/compaction-handoff.js:82","scripts/validate-canon-schema.js:391","scripts/validate-audit.js:101","scripts/phase-complete-check.js:76"],"why_it_matters":"Silent failures hide real problems: JSON parse errors, file system issues, permission problems. Debugging becomes impossible when errors are swallowed without any logging","suggested_fix":"Add minimal error logging: catch (err) { console.error('Operation failed:', err.message); }. For non-critical operations, at least log to debug output","acceptance_tests":["File operation failures are logged","JSON parse errors are reported with context","Permission errors provide actionable guidance"],"file":".claude/hooks/component-size-check.js","line":47,"description":"Silent failures hide real problems: JSON parse errors, file system issues, permission problems. Debugging becomes impossible when errors are swallowed without any logging","recommendation":"Add minimal error logging: catch (err) { console.error('Operation failed:', err.message); }. For non-critical operations, at least log to debug output","id":"process::hooks-scripts::empty-catch-pattern","evidence":[{"type":"code_reference","detail":".claude/hooks/component-size-check.js:47"},{"type":"description","detail":"Silent failures hide real problems: JSON parse errors, file system issues, permission problems. Debugging becomes impossible when errors are swallowed without any logging"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".claude/hooks/component-size-check.js:47"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".claude/hooks/component-size-check.js:47"}}}
{"category":"process","title":"Error handling: Hook validation exits with 0 on security failures","fingerprint":"process::hooks::exit-code-on-security-fail","severity":"S2","effort":"E2","confidence":"HIGH","files":[".claude/hooks/typescript-strict-check.js:28",".claude/hooks/typescript-strict-check.js:72",".claude/hooks/component-size-check.js:32",".claude/hooks/track-agent-invocation.js:31"],"why_it_matters":"Security checks that detect path traversal or invalid input exit with 0 (success), making it appear operations succeeded when they should have been rejected. This could mask security issues","suggested_fix":"Distinguish between 'not applicable' (exit 0) and 'validation failed' (exit 1). When detecting security issues like path traversal, exit with non-zero code and log the security violation","acceptance_tests":["Path traversal attempts result in exit code 1","Invalid arguments result in exit code 1","Log messages clearly indicate security rejections","Normal 'not applicable' cases still exit 0"],"file":".claude/hooks/typescript-strict-check.js","line":28,"description":"Security checks that detect path traversal or invalid input exit with 0 (success), making it appear operations succeeded when they should have been rejected. This could mask security issues","recommendation":"Distinguish between 'not applicable' (exit 0) and 'validation failed' (exit 1). When detecting security issues like path traversal, exit with non-zero code and log the security violation","id":"process::hooks::exit-code-on-security-fail"}
{"category":"process","title":"Error handling: readFileSync without try/catch in multiple scripts","fingerprint":"process::scripts::unprotected-readfilesync","severity":"S1","effort":"E2","confidence":"HIGH","files":["scripts/verify-sonar-phase.js:134","scripts/verify-sonar-phase.js:213","scripts/validate-skill-config.js:105","scripts/update-readme-status.js:71"],"why_it_matters":"Unprotected file reads cause uncaught exceptions that crash scripts. Users see stack traces instead of helpful error messages. ENOENT errors don't explain what file was missing or why","suggested_fix":"Wrap all readFileSync calls in try/catch with helpful error messages. Example: try { content = fs.readFileSync(file, 'utf8'); } catch (err) { console.error(`Failed to read config file: ${err.message}\\nPlease ensure the file exists and is readable.`); process.exit(1); }","acceptance_tests":["Missing files produce helpful error messages","Permission errors explain what access is needed","Error messages suggest corrective actions","Scripts exit cleanly with appropriate exit codes"],"file":"scripts/verify-sonar-phase.js","line":134,"description":"Unprotected file reads cause uncaught exceptions that crash scripts. Users see stack traces instead of helpful error messages. ENOENT errors don't explain what file was missing or why","recommendation":"Wrap all readFileSync calls in try/catch with helpful error messages. Example: try { content = fs.readFileSync(file, 'utf8'); } catch (err) { console.error(`Failed to read config file: ${err.message}\\nPlease ensure the file exists and is readable.`); process.exit(1); }","id":"process::scripts::unprotected-readfilesync","evidence":[{"type":"code_reference","detail":"scripts/verify-sonar-phase.js:134"},{"type":"description","detail":"Unprotected file reads cause uncaught exceptions that crash scripts. Users see stack traces instead of helpful error messages. ENOENT errors don't explain what file was missing or why"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/verify-sonar-phase.js:134"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/verify-sonar-phase.js:134"}}}
{"category":"process","title":"Error handling: execSync without timeout or error handling","fingerprint":"process::scripts::execsync-no-timeout","severity":"S1","effort":"E2","confidence":"HIGH","files":["scripts/validate-audit.js:651",".claude/hooks/compaction-handoff.js:97",".claude/hooks/session-start.js:49"],"why_it_matters":"execSync calls without timeout can hang indefinitely if child processes freeze. Missing error handling means command failures crash the script with cryptic errors","suggested_fix":"Always include timeout option and wrap in try/catch. Example: try { const output = execSync(cmd, { timeout: 10000, encoding: 'utf8' }); } catch (err) { if (err.killed) { console.error('Command timed out after 10s'); } else { console.error('Command failed:', err.message); } process.exit(1); }","acceptance_tests":["Commands timeout after reasonable duration","Timeout errors are clearly reported","Command failures include the command that failed","Exit codes distinguish timeout vs other failures"],"file":"scripts/validate-audit.js","line":651,"description":"execSync calls without timeout can hang indefinitely if child processes freeze. Missing error handling means command failures crash the script with cryptic errors","recommendation":"Always include timeout option and wrap in try/catch. Example: try { const output = execSync(cmd, { timeout: 10000, encoding: 'utf8' }); } catch (err) { if (err.killed) { console.error('Command timed out after 10s'); } else { console.error('Command failed:', err.message); } process.exit(1); }","id":"process::scripts::execsync-no-timeout","evidence":[{"type":"code_reference","detail":"scripts/validate-audit.js:651"},{"type":"description","detail":"execSync calls without timeout can hang indefinitely if child processes freeze. Missing error handling means command failures crash the script with cryptic errors"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/validate-audit.js:651"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/validate-audit.js:651"}}}
{"category":"process","title":"Error handling: Error messages expose full system paths","fingerprint":"process::scripts::path-exposure-in-errors","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/validate-audit.js:110","scripts/lib/security-helpers.js:107","scripts/lib/security-helpers.js:114","scripts/analyze-learning-effectiveness.js:223"],"why_it_matters":"Error messages that include full absolute paths expose system structure (/home/username/, /Users/name/projects/). In logs or error reports, this leaks potentially sensitive information about deployment structure","suggested_fix":"Use path.basename() or relative paths in error messages. Example: Instead of 'Audit file not found: /home/user/project/file.jsonl', use 'Audit file not found: file.jsonl (expected in docs/audits/)'","acceptance_tests":["Error messages use relative paths or basenames only","No /home/, /Users/, or drive letters in error output","Path context is still clear for debugging","Security-sensitive paths are never logged"],"file":"scripts/validate-audit.js","line":110,"description":"Error messages that include full absolute paths expose system structure (/home/username/, /Users/name/projects/). In logs or error reports, this leaks potentially sensitive information about deployment structure","recommendation":"Use path.basename() or relative paths in error messages. Example: Instead of 'Audit file not found: /home/user/project/file.jsonl', use 'Audit file not found: file.jsonl (expected in docs/audits/)'","id":"process::scripts::path-exposure-in-errors"}
{"category":"process","title":"Error handling: State file operations fail silently","fingerprint":"process::state-utils::silent-write-failures","severity":"S1","effort":"E1","confidence":"HIGH","files":[".claude/hooks/state-utils.js:75",".claude/hooks/track-agent-invocation.js:90",".claude/hooks/session-start.js:85"],"why_it_matters":"State persistence failures mean hooks lose track of session context, agent invocations, and compaction data. Silent failures leave the system in an inconsistent state without alerting anyone","suggested_fix":"writeState() should return false on failure but caller should check the return value. Example: if (!writeState(data)) { console.error('⚠️  Failed to save session state - data may be lost after compaction'); }","acceptance_tests":["Failed state writes produce visible warnings","Return values are checked by callers","Error messages explain impact (e.g., 'compaction may lose context')","Critical state failures exit non-zero"],"file":".claude/hooks/state-utils.js","line":75,"description":"State persistence failures mean hooks lose track of session context, agent invocations, and compaction data. Silent failures leave the system in an inconsistent state without alerting anyone","recommendation":"writeState() should return false on failure but caller should check the return value. Example: if (!writeState(data)) { console.error('⚠️  Failed to save session state - data may be lost after compaction'); }","id":"process::state-utils::silent-write-failures","evidence":[{"type":"code_reference","detail":".claude/hooks/state-utils.js:75"},{"type":"description","detail":"State persistence failures mean hooks lose track of session context, agent invocations, and compaction data. Silent failures leave the system in an inconsistent state without alerting anyone"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".claude/hooks/state-utils.js:75"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".claude/hooks/state-utils.js:75"}}}
{"category":"process","title":"Error handling: JSON.parse failures without validation context","fingerprint":"process::hooks::json-parse-no-context","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/verify-skill-usage.js:136",".claude/hooks/track-agent-invocation.js:45",".claude/hooks/typescript-strict-check.js:42"],"why_it_matters":"When JSON.parse fails in hooks, empty catch blocks hide what was being parsed and why it failed. Malformed hook arguments or corrupted state files become impossible to debug","suggested_fix":"Log parse failures with context. Example: catch (err) { console.error('Failed to parse hook arguments:', arg.substring(0, 100), err.message); return null; }","acceptance_tests":["Parse errors indicate what was being parsed","First 100 chars of malformed JSON are shown","Clear distinction between missing vs malformed data","Errors suggest how to fix the input"],"file":"scripts/verify-skill-usage.js","line":136,"description":"When JSON.parse fails in hooks, empty catch blocks hide what was being parsed and why it failed. Malformed hook arguments or corrupted state files become impossible to debug","recommendation":"Log parse failures with context. Example: catch (err) { console.error('Failed to parse hook arguments:', arg.substring(0, 100), err.message); return null; }","id":"process::hooks::json-parse-no-context"}
{"category":"process","title":"Error handling: Missing error messages in file write operations","fingerprint":"process::scripts::write-no-error-msg","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/update-readme-status.js:107",".claude/hooks/compaction-handoff.js:74",".claude/hooks/pre-compaction-save.js:87"],"why_it_matters":"writeFileSync failures (disk full, permission denied, read-only filesystem) crash without explaining what failed to write. Users can't tell if their data was saved or lost","suggested_fix":"Wrap writes in try/catch with descriptive errors. Example: try { fs.writeFileSync(file, data); } catch (err) { console.error(`Failed to write ${path.basename(file)}: ${err.code === 'ENOSPC' ? 'Disk full' : err.message}`); process.exit(1); }","acceptance_tests":["Write failures explain which file failed","Common errors (ENOSPC, EACCES) have user-friendly messages","Atomic write failures clean up temp files","Exit codes indicate write failure vs success"],"file":"scripts/update-readme-status.js","line":107,"description":"writeFileSync failures (disk full, permission denied, read-only filesystem) crash without explaining what failed to write. Users can't tell if their data was saved or lost","recommendation":"Wrap writes in try/catch with descriptive errors. Example: try { fs.writeFileSync(file, data); } catch (err) { console.error(`Failed to write ${path.basename(file)}: ${err.code === 'ENOSPC' ? 'Disk full' : err.message}`); process.exit(1); }","id":"process::scripts::write-no-error-msg"}
{"category":"process","title":"Error handling: continueOnError used appropriately in settings.json","fingerprint":"process::.claude/settings.json::continue-on-error-usage","severity":"S0","effort":"E0","confidence":"HIGH","files":[".claude/settings.json:24",".claude/settings.json:31",".claude/settings.json:250"],"why_it_matters":"continueOnError is correctly used for non-critical operations: remote branch checks (network may be unavailable), dashboard cleanup (dev-only), and commit tracking (metadata only). These should not block the workflow","suggested_fix":"No fix needed - usage is appropriate. These hooks enhance the workflow but aren't critical path","acceptance_tests":["Session starts even if remote branch check fails","Workflow continues if dashboard cleanup fails","Commit tracking failures don't block operations"],"file":".claude/settings.json","line":24,"description":"continueOnError is correctly used for non-critical operations: remote branch checks (network may be unavailable), dashboard cleanup (dev-only), and commit tracking (metadata only). These should not block the workflow","recommendation":"No fix needed - usage is appropriate. These hooks enhance the workflow but aren't critical path","id":"process::.claude/settings.json::continue-on-error-usage","evidence":[{"type":"code_reference","detail":".claude/settings.json:24"},{"type":"description","detail":"continueOnError is correctly used for non-critical operations: remote branch checks (network may be unavailable), dashboard cleanup (dev-only), and commit tracking (metadata only). These should not block the workflow"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".claude/settings.json:24"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".claude/settings.json:24"}}}
{"category":"process","title":"Error handling: Validation scripts exit 0 with violations in non-strict mode","fingerprint":"process::scripts/verify-skill-usage.js::exit-zero-with-violations","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/verify-skill-usage.js:232","scripts/verify-skill-usage.js:240","scripts/verify-skill-usage.js:261"],"why_it_matters":"verify-skill-usage.js exits 0 even when violations exist (non-strict mode). This makes CI integration confusing - the script reports issues but signals success. Violations may be ignored","suggested_fix":"Exit code should reflect presence of violations regardless of mode. Use --quiet to suppress output, not to change exit behavior. Example: if (violations.length > 0) process.exit(1); else process.exit(0);","acceptance_tests":["Script exits 1 when violations exist","--quiet suppresses output but preserves exit code","CI can rely on exit code to detect issues","Documentation explains exit code behavior"],"file":"scripts/verify-skill-usage.js","line":232,"description":"verify-skill-usage.js exits 0 even when violations exist (non-strict mode). This makes CI integration confusing - the script reports issues but signals success. Violations may be ignored","recommendation":"Exit code should reflect presence of violations regardless of mode. Use --quiet to suppress output, not to change exit behavior. Example: if (violations.length > 0) process.exit(1); else process.exit(0);","id":"process::scripts/verify-skill-usage.js::exit-zero-with-violations"}
{"category":"process","title":"Error handling: Multiple exit(0) calls suggest unclear control flow","fingerprint":"process::.claude/hooks/typescript-strict-check.js::multiple-exit-zero","severity":"S2","effort":"E2","confidence":"MEDIUM","files":[".claude/hooks/typescript-strict-check.js:28",".claude/hooks/typescript-strict-check.js:35",".claude/hooks/typescript-strict-check.js:47",".claude/hooks/typescript-strict-check.js:52",".claude/hooks/typescript-strict-check.js:58"],"why_it_matters":"typescript-strict-check.js has 15+ process.exit(0) calls in validation logic. This pattern makes it unclear which exits are 'check passed' vs 'check not applicable' vs 'check skipped due to error'","suggested_fix":"Refactor to have a single exit point with clear exit code strategy. Use early returns instead of exit(0) in validation functions, then exit once at the end based on accumulated state","acceptance_tests":["Single exit point at end of script","Exit code clearly indicates: 0=passed/not-applicable, 1=failed","Comments explain each early return reason","Control flow is linear and easy to follow"],"file":".claude/hooks/typescript-strict-check.js","line":28,"description":"typescript-strict-check.js has 15+ process.exit(0) calls in validation logic. This pattern makes it unclear which exits are 'check passed' vs 'check not applicable' vs 'check skipped due to error'","recommendation":"Refactor to have a single exit point with clear exit code strategy. Use early returns instead of exit(0) in validation functions, then exit once at the end based on accumulated state","id":"process::.claude/hooks/typescript-strict-check.js::multiple-exit-zero"}
{"category":"process","title":"Error handling: Hook execution errors not propagated to user","fingerprint":"process::hooks::error-visibility","severity":"S1","effort":"E2","confidence":"HIGH","files":[".claude/hooks/component-size-check.js:47",".claude/hooks/pattern-check.js:60",".claude/hooks/audit-s0s1-validator.js:49"],"why_it_matters":"When PostToolUse hooks fail silently (empty catch blocks), users don't know validation ran or failed. They may proceed thinking code is validated when checks actually crashed","suggested_fix":"Hooks should output clear status messages: 'ok' on success, error description on failure. Log to stderr for errors while preserving stdout for hook protocol. Example: catch (err) { console.error('Hook failed:', err.message); console.log('error'); process.exit(1); }","acceptance_tests":["Users see when hooks fail vs pass","Error messages are actionable","Hook failures are distinguishable from 'not applicable'","Logs clearly show which hook failed"],"file":".claude/hooks/component-size-check.js","line":47,"description":"When PostToolUse hooks fail silently (empty catch blocks), users don't know validation ran or failed. They may proceed thinking code is validated when checks actually crashed","recommendation":"Hooks should output clear status messages: 'ok' on success, error description on failure. Log to stderr for errors while preserving stdout for hook protocol. Example: catch (err) { console.error('Hook failed:', err.message); console.log('error'); process.exit(1); }","id":"process::hooks::error-visibility","evidence":[{"type":"code_reference","detail":".claude/hooks/component-size-check.js:47"},{"type":"description","detail":"When PostToolUse hooks fail silently (empty catch blocks), users don't know validation ran or failed. They may proceed thinking code is validated when checks actually crashed"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".claude/hooks/component-size-check.js:47"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".claude/hooks/component-size-check.js:47"}}}
{"category":"process","title":"Error handling: generate-pending-alerts.js throws error on write failure but doesn't clean up partial state","fingerprint":"process::scripts/generate-pending-alerts.js::no-cleanup-on-failure","severity":"S1","effort":"E2","confidence":"HIGH","files":["scripts/generate-pending-alerts.js:389","scripts/generate-pending-alerts.js:38","scripts/generate-pending-alerts.js:116"],"why_it_matters":"Script throws 'Failed to write alerts file' but doesn't rollback partial writes or clean up temp files. This can leave .alerts.json in inconsistent state, causing downstream tools to fail","suggested_fix":"Use atomic write pattern: write to temp file, validate, then rename. On failure, clean up temp file and preserve existing alerts file. Example: const tmp = file + '.tmp'; try { fs.writeFileSync(tmp, data); fs.renameSync(tmp, file); } catch (err) { fs.rmSync(tmp, {force:true}); throw err; }","acceptance_tests":["Failed writes don't corrupt existing alerts file","Temp files are cleaned up on error","Atomic rename ensures all-or-nothing updates","Error message explains what failed and why"],"file":"scripts/generate-pending-alerts.js","line":389,"description":"Script throws 'Failed to write alerts file' but doesn't rollback partial writes or clean up temp files. This can leave .alerts.json in inconsistent state, causing downstream tools to fail","recommendation":"Use atomic write pattern: write to temp file, validate, then rename. On failure, clean up temp file and preserve existing alerts file. Example: const tmp = file + '.tmp'; try { fs.writeFileSync(tmp, data); fs.renameSync(tmp, file); } catch (err) { fs.rmSync(tmp, {force:true}); throw err; }","id":"process::scripts/generate-pending-alerts.js::no-cleanup-on-failure","evidence":[{"type":"code_reference","detail":"scripts/generate-pending-alerts.js:389"},{"type":"description","detail":"Script throws 'Failed to write alerts file' but doesn't rollback partial writes or clean up temp files. This can leave .alerts.json in inconsistent state, causing downstream tools to fail"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/generate-pending-alerts.js:389"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/generate-pending-alerts.js:389"}}}
{"category":"process","title":"Error handling: sync-sonarcloud.js API errors expose implementation details","fingerprint":"process::scripts/debt/sync-sonarcloud.js::verbose-api-errors","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/debt/sync-sonarcloud.js:290"],"why_it_matters":"Error message includes full HTTP response status and potentially sensitive API error details. In logs, this could expose API keys or internal service details","suggested_fix":"Sanitize error messages before throwing. Example: throw new Error(`SonarCloud API request failed (${response.status}). Check SONARCLOUD_TOKEN environment variable.`); Don't include response body or headers in error messages","acceptance_tests":["API errors don't include response bodies","No tokens or sensitive headers in error messages","User-friendly guidance for common errors (401, 403, 429)","Detailed errors only in debug mode"],"file":"scripts/debt/sync-sonarcloud.js","line":290,"description":"Error message includes full HTTP response status and potentially sensitive API error details. In logs, this could expose API keys or internal service details","recommendation":"Sanitize error messages before throwing. Example: throw new Error(`SonarCloud API request failed (${response.status}). Check SONARCLOUD_TOKEN environment variable.`); Don't include response body or headers in error messages","id":"process::scripts/debt/sync-sonarcloud.js::verbose-api-errors"}
{"category":"process","title":"Error handling: execSync in validation scripts can hang on interactive prompts","fingerprint":"process::scripts::execsync-interactive-hang","severity":"S1","effort":"E1","confidence":"HIGH","files":["scripts/validate-audit.js:651","scripts/validate-audit.js:707"],"why_it_matters":"execSync('npm audit') and execSync('npm run lint') without stdio: 'pipe' can hang if these commands prompt for user input. Hook execution would freeze indefinitely","suggested_fix":"Already using stdio: ['ignore', 'pipe', 'pipe'] pattern correctly in validate-audit.js. Verify all other execSync calls use similar pattern to prevent stdin interaction","acceptance_tests":["Commands never wait for stdin","stdio is explicitly configured for all execSync calls","Timeout is set for all long-running commands","Scripts can run unattended in CI"],"file":"scripts/validate-audit.js","line":651,"description":"execSync('npm audit') and execSync('npm run lint') without stdio: 'pipe' can hang if these commands prompt for user input. Hook execution would freeze indefinitely","recommendation":"Already using stdio: ['ignore', 'pipe', 'pipe'] pattern correctly in validate-audit.js. Verify all other execSync calls use similar pattern to prevent stdin interaction","id":"process::scripts::execsync-interactive-hang","evidence":[{"type":"code_reference","detail":"scripts/validate-audit.js:651"},{"type":"description","detail":"execSync('npm audit') and execSync('npm run lint') without stdio: 'pipe' can hang if these commands prompt for user input. Hook execution would freeze indefinitely"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/validate-audit.js:651"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/validate-audit.js:651"}}}
