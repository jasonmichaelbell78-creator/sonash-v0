{"category":"process","title":"Slow: ESLint full codebase scan in pre-commit","fingerprint":"process::.husky/pre-commit::slow-eslint-full-scan","severity":"S2","effort":"E1","confidence":"HIGH","files":[".husky/pre-commit:9"],"why_it_matters":"ESLint scans entire codebase (~3-10s) on every commit instead of only staged files. Developers wait unnecessarily even for small changes. Over time this encourages --no-verify bypassing.","suggested_fix":"Use 'npm run lint -- --cache' for caching, or integrate with lint-staged to check only staged files. lint-staged already runs Prettier (line 23), could also run ESLint on same files.","acceptance_tests":["ESLint completes in <2s for typical commits","ESLint still catches errors before commit","Cache works between commits"],"file":".husky/pre-commit","line":9,"description":"ESLint scans entire codebase (~3-10s) on every commit instead of only staged files. Developers wait unnecessarily even for small changes. Over time this encourages --no-verify bypassing.","recommendation":"Use 'npm run lint -- --cache' for caching, or integrate with lint-staged to check only staged files. lint-staged already runs Prettier (line 23), could also run ESLint on same files.","id":"process::.husky/pre-commit::slow-eslint-full-scan"}
{"category":"process","title":"Duplicate: Pattern compliance runs in both pre-commit and pre-push","fingerprint":"process::.husky/pre-commit+pre-push::duplicate-pattern-check","severity":"S2","effort":"E1","confidence":"HIGH","files":[".husky/pre-commit:35",".husky/pre-push:26"],"why_it_matters":"'npm run patterns:check' runs twice - once in pre-commit (line 35) and again in pre-push (line 26). Same files checked twice adds 1-3s per push. Pure waste since files don't change between commit and push.","suggested_fix":"Remove pattern check from pre-commit OR pre-push. Recommend keeping in pre-commit only (fail fast) and removing from pre-push line 21-35. Pattern violations should be caught at commit time.","acceptance_tests":["Pattern check runs only once per commit/push cycle","Total hook time reduced by 1-3s","All pattern violations still caught"],"file":".husky/pre-commit","line":35,"description":"'npm run patterns:check' runs twice - once in pre-commit (line 35) and again in pre-push (line 26). Same files checked twice adds 1-3s per push. Pure waste since files don't change between commit and push.","recommendation":"Remove pattern check from pre-commit OR pre-push. Recommend keeping in pre-commit only (fail fast) and removing from pre-push line 21-35. Pattern violations should be caught at commit time.","id":"process::.husky/pre-commit+pre-push::duplicate-pattern-check"}
{"category":"process","title":"Slow: TypeScript full project type check on every push","fingerprint":"process::.husky/pre-push::slow-tsc-no-incremental","severity":"S2","effort":"E2","confidence":"HIGH","files":[".husky/pre-push:83"],"why_it_matters":"'npx tsc --noEmit' does full project type check (5-15s) on every push with no incremental caching. For large projects this becomes painful. Developers may skip with git push --no-verify.","suggested_fix":"1) Use 'tsc --noEmit --incremental' with tsbuildinfo caching, OR 2) Use 'tsc --noEmit --pretty' with file filtering for changed files only, OR 3) Move to CI and make optional in pre-push with SKIP_TYPE_CHECK=1 override.","acceptance_tests":["Type check completes in <5s with caching","Incremental builds work correctly","Type errors still caught before push"],"file":".husky/pre-push","line":83,"description":"'npx tsc --noEmit' does full project type check (5-15s) on every push with no incremental caching. For large projects this becomes painful. Developers may skip with git push --no-verify.","recommendation":"1) Use 'tsc --noEmit --incremental' with tsbuildinfo caching, OR 2) Use 'tsc --noEmit --pretty' with file filtering for changed files only, OR 3) Move to CI and make optional in pre-push with SKIP_TYPE_CHECK=1 override.","id":"process::.husky/pre-push::slow-tsc-no-incremental"}
{"category":"process","title":"Slow: Circular dependency scan on entire codebase every push","fingerprint":"process::.husky/pre-push::slow-madge-full-scan","severity":"S2","effort":"E2","confidence":"HIGH","files":[".husky/pre-push:12"],"why_it_matters":"'madge --circular' scans lib/, components/, app/ directories (2-5s) on every push regardless of what changed. Circular deps are architectural issues that rarely appear in normal development. Full scan is overkill.","suggested_fix":"1) Add madge caching or run incrementally on changed files only, OR 2) Move to CI as a scheduled check (daily/weekly), OR 3) Make optional with SKIP_CIRCULAR_CHECK=1 and run only when dependency files change (package.json, imports in changed files).","acceptance_tests":["Circular dep check skipped when no dependency changes","Optional override documented","Architectural issues still caught in CI"],"file":".husky/pre-push","line":12,"description":"'madge --circular' scans lib/, components/, app/ directories (2-5s) on every push regardless of what changed. Circular deps are architectural issues that rarely appear in normal development. Full scan is overkill.","recommendation":"1) Add madge caching or run incrementally on changed files only, OR 2) Move to CI as a scheduled check (daily/weekly), OR 3) Make optional with SKIP_CIRCULAR_CHECK=1 and run only when dependency files change (package.json, imports in changed files).","id":"process::.husky/pre-push::slow-madge-full-scan"}
{"category":"process","title":"Slow: Test suite rebuilds TypeScript on every test run","fingerprint":"process::package.json::slow-test-build","severity":"S2","effort":"E2","confidence":"HIGH","files":["package.json:11"],"why_it_matters":"'npm test' runs 'test:build' which compiles ALL TypeScript (tsc + tsc-alias) before tests. Pre-commit runs tests (line 59/80) adding 10-30s for full compilation even for small changes. No incremental compilation.","suggested_fix":"1) Use 'tsc --incremental' in test:build for caching, OR 2) Use tsx/ts-node for on-the-fly compilation without build step, OR 3) Only run test:build when test files or dependencies change (check git diff).","acceptance_tests":["Test build time reduced by 60-80% for incremental changes","Tests still run correctly","tsconfig.test.json still respected"],"file":"package.json","line":11,"description":"'npm test' runs 'test:build' which compiles ALL TypeScript (tsc + tsc-alias) before tests. Pre-commit runs tests (line 59/80) adding 10-30s for full compilation even for small changes. No incremental compilation.","recommendation":"1) Use 'tsc --incremental' in test:build for caching, OR 2) Use tsx/ts-node for on-the-fly compilation without build step, OR 3) Only run test:build when test files or dependencies change (check git diff).","id":"process::package.json::slow-test-build"}
{"category":"process","title":"Inefficient: Sequential security checks in pre-push","fingerprint":"process::.husky/pre-push::sequential-security-checks","severity":"S3","effort":"E2","confidence":"HIGH","files":[".husky/pre-push:50-65"],"why_it_matters":"Pre-push security checks loop through changed files sequentially (lines 50-65), running 'node scripts/security-check.js --file' once per file. For 10+ changed files, this adds 5-15s. No parallelization means cores sit idle.","suggested_fix":"1) Modify security-check.js to accept multiple files at once, OR 2) Use xargs -P4 for parallel execution, OR 3) Rewrite loop to spawn checks in parallel and wait for all results. Example: 'echo \"$changed_files\" | xargs -P4 -I{} node scripts/security-check.js --file {}'","acceptance_tests":["Security checks run in parallel (4+ concurrent)","Total time reduced by 50-70% for multi-file changes","All security issues still detected"],"file":".husky/pre-push","line":50,"description":"Pre-push security checks loop through changed files sequentially (lines 50-65), running 'node scripts/security-check.js --file' once per file. For 10+ changed files, this adds 5-15s. No parallelization means cores sit idle.","recommendation":"1) Modify security-check.js to accept multiple files at once, OR 2) Use xargs -P4 for parallel execution, OR 3) Rewrite loop to spawn checks in parallel and wait for all results. Example: 'echo \"$changed_files\" | xargs -P4 -I{} node scripts/security-check.js --file {}'","id":"process::.husky/pre-push::sequential-security-checks"}
{"category":"process","title":"Performance: 10 Claude hooks run on every Write/Edit operation","fingerprint":"process::.claude/settings.json::many-posttooluse-hooks","severity":"S2","effort":"E3","confidence":"HIGH","files":[".claude/settings.json:57-111"],"why_it_matters":"Every Write/Edit/MultiEdit triggers 10 separate hooks (check-write-requirements, audit-s0s1-validator, pattern-check, component-size-check, firestore-write-block, test-mocking-validator, app-check-validator, typescript-strict-check, repository-pattern-check, agent-trigger-enforcer). Total: ~5818 lines of hook code. Each hook spawns node process, adds 1-3s latency per file write. Poor DX during active development.","suggested_fix":"1) Batch-execute hooks in single node process to avoid spawn overhead, OR 2) Make hooks async/parallel where possible, OR 3) Add smart skipping - only run relevant hooks based on file type (e.g., firestore-write-block only for firestore files), OR 4) Move some non-critical checks to pre-commit only.","acceptance_tests":["Write/Edit latency reduced to <1s total","Hook logic preserved (no false negatives)","File type filtering works correctly"],"file":".claude/settings.json","line":57,"description":"Every Write/Edit/MultiEdit triggers 10 separate hooks (check-write-requirements, audit-s0s1-validator, pattern-check, component-size-check, firestore-write-block, test-mocking-validator, app-check-validator, typescript-strict-check, repository-pattern-check, agent-trigger-enforcer). Total: ~5818 lines of hook code. Each hook spawns node process, adds 1-3s latency per file write. Poor DX during active development.","recommendation":"1) Batch-execute hooks in single node process to avoid spawn overhead, OR 2) Make hooks async/parallel where possible, OR 3) Add smart skipping - only run relevant hooks based on file type (e.g., firestore-write-block only for firestore files), OR 4) Move some non-critical checks to pre-commit only.","id":"process::.claude/settings.json::many-posttooluse-hooks"}
{"category":"process","title":"Inefficient: Pattern check runs on every file write via Claude hook","fingerprint":"process::.claude/hooks/pattern-check.js::per-file-overhead","severity":"S3","effort":"E2","confidence":"HIGH","files":[".claude/hooks/pattern-check.js:1",".claude/settings.json:73,123"],"why_it_matters":"Pattern-check.js hook (line 73, 123 in settings.json) runs check-pattern-compliance.js on EVERY file write/edit during Claude sessions. For quick doc edits or small changes, running full pattern checker adds 0.5-2s overhead. Pre-commit already runs patterns:check (line 35), making this redundant during development.","suggested_fix":"1) Make pattern-check.js conditional - skip for .md/.txt/docs files, OR 2) Add debouncing - only check after N writes or M seconds, OR 3) Remove hook and rely solely on pre-commit pattern check (fail fast at commit, not during writing), OR 4) Make hook informational only (warn but don't block).","acceptance_tests":["Pattern check skipped for non-code files","Write latency <0.5s for docs","Pattern violations still caught at commit time"],"file":".claude/hooks/pattern-check.js","line":1,"description":"Pattern-check.js hook (line 73, 123 in settings.json) runs check-pattern-compliance.js on EVERY file write/edit during Claude sessions. For quick doc edits or small changes, running full pattern checker adds 0.5-2s overhead. Pre-commit already runs patterns:check (line 35), making this redundant during development.","recommendation":"1) Make pattern-check.js conditional - skip for .md/.txt/docs files, OR 2) Add debouncing - only check after N writes or M seconds, OR 3) Remove hook and rely solely on pre-commit pattern check (fail fast at commit, not during writing), OR 4) Make hook informational only (warn but don't block).","id":"process::.claude/hooks/pattern-check.js::per-file-overhead"}
{"category":"process","title":"Inefficient: Multiple git status/diff scans in pre-commit","fingerprint":"process::.husky/pre-commit::multiple-git-scans","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".husky/pre-commit:47,94,138,159,194"],"why_it_matters":"Pre-commit runs 'git diff --cached --name-only' separately at lines 47, 94, 138, 159, 194. Each git call adds 50-200ms overhead. For repos with many files, this compounds to 0.5-1s wasted on duplicate filesystem scans.","suggested_fix":"Run 'git diff --cached --name-only' ONCE at the top of pre-commit hook and store in STAGED_FILES variable. Reuse this variable throughout. Already done partially (line 47, 94 reuse), but lines 138, 159, 194 run fresh git commands. Consolidate all into single scan.","acceptance_tests":["Only one git diff command executed","Hook behavior unchanged","Time savings: 0.3-0.8s per commit"],"file":".husky/pre-commit","line":47,"description":"Pre-commit runs 'git diff --cached --name-only' separately at lines 47, 94, 138, 159, 194. Each git call adds 50-200ms overhead. For repos with many files, this compounds to 0.5-1s wasted on duplicate filesystem scans.","recommendation":"Run 'git diff --cached --name-only' ONCE at the top of pre-commit hook and store in STAGED_FILES variable. Reuse this variable throughout. Already done partially (line 47, 94 reuse), but lines 138, 159, 194 run fresh git commands. Consolidate all into single scan.","id":"process::.husky/pre-commit::multiple-git-scans"}
{"category":"process","title":"Risk: No timeout on npm test in pre-commit","fingerprint":"process::.husky/pre-commit::no-test-timeout","severity":"S3","effort":"E1","confidence":"MEDIUM","files":[".husky/pre-commit:59,80"],"why_it_matters":"'npm test' runs without timeout in pre-commit (lines 59, 80). If test hangs due to async issue, developer waits indefinitely or force-quits, losing context. No escape hatch besides killing terminal. Degraded DX for rare but frustrating hangs.","suggested_fix":"Add timeout wrapper: 'timeout 120 npm test' (120s = 2 min). If tests hang beyond reasonable time, hook fails fast with clear timeout message. Document with: 'Tests timed out after 120s. Check for hanging async operations or use SKIP_TESTS=1 for emergency commit.'","acceptance_tests":["Tests timeout after 120s if hung","Clear timeout error message shown","Normal test runs unaffected"],"file":".husky/pre-commit","line":59,"description":"'npm test' runs without timeout in pre-commit (lines 59, 80). If test hangs due to async issue, developer waits indefinitely or force-quits, losing context. No escape hatch besides killing terminal. Degraded DX for rare but frustrating hangs.","recommendation":"Add timeout wrapper: 'timeout 120 npm test' (120s = 2 min). If tests hang beyond reasonable time, hook fails fast with clear timeout message. Document with: 'Tests timed out after 120s. Check for hanging async operations or use SKIP_TESTS=1 for emergency commit.'","id":"process::.husky/pre-commit::no-test-timeout"}
{"category":"process","title":"Optimization: Doc-only commit detection could be smarter","fingerprint":"process::.husky/pre-commit::doc-only-detection-complexity","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".husky/pre-commit:68-88"],"why_it_matters":"Doc-only commit detection (lines 68-88) uses complex regex grep filtering to skip tests. Logic is hard to maintain and test. False positives (docs with critical info) or false negatives (code masquerading as docs) could occur. Current regex at line 71 is 100+ chars long.","suggested_fix":"1) Extract doc-only detection to dedicated script 'scripts/is-doc-only-commit.js' with unit tests, OR 2) Use git diff --name-status with explicit allowlist (docs/, *.md, *.png, *.jsonl) instead of complex exclusion regex, OR 3) Make SKIP_TESTS=1 the default for docs and auto-detect risky files (package.json, tsconfig, etc.) to force tests.","acceptance_tests":["Doc-only detection logic unit tested","Clear separation of concerns","False positive/negative rate <1%"],"file":".husky/pre-commit","line":68,"description":"Doc-only commit detection (lines 68-88) uses complex regex grep filtering to skip tests. Logic is hard to maintain and test. False positives (docs with critical info) or false negatives (code masquerading as docs) could occur. Current regex at line 71 is 100+ chars long.","recommendation":"1) Extract doc-only detection to dedicated script 'scripts/is-doc-only-commit.js' with unit tests, OR 2) Use git diff --name-status with explicit allowlist (docs/, *.md, *.png, *.jsonl) instead of complex exclusion regex, OR 3) Make SKIP_TESTS=1 the default for docs and auto-detect risky files (package.json, tsconfig, etc.) to force tests.","id":"process::.husky/pre-commit::doc-only-detection-complexity"}
{"category":"process","title":"Slow: Session start hooks add 2-5s latency to every session","fingerprint":"process::.claude/settings.json::slow-session-start","severity":"S3","effort":"E3","confidence":"MEDIUM","files":[".claude/settings.json:8-44"],"why_it_matters":"SessionStart hooks run 4 sequential node processes (session-start.js, check-mcp-servers.js, check-remote-session-context.js, stop-serena-dashboard.js) on EVERY Claude session start. Total latency: 2-5s before developer can begin work. Compounds frustration for quick questions/checks. Remote session check can be slow if network latency high.","suggested_fix":"1) Parallelize independent hooks (session-start, check-mcp-servers, stop-serena can run concurrently), OR 2) Make check-remote-session-context.js async/non-blocking with background notification, OR 3) Add cache TTL - skip checks if last run was <5min ago, OR 4) Optimize scripts - combine into single process to avoid spawn overhead.","acceptance_tests":["Session start latency <1s for cached/local operations","Hooks run in parallel where possible","Functionality preserved (no missed checks)"],"file":".claude/settings.json","line":8,"description":"SessionStart hooks run 4 sequential node processes (session-start.js, check-mcp-servers.js, check-remote-session-context.js, stop-serena-dashboard.js) on EVERY Claude session start. Total latency: 2-5s before developer can begin work. Compounds frustration for quick questions/checks. Remote session check can be slow if network latency high.","recommendation":"1) Parallelize independent hooks (session-start, check-mcp-servers, stop-serena can run concurrently), OR 2) Make check-remote-session-context.js async/non-blocking with background notification, OR 3) Add cache TTL - skip checks if last run was <5min ago, OR 4) Optimize scripts - combine into single process to avoid spawn overhead.","id":"process::.claude/settings.json::slow-session-start"}
{"category":"process","title":"Optimization: UserPromptSubmit hooks run before every user message","fingerprint":"process::.claude/settings.json::user-prompt-overhead","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".claude/settings.json:265-290"],"why_it_matters":"UserPromptSubmit hooks (lines 265-290) run 4 checks (alerts-reminder, analyze-user-request, session-end-reminder, plan-mode-suggestion) before processing EVERY user prompt. Adds 0.5-2s perceived latency. For rapid back-and-forth conversations, this degrades conversational flow.","suggested_fix":"1) Make hooks async - run in background and surface results after response, OR 2) Add smart throttling - only run every Nth prompt or when certain keywords detected, OR 3) Batch hooks into single process to reduce spawn overhead, OR 4) Cache results - skip redundant checks if recent prompt was similar.","acceptance_tests":["Prompt processing starts immediately (<200ms)","Hooks run asynchronously without blocking","Important alerts still surfaced reliably"],"file":".claude/settings.json","line":265,"description":"UserPromptSubmit hooks (lines 265-290) run 4 checks (alerts-reminder, analyze-user-request, session-end-reminder, plan-mode-suggestion) before processing EVERY user prompt. Adds 0.5-2s perceived latency. For rapid back-and-forth conversations, this degrades conversational flow.","recommendation":"1) Make hooks async - run in background and surface results after response, OR 2) Add smart throttling - only run every Nth prompt or when certain keywords detected, OR 3) Batch hooks into single process to reduce spawn overhead, OR 4) Cache results - skip redundant checks if recent prompt was similar.","id":"process::.claude/settings.json::user-prompt-overhead"}
