{"category":"process","title":"Gap: Shell scripts not linted or validated","fingerprint":"process::N/A::shell-script-no-lint","severity":"S2","effort":"E2","confidence":"HIGH","files":[".claude/hooks/analyze-user-request.sh:1",".claude/hooks/check-edit-requirements.sh:1",".claude/hooks/check-mcp-servers.sh:1",".claude/hooks/check-write-requirements.sh:1",".claude/hooks/pattern-check.sh:1",".claude/hooks/session-start.sh:1"],"why_it_matters":"6 shell scripts in .claude/hooks/ (and additional ones in skills/) can be committed with syntax errors, runtime bugs, or security issues. ShellCheck would catch common mistakes like unquoted variables, incorrect conditionals, and unsafe patterns. Shell scripts run at critical points (session start, pre-commit checks) so bugs can break development workflow.","suggested_fix":"Add ShellCheck validation: 1) Install shellcheck as devDependency, 2) Add npm script 'shellcheck:check' that runs on .claude/hooks/*.sh and .claude/skills/**/*.sh, 3) Add to pre-commit hook before other checks, 4) Add to CI workflow as blocking step, 5) Create .shellcheckrc to configure rules.","acceptance_tests":["ShellCheck runs on all .sh files","Pre-commit blocks commits with shell syntax errors","CI fails if shell scripts have issues"],"file":".claude/hooks/analyze-user-request.sh","line":1,"description":"6 shell scripts in .claude/hooks/ (and additional ones in skills/) can be committed with syntax errors, runtime bugs, or security issues. ShellCheck would catch common mistakes like unquoted variables, incorrect conditionals, and unsafe patterns. Shell scripts run at critical points (session start, pre-commit checks) so bugs can break development workflow.","recommendation":"Add ShellCheck validation: 1) Install shellcheck as devDependency, 2) Add npm script 'shellcheck:check' that runs on .claude/hooks/*.sh and .claude/skills/**/*.sh, 3) Add to pre-commit hook before other checks, 4) Add to CI workflow as blocking step, 5) Create .shellcheckrc to configure rules.","id":"process::N/A::shell-script-no-lint"}
{"category":"process","title":"Gap: Config .mjs files excluded from linting","fingerprint":"process::N/A::mjs-config-no-lint","severity":"S3","effort":"E1","confidence":"HIGH","files":["eslint.config.mjs:25","next.config.mjs:1","postcss.config.mjs:1"],"why_it_matters":"eslint.config.mjs explicitly excludes '*.config.mjs' from linting. These are critical configuration files (Next.js, PostCSS, ESLint itself) that affect build and development. Syntax errors or security issues in these files can break builds or introduce vulnerabilities. Currently they can be committed without any validation.","suggested_fix":"Remove '*.config.mjs' from ignores array in eslint.config.mjs. If specific rules need to be relaxed for config files, create a separate configuration block with adjusted rules (e.g., allow 'export default' without explicit types). Verify all config files pass linting before making change blocking.","acceptance_tests":["ESLint runs on all .mjs config files","Changes to config files are validated in pre-commit","No build breaks after enabling linting"],"file":"eslint.config.mjs","line":25,"description":"eslint.config.mjs explicitly excludes '*.config.mjs' from linting. These are critical configuration files (Next.js, PostCSS, ESLint itself) that affect build and development. Syntax errors or security issues in these files can break builds or introduce vulnerabilities. Currently they can be committed without any validation.","recommendation":"Remove '*.config.mjs' from ignores array in eslint.config.mjs. If specific rules need to be relaxed for config files, create a separate configuration block with adjusted rules (e.g., allow 'export default' without explicit types). Verify all config files pass linting before making change blocking.","id":"process::N/A::mjs-config-no-lint"}
{"category":"process","title":"Gap: Scripts directory missing test coverage","fingerprint":"process::N/A::scripts-no-tests","severity":"S2","effort":"E3","confidence":"HIGH","files":["scripts/:1"],"why_it_matters":"89 JavaScript files in scripts/ directory but only 5 have test coverage (check-docs-light, phase-complete-check, surface-lessons-learned, update-readme-status, validate-audit-s0s1). These scripts handle critical automation: debt management, audit validation, security checks, hook health, document sync. Bugs in these scripts can corrupt data, break CI, or cause incorrect validation results. Scripts like validate-audit.js, security-check.js, and debt/validate-schema.js are used as blocking gates in pre-commit/pre-push.","suggested_fix":"Prioritize test coverage for blocking scripts: 1) Start with security-check.js (blocks pre-push), 2) Add tests for debt/validate-schema.js (blocks commits), 3) Cover validate-audit.js (blocks S0/S1), 4) Add tests for check-pattern-compliance.js (blocks commits), 5) Expand to other critical scripts. Create tests/scripts/__helpers__ for common test utilities. Aim for 60%+ coverage of blocking scripts, 30%+ for others.","acceptance_tests":["Tests exist for all blocking validation scripts","Coverage report shows >60% for critical scripts","Test suite catches intentional bugs in validation logic"],"file":"scripts/","line":1,"description":"89 JavaScript files in scripts/ directory but only 5 have test coverage (check-docs-light, phase-complete-check, surface-lessons-learned, update-readme-status, validate-audit-s0s1). These scripts handle critical automation: debt management, audit validation, security checks, hook health, document sync. Bugs in these scripts can corrupt data, break CI, or cause incorrect validation results. Scripts like validate-audit.js, security-check.js, and debt/validate-schema.js are used as blocking gates in pre-commit/pre-push.","recommendation":"Prioritize test coverage for blocking scripts: 1) Start with security-check.js (blocks pre-push), 2) Add tests for debt/validate-schema.js (blocks commits), 3) Cover validate-audit.js (blocks S0/S1), 4) Add tests for check-pattern-compliance.js (blocks commits), 5) Expand to other critical scripts. Create tests/scripts/__helpers__ for common test utilities. Aim for 60%+ coverage of blocking scripts, 30%+ for others.","id":"process::N/A::scripts-no-tests"}
{"category":"process","title":"Gap: Firebase functions lack integration tests","fingerprint":"process::N/A::functions-no-integration-tests","severity":"S2","effort":"E3","confidence":"HIGH","files":["functions/src/admin.ts:1","functions/src/recaptcha-verify.ts:1","functions/src/jobs.ts:1","functions/src/security-wrapper.ts:1"],"why_it_matters":"8 TypeScript files in functions/src/ contain Cloud Functions (admin operations, recaptcha verification, scheduled jobs, security wrappers) but no integration tests exist in functions/ directory. While unit tests exist for the main app, Firebase functions interact with Firestore, authentication, and external APIs. Integration tests would catch: incorrect Firestore rules interactions, auth token validation issues, rate limiting failures, scheduled job execution problems. Functions are deployed to production and handle sensitive operations.","suggested_fix":"Set up Firebase Functions integration test framework: 1) Install firebase-functions-test (already in devDeps), 2) Create functions/test/ directory, 3) Add test files for each function module (admin.test.ts, recaptcha-verify.test.ts, jobs.test.ts), 4) Use Firebase emulators for Firestore/Auth, 5) Add 'test' script to functions/package.json, 6) Run function tests in CI after main tests, 7) Document test setup in functions/README.md.","acceptance_tests":["Integration tests exist for all Cloud Functions","Tests run against Firebase emulators","CI runs function tests and fails on errors","Coverage includes auth, Firestore, and API interactions"],"file":"functions/src/admin.ts","line":1,"description":"8 TypeScript files in functions/src/ contain Cloud Functions (admin operations, recaptcha verification, scheduled jobs, security wrappers) but no integration tests exist in functions/ directory. While unit tests exist for the main app, Firebase functions interact with Firestore, authentication, and external APIs. Integration tests would catch: incorrect Firestore rules interactions, auth token validation issues, rate limiting failures, scheduled job execution problems. Functions are deployed to production and handle sensitive operations.","recommendation":"Set up Firebase Functions integration test framework: 1) Install firebase-functions-test (already in devDeps), 2) Create functions/test/ directory, 3) Add test files for each function module (admin.test.ts, recaptcha-verify.test.ts, jobs.test.ts), 4) Use Firebase emulators for Firestore/Auth, 5) Add 'test' script to functions/package.json, 6) Run function tests in CI after main tests, 7) Document test setup in functions/README.md.","id":"process::N/A::functions-no-integration-tests"}
{"category":"process","title":"Gap: Skills missing usage documentation","fingerprint":"process::N/A::skills-no-usage-docs","severity":"S3","effort":"E3","confidence":"HIGH","files":[".claude/skills/:1"],"why_it_matters":"56 skills exist but 0 have USAGE.md documentation, only 1 has README.md. SKILL_INDEX.md shows skills organized by category (Audit & Code Quality, Session Management, Development Roles, etc.) but individual skills lack: usage examples, parameter documentation, expected outputs, common use cases, troubleshooting tips. This makes skills harder to use correctly and increases likelihood of misuse. New team members or AI agents using these skills lack guidance.","suggested_fix":"Create standardized skill documentation template: 1) Add USAGE.md template to skill-creator skill, 2) Document top 10 most-used skills first (check MCP logs for frequency), 3) Include sections: Synopsis, Parameters, Examples, Expected Output, Common Issues, Related Skills, 4) Add skills:check-docs npm script to validate USAGE.md exists and has required sections, 5) Add to pre-commit check when skill files are modified, 6) Generate missing USAGE.md files in batch using doc-optimizer skill.","acceptance_tests":["All skills have USAGE.md with required sections","skills:check-docs validates documentation completeness","Pre-commit checks USAGE.md when SKILL.md changes","SKILL_INDEX.md links to usage documentation"],"file":".claude/skills/","line":1,"description":"56 skills exist but 0 have USAGE.md documentation, only 1 has README.md. SKILL_INDEX.md shows skills organized by category (Audit & Code Quality, Session Management, Development Roles, etc.) but individual skills lack: usage examples, parameter documentation, expected outputs, common use cases, troubleshooting tips. This makes skills harder to use correctly and increases likelihood of misuse. New team members or AI agents using these skills lack guidance.","recommendation":"Create standardized skill documentation template: 1) Add USAGE.md template to skill-creator skill, 2) Document top 10 most-used skills first (check MCP logs for frequency), 3) Include sections: Synopsis, Parameters, Examples, Expected Output, Common Issues, Related Skills, 4) Add skills:check-docs npm script to validate USAGE.md exists and has required sections, 5) Add to pre-commit check when skill files are modified, 6) Generate missing USAGE.md files in batch using doc-optimizer skill.","id":"process::N/A::skills-no-usage-docs"}
{"category":"process","title":"Gap: YAML workflow files not linted","fingerprint":"process::N/A::yaml-no-lint","severity":"S3","effort":"E1","confidence":"HIGH","files":[".github/workflows/ci.yml:1",".github/workflows/deploy-firebase.yml:1",".github/workflows/docs-lint.yml:1"],"why_it_matters":"10 GitHub workflow YAML files exist (.github/workflows/*.yml) but no YAML linting is configured. Workflow files control CI/CD, deployments, security checks, and automation. YAML syntax errors break CI/CD pipelines. Invalid workflow syntax might not be caught until push, wasting time. Indentation errors, incorrect anchors, or invalid keys can cause silent failures or unexpected behavior.","suggested_fix":"Add YAML linting: 1) Install yamllint as devDependency, 2) Create .yamllint.yml config (set line-length to 120, indent to 2, allow comments), 3) Add npm script 'yaml:lint' that checks .github/workflows/*.yml and .serena/project.yml, 4) Add to pre-commit hook (non-blocking warning first), 5) Add to CI as blocking step, 6) Fix any existing issues before making blocking.","acceptance_tests":["yamllint runs on all YAML files","Pre-commit warns about YAML issues","CI fails if workflow files have syntax errors","Intentional YAML errors are caught"],"file":".github/workflows/ci.yml","line":1,"description":"10 GitHub workflow YAML files exist (.github/workflows/*.yml) but no YAML linting is configured. Workflow files control CI/CD, deployments, security checks, and automation. YAML syntax errors break CI/CD pipelines. Invalid workflow syntax might not be caught until push, wasting time. Indentation errors, incorrect anchors, or invalid keys can cause silent failures or unexpected behavior.","recommendation":"Add YAML linting: 1) Install yamllint as devDependency, 2) Create .yamllint.yml config (set line-length to 120, indent to 2, allow comments), 3) Add npm script 'yaml:lint' that checks .github/workflows/*.yml and .serena/project.yml, 4) Add to pre-commit hook (non-blocking warning first), 5) Add to CI as blocking step, 6) Fix any existing issues before making blocking.","id":"process::N/A::yaml-no-lint"}
{"category":"process","title":"Gap: Environment files not validated","fingerprint":"process::N/A::env-no-validation","severity":"S2","effort":"E2","confidence":"HIGH","files":[".env.local.example:1","functions/.env.local.example:1"],"why_it_matters":"Multiple .env files exist (.env.local.example, functions/.env.local.example, .env.production) but no validation of required variables or format. Missing required env vars cause runtime errors. Incorrect env var formats (URLs without protocols, invalid API keys) fail late. Example files can become stale and missing new required variables. No check that actual .env files match the example structure.","suggested_fix":"Create environment validation: 1) Add scripts/validate-env.js that reads .env.local.example and checks actual .env files have required keys, 2) Validate format (URLs, numeric values, required prefixes like NEXT_PUBLIC_), 3) Add npm script 'env:validate', 4) Run in pre-push as non-blocking warning (can't block since .env is gitignored), 5) Add to CI for production builds, 6) Check functions/.env separately with functions-specific requirements, 7) Document required env vars in README.md.","acceptance_tests":["env:validate checks all required variables exist","CI fails if production env vars missing","Format validation catches malformed values","Example files stay in sync with requirements"],"file":".env.local.example","line":1,"description":"Multiple .env files exist (.env.local.example, functions/.env.local.example, .env.production) but no validation of required variables or format. Missing required env vars cause runtime errors. Incorrect env var formats (URLs without protocols, invalid API keys) fail late. Example files can become stale and missing new required variables. No check that actual .env files match the example structure.","recommendation":"Create environment validation: 1) Add scripts/validate-env.js that reads .env.local.example and checks actual .env files have required keys, 2) Validate format (URLs, numeric values, required prefixes like NEXT_PUBLIC_), 3) Add npm script 'env:validate', 4) Run in pre-push as non-blocking warning (can't block since .env is gitignored), 5) Add to CI for production builds, 6) Check functions/.env separately with functions-specific requirements, 7) Document required env vars in README.md.","id":"process::N/A::env-no-validation"}
{"category":"process","title":"Gap: Firebase functions TypeScript not type-checked in pre-push","fingerprint":"process::N/A::functions-no-type-check-pre-push","severity":"S3","effort":"E1","confidence":"HIGH","files":[".husky/pre-push:82","functions/tsconfig.json:1"],"why_it_matters":"Pre-push hook (line 82-90) runs 'npx tsc --noEmit' for type checking but only for the main project, not for functions/. Firebase functions have their own TypeScript config (functions/tsconfig.json) and can have type errors that slip through. Type errors in functions are only caught during 'npm run build' in functions/ which might not be run before push. CI doesn't explicitly type-check functions directory either (only runs functions build during deploy workflow).","suggested_fix":"Add functions type check to pre-push: 1) After main type check in .husky/pre-push (line 90), add functions type check, 2) Run 'cd functions && npx tsc --noEmit' (or use absolute path), 3) Show appropriate error message if functions type check fails, 4) Consider adding to CI workflow as explicit step before build, 5) Ensure functions TypeScript errors are visible and block push.","acceptance_tests":["Pre-push runs tsc --noEmit on functions/","Type errors in functions/ block push","CI explicitly type-checks functions directory","Intentional type errors in functions are caught"],"file":".husky/pre-push","line":82,"description":"Pre-push hook (line 82-90) runs 'npx tsc --noEmit' for type checking but only for the main project, not for functions/. Firebase functions have their own TypeScript config (functions/tsconfig.json) and can have type errors that slip through. Type errors in functions are only caught during 'npm run build' in functions/ which might not be run before push. CI doesn't explicitly type-check functions directory either (only runs functions build during deploy workflow).","recommendation":"Add functions type check to pre-push: 1) After main type check in .husky/pre-push (line 90), add functions type check, 2) Run 'cd functions && npx tsc --noEmit' (or use absolute path), 3) Show appropriate error message if functions type check fails, 4) Consider adding to CI workflow as explicit step before build, 5) Ensure functions TypeScript errors are visible and block push.","id":"process::N/A::functions-no-type-check-pre-push"}
{"category":"process","title":"Gap: No syntax validation for committed shell scripts in CI","fingerprint":"process::N/A::ci-no-shell-syntax-check","severity":"S2","effort":"E2","confidence":"HIGH","files":[".github/workflows/ci.yml:1",".husky/pre-commit:1"],"why_it_matters":"CI workflow checks many things (ESLint, TypeScript, tests, patterns, security) but doesn't validate shell script syntax. Pre-commit hook is itself a shell script (.husky/pre-commit) - if it has syntax errors, commits can become blocked or validation can silently fail. .claude/hooks/ contains 6 critical shell scripts that run during development. A shell syntax error could break session-start.sh or pattern-check.sh, disrupting development flow. While these might work on developer's machine, different shell versions or environments could expose issues.","suggested_fix":"Add shell script validation to CI: 1) Install ShellCheck in CI environment (add to CI job steps), 2) Add step after 'Checkout code' named 'Validate shell scripts', 3) Run 'shellcheck .husky/pre-commit .husky/pre-push .claude/hooks/*.sh .claude/skills/**/*.sh', 4) Make blocking (don't use continue-on-error), 5) Add corresponding pre-commit check so issues are caught earlier, 6) Document shell script standards in CONTRIBUTING.md.","acceptance_tests":["CI runs shellcheck on all shell scripts","CI fails if shell syntax errors exist","Pull requests blocked by shell script issues","Intentional syntax errors caught in CI"],"file":".github/workflows/ci.yml","line":1,"description":"CI workflow checks many things (ESLint, TypeScript, tests, patterns, security) but doesn't validate shell script syntax. Pre-commit hook is itself a shell script (.husky/pre-commit) - if it has syntax errors, commits can become blocked or validation can silently fail. .claude/hooks/ contains 6 critical shell scripts that run during development. A shell syntax error could break session-start.sh or pattern-check.sh, disrupting development flow. While these might work on developer's machine, different shell versions or environments could expose issues.","recommendation":"Add shell script validation to CI: 1) Install ShellCheck in CI environment (add to CI job steps), 2) Add step after 'Checkout code' named 'Validate shell scripts', 3) Run 'shellcheck .husky/pre-commit .husky/pre-push .claude/hooks/*.sh .claude/skills/**/*.sh', 4) Make blocking (don't use continue-on-error), 5) Add corresponding pre-commit check so issues are caught earlier, 6) Document shell script standards in CONTRIBUTING.md.","id":"process::N/A::ci-no-shell-syntax-check"}
{"category":"process","title":"Gap: No validation that new files are covered by appropriate checks","fingerprint":"process::N/A::new-files-coverage-check","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".husky/pre-commit:1"],"why_it_matters":"When new file types are added to the project (e.g., .proto files, .graphql, .tf for Terraform), there's no check that they're covered by linting, validation, or security checks. Pre-commit checks specific file types (.md for doc index, .jsonl for debt, .ts/.js for ESLint) but doesn't ensure NEW file types have appropriate validation. Could add Terraform files without terraform validate, GraphQL without schema validation, Protocol Buffers without protolint, etc. Gap would only be noticed during PR review or when issues occur.","suggested_fix":"Create new-file-type detection: 1) Add scripts/check-file-coverage.js that detects file extensions in repo, 2) Maintain config/known-file-types.json mapping extensions to their validators (e.g., .ts->ESLint+TypeScript, .sh->ShellCheck, .yml->yamllint), 3) Check if any committed files have extensions not in known list, 4) Warning in pre-commit (non-blocking), 5) Add 'coverage:files' npm script for manual checking, 6) Run in CI as informational (continue-on-error: true), 7) Prompt to add validation for new file types.","acceptance_tests":["New file types trigger coverage warnings","Known file types have documented validators","Adding .proto file without protolint shows warning","config/known-file-types.json is maintainable"],"file":".husky/pre-commit","line":1,"description":"When new file types are added to the project (e.g., .proto files, .graphql, .tf for Terraform), there's no check that they're covered by linting, validation, or security checks. Pre-commit checks specific file types (.md for doc index, .jsonl for debt, .ts/.js for ESLint) but doesn't ensure NEW file types have appropriate validation. Could add Terraform files without terraform validate, GraphQL without schema validation, Protocol Buffers without protolint, etc. Gap would only be noticed during PR review or when issues occur.","recommendation":"Create new-file-type detection: 1) Add scripts/check-file-coverage.js that detects file extensions in repo, 2) Maintain config/known-file-types.json mapping extensions to their validators (e.g., .ts->ESLint+TypeScript, .sh->ShellCheck, .yml->yamllint), 3) Check if any committed files have extensions not in known list, 4) Warning in pre-commit (non-blocking), 5) Add 'coverage:files' npm script for manual checking, 6) Run in CI as informational (continue-on-error: true), 7) Prompt to add validation for new file types.","id":"process::N/A::new-files-coverage-check"}
