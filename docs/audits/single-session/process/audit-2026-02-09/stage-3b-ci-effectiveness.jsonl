{"category":"process","title":"CI gap: pull_request_target security vulnerability allows untrusted code execution","fingerprint":"process::.github/workflows/deploy-firebase.yml::pull-request-target-risk","severity":"S0","effort":"E2","confidence":"HIGH","files":[".github/workflows/deploy-firebase.yml:7"],"why_it_matters":"Using pull_request_target with code checkout from PR head (line 32) allows malicious PRs to execute arbitrary code with repository secrets access. This is a well-documented GitHub Actions security anti-pattern that could lead to credential theft or repository compromise.","suggested_fix":"Replace pull_request_target with pull_request and use a separate workflow for preview deploys that runs after CI passes. Alternatively, use pull_request_target but only checkout base branch code, then merge PR changes in a sandboxed environment. See GitHub's security hardening guide.","acceptance_tests":["Preview deploys cannot access repository secrets","Malicious PR code cannot execute with elevated permissions","CI must pass before any deployment occurs"],"file":".github/workflows/deploy-firebase.yml","line":7,"description":"Using pull_request_target with code checkout from PR head (line 32) allows malicious PRs to execute arbitrary code with repository secrets access. This is a well-documented GitHub Actions security anti-pattern that could lead to credential theft or repository compromise.","recommendation":"Replace pull_request_target with pull_request and use a separate workflow for preview deploys that runs after CI passes. Alternatively, use pull_request_target but only checkout base branch code, then merge PR changes in a sandboxed environment. See GitHub's security hardening guide.","id":"process::.github/workflows/deploy-firebase.yml::pull-request-target-risk","evidence":[{"type":"code_reference","detail":".github/workflows/deploy-firebase.yml:7"},{"type":"description","detail":"Using pull_request_target with code checkout from PR head (line 32) allows malicious PRs to execute arbitrary code with repository secrets access. This is a well-documented GitHub Actions security anti-pattern that could lead to credential theft or repository compromise."}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".github/workflows/deploy-firebase.yml:7"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".github/workflows/deploy-firebase.yml:7"}}}
{"category":"process","title":"CI gap: No test coverage thresholds enforced","fingerprint":"process::.github/workflows/ci.yml::no-coverage-thresholds","severity":"S1","effort":"E1","confidence":"HIGH","files":[".github/workflows/ci.yml:115"],"why_it_matters":"Tests run with coverage reporting but there are no minimum thresholds configured. Code with 0% test coverage can pass CI, allowing untested code to merge. This defeats the purpose of coverage tracking.","suggested_fix":"Add c8 configuration with minimum thresholds (e.g., 70% lines, 60% branches). Update ci.yml line 115 to fail if thresholds not met: npm run test:coverage -- --check-coverage --lines 70 --branches 60","acceptance_tests":["CI fails when coverage drops below threshold","Coverage report shows current vs threshold values","Configuration is in version control (.c8rc.json)"],"file":".github/workflows/ci.yml","line":115,"description":"Tests run with coverage reporting but there are no minimum thresholds configured. Code with 0% test coverage can pass CI, allowing untested code to merge. This defeats the purpose of coverage tracking.","recommendation":"Add c8 configuration with minimum thresholds (e.g., 70% lines, 60% branches). Update ci.yml line 115 to fail if thresholds not met: npm run test:coverage -- --check-coverage --lines 70 --branches 60","id":"process::.github/workflows/ci.yml::no-coverage-thresholds","evidence":[{"type":"code_reference","detail":".github/workflows/ci.yml:115"},{"type":"description","detail":"Tests run with coverage reporting but there are no minimum thresholds configured. Code with 0% test coverage can pass CI, allowing untested code to merge. This defeats the purpose of coverage tracking."}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".github/workflows/ci.yml:115"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".github/workflows/ci.yml:115"}}}
{"category":"process","title":"CI gap: continue-on-error bypasses critical validations","fingerprint":"process::.github/workflows/ci.yml::continue-on-error-abuse","severity":"S2","effort":"E1","confidence":"HIGH","files":[".github/workflows/ci.yml:74",".github/workflows/ci.yml:79",".github/workflows/ci.yml:89",".github/workflows/ci.yml:106"],"why_it_matters":"Four validation steps use continue-on-error: pattern compliance on main (74), documentation check (79), audit validation (89), and technical debt views (106). These failures never block merges, allowing broken patterns, bad docs, invalid audits, and stale debt tracking to accumulate unnoticed.","suggested_fix":"Remove continue-on-error from all steps except known unstable checks. Make pattern compliance blocking for changed files. Add separate non-blocking 'advisory' job for experimental checks. Use required status checks in GitHub branch protection.","acceptance_tests":["Pattern compliance failures block PR merge","Documentation errors block merge","Audit validation errors block merge","Only explicitly marked experimental checks are non-blocking"],"file":".github/workflows/ci.yml","line":74,"description":"Four validation steps use continue-on-error: pattern compliance on main (74), documentation check (79), audit validation (89), and technical debt views (106). These failures never block merges, allowing broken patterns, bad docs, invalid audits, and stale debt tracking to accumulate unnoticed.","recommendation":"Remove continue-on-error from all steps except known unstable checks. Make pattern compliance blocking for changed files. Add separate non-blocking 'advisory' job for experimental checks. Use required status checks in GitHub branch protection.","id":"process::.github/workflows/ci.yml::continue-on-error-abuse"}
{"category":"process","title":"CI gap: Missing secrets cause silent build success","fingerprint":"process::.github/workflows/ci.yml::missing-secrets-silent","severity":"S2","effort":"E1","confidence":"HIGH","files":[".github/workflows/ci.yml:154-159"],"why_it_matters":"Build step uses secrets for Firebase config (lines 154-159). If secrets are missing or misconfigured, environment variables are set to empty strings and build succeeds. This hides configuration issues until runtime in production.","suggested_fix":"Add validation step before build: for secret in NEXT_PUBLIC_FIREBASE_API_KEY ...; do [[ -z $secret ]] && exit 1; done. Or use GitHub's required secrets feature and fail explicitly if not set.","acceptance_tests":["CI fails immediately if required secrets are missing","Build logs clearly indicate which secret is missing","Fork PRs can still build with placeholder values"],"file":".github/workflows/ci.yml","line":154,"description":"Build step uses secrets for Firebase config (lines 154-159). If secrets are missing or misconfigured, environment variables are set to empty strings and build succeeds. This hides configuration issues until runtime in production.","recommendation":"Add validation step before build: for secret in NEXT_PUBLIC_FIREBASE_API_KEY ...; do [[ -z $secret ]] && exit 1; done. Or use GitHub's required secrets feature and fail explicitly if not set.","id":"process::.github/workflows/ci.yml::missing-secrets-silent"}
{"category":"process","title":"CI gap: Pattern compliance only checks changed files in PRs","fingerprint":"process::.github/workflows/ci.yml::pattern-check-incomplete","severity":"S2","effort":"E2","confidence":"HIGH","files":[".github/workflows/ci.yml:58-68"],"why_it_matters":"Line 64 only checks changed files in PRs. If pattern rules are updated, existing violations in unchanged files are never caught. Pattern debt accumulates invisibly until someone touches those files. Also, if someone bypasses the check once, the violation persists forever.","suggested_fix":"Run full pattern check on a schedule (weekly) and post issues for violations. Or run full check on PRs that modify pattern rules themselves. Consider making pattern check blocking only for new violations but report existing ones.","acceptance_tests":["Weekly scheduled job reports all pattern violations","PRs that modify .claude/pattern-rules.jsonl trigger full check","Existing violations are tracked and reported but don't block new PRs"],"file":".github/workflows/ci.yml","line":58,"description":"Line 64 only checks changed files in PRs. If pattern rules are updated, existing violations in unchanged files are never caught. Pattern debt accumulates invisibly until someone touches those files. Also, if someone bypasses the check once, the violation persists forever.","recommendation":"Run full pattern check on a schedule (weekly) and post issues for violations. Or run full check on PRs that modify pattern rules themselves. Consider making pattern check blocking only for new violations but report existing ones.","id":"process::.github/workflows/ci.yml::pattern-check-incomplete"}
{"category":"process","title":"CI gap: Build job re-installs dependencies wastefully","fingerprint":"process::.github/workflows/ci.yml::no-dependency-caching","severity":"S2","effort":"E2","confidence":"MEDIUM","files":[".github/workflows/ci.yml:136-149"],"why_it_matters":"Build job (lines 136-149) runs after lint-typecheck-test but re-installs all dependencies and rebuilds from scratch. This wastes 2-5 minutes per CI run and increases risk of dependency resolution differences between jobs.","suggested_fix":"Cache node_modules as artifact in first job and restore in build job. Or combine jobs into single job with multiple steps. Or use Docker layer caching. Document reason if separate jobs are required.","acceptance_tests":["Build job reuses artifacts from test job","CI runtime reduced by 2+ minutes","Cache hit rate is >90% for typical PRs"],"file":".github/workflows/ci.yml","line":136,"description":"Build job (lines 136-149) runs after lint-typecheck-test but re-installs all dependencies and rebuilds from scratch. This wastes 2-5 minutes per CI run and increases risk of dependency resolution differences between jobs.","recommendation":"Cache node_modules as artifact in first job and restore in build job. Or combine jobs into single job with multiple steps. Or use Docker layer caching. Document reason if separate jobs are required.","id":"process::.github/workflows/ci.yml::no-dependency-caching"}
{"category":"process","title":"CI gap: Race condition in tier label assignment","fingerprint":"process::.github/workflows/auto-label-review-tier.yml::label-race-condition","severity":"S2","effort":"E2","confidence":"MEDIUM","files":[".github/workflows/auto-label-review-tier.yml:77-150"],"why_it_matters":"Label removal (lines 77-100) and addition (101-150) are separate steps. If workflow runs twice concurrently on rapid PR updates, labels can get into inconsistent state (e.g., both tier-2 and tier-3 present, or no tier label at all).","suggested_fix":"Use GitHub API's replaceLabels operation which is atomic. Or add concurrency group keyed on PR number with cancel-in-progress: true. Or use a single API call that removes and adds in one transaction.","acceptance_tests":["Concurrent workflow runs don't create duplicate tier labels","Tier label is always exactly one of tier-0 through tier-4","Race condition testing with rapid PR pushes"],"file":".github/workflows/auto-label-review-tier.yml","line":77,"description":"Label removal (lines 77-100) and addition (101-150) are separate steps. If workflow runs twice concurrently on rapid PR updates, labels can get into inconsistent state (e.g., both tier-2 and tier-3 present, or no tier label at all).","recommendation":"Use GitHub API's replaceLabels operation which is atomic. Or add concurrency group keyed on PR number with cancel-in-progress: true. Or use a single API call that removes and adds in one transaction.","id":"process::.github/workflows/auto-label-review-tier.yml::label-race-condition"}
{"category":"process","title":"CI gap: Inline tier assignment logic creates maintenance drift","fingerprint":"process::.github/workflows/auto-label-review-tier.yml::duplicate-tier-logic","severity":"S2","effort":"E2","confidence":"HIGH","files":[".github/workflows/auto-label-review-tier.yml:60-75"],"why_it_matters":"Lines 60-75 contain inline bash logic that duplicates scripts/assign-review-tier.js. Comment says 'TODO: Uncomment when script is ready' but script exists and is referenced. This technical debt causes maintenance burden and drift between workflow and script logic.","suggested_fix":"Remove TODO placeholder logic and uncomment line 56 to use the actual script. Or if script needs updates, fix it first then switch. Add test that workflow and script produce same tier for sample file sets.","acceptance_tests":["Workflow uses scripts/assign-review-tier.js not inline bash","Tier assignment logic exists in only one place","Tests verify consistency between workflow and script"],"file":".github/workflows/auto-label-review-tier.yml","line":60,"description":"Lines 60-75 contain inline bash logic that duplicates scripts/assign-review-tier.js. Comment says 'TODO: Uncomment when script is ready' but script exists and is referenced. This technical debt causes maintenance burden and drift between workflow and script logic.","recommendation":"Remove TODO placeholder logic and uncomment line 56 to use the actual script. Or if script needs updates, fix it first then switch. Add test that workflow and script produce same tier for sample file sets.","id":"process::.github/workflows/auto-label-review-tier.yml::duplicate-tier-logic"}
{"category":"process","title":"CI gap: Fork PRs completely skip SonarCloud analysis","fingerprint":"process::.github/workflows/sonarcloud.yml::skip-fork-prs","severity":"S2","effort":"E2","confidence":"HIGH","files":[".github/workflows/sonarcloud.yml:22-24"],"why_it_matters":"Lines 22-24 skip SonarCloud analysis for all fork PRs because secrets aren't available. External contributions get zero static analysis, allowing security issues, code smells, and bugs to merge without detection. This is especially risky since forks are more likely to introduce novel bugs.","suggested_fix":"Run SonarCloud on a schedule against main branch to catch issues after merge. Or use pull_request_target carefully to analyze fork code (but see security implications). Or require maintainers to manually trigger analysis before merging fork PRs.","acceptance_tests":["Fork PR code is analyzed within 24 hours of merge","Security hotspots in fork PRs are detected before or soon after merge","Analysis results are visible to PR reviewers"],"file":".github/workflows/sonarcloud.yml","line":22,"description":"Lines 22-24 skip SonarCloud analysis for all fork PRs because secrets aren't available. External contributions get zero static analysis, allowing security issues, code smells, and bugs to merge without detection. This is especially risky since forks are more likely to introduce novel bugs.","recommendation":"Run SonarCloud on a schedule against main branch to catch issues after merge. Or use pull_request_target carefully to analyze fork code (but see security implications). Or require maintainers to manually trigger analysis before merging fork PRs.","id":"process::.github/workflows/sonarcloud.yml::skip-fork-prs"}
{"category":"process","title":"CI gap: Firebase deployment has no success validation","fingerprint":"process::.github/workflows/deploy-firebase.yml::no-deployment-validation","severity":"S2","effort":"E2","confidence":"HIGH","files":[".github/workflows/deploy-firebase.yml:140-147"],"why_it_matters":"Lines 140-147 deploy functions, rules, and hosting but don't verify deployment actually succeeded. Firebase CLI can exit 0 even if deployment partially failed. Broken deployments may go unnoticed until users report issues.","suggested_fix":"Add validation steps after each deploy: query Firebase to confirm functions are deployed and callable, test firestore rules with sample operations, curl hosting URL to verify it returns 200. Fail workflow if validation fails.","acceptance_tests":["Deployment validation catches broken function deploys","Firestore rules are tested after deployment","Hosting URL is accessible and returns expected content","Failed deployments trigger immediate alerts"],"file":".github/workflows/deploy-firebase.yml","line":140,"description":"Lines 140-147 deploy functions, rules, and hosting but don't verify deployment actually succeeded. Firebase CLI can exit 0 even if deployment partially failed. Broken deployments may go unnoticed until users report issues.","recommendation":"Add validation steps after each deploy: query Firebase to confirm functions are deployed and callable, test firestore rules with sample operations, curl hosting URL to verify it returns 200. Fail workflow if validation fails.","id":"process::.github/workflows/deploy-firebase.yml::no-deployment-validation"}
{"category":"process","title":"CI gap: Deployment has no rollback mechanism","fingerprint":"process::.github/workflows/deploy-firebase.yml::no-rollback","severity":"S2","effort":"E3","confidence":"MEDIUM","files":[".github/workflows/deploy-firebase.yml:140-147"],"why_it_matters":"Deployment steps run sequentially (lines 140-147) but if one fails, there's no rollback. A partial deployment could leave production in inconsistent state (e.g., new functions deployed but old hosting, or new rules but old functions).","suggested_fix":"Add rollback step that runs on failure: capture previous deployment SHA before deploy, on failure run firebase deploy with previous version. Or use Firebase's rollback API. Or deploy to staging first, validate, then promote.","acceptance_tests":["Failed deployments automatically roll back to last known good state","Production is never in partially-deployed state","Rollback is tested in staging environment"],"file":".github/workflows/deploy-firebase.yml","line":140,"description":"Deployment steps run sequentially (lines 140-147) but if one fails, there's no rollback. A partial deployment could leave production in inconsistent state (e.g., new functions deployed but old hosting, or new rules but old functions).","recommendation":"Add rollback step that runs on failure: capture previous deployment SHA before deploy, on failure run firebase deploy with previous version. Or use Firebase's rollback API. Or deploy to staging first, validate, then promote.","id":"process::.github/workflows/deploy-firebase.yml::no-rollback"}
{"category":"process","title":"CI gap: Service account credentials written to filesystem","fingerprint":"process::.github/workflows/deploy-firebase.yml::credentials-filesystem-risk","severity":"S2","effort":"E1","confidence":"HIGH","files":[".github/workflows/deploy-firebase.yml:120-124"],"why_it_matters":"Lines 120-124 write service account JSON to $HOME/gcloud-key.json. If subsequent steps fail or are compromised, credentials could be leaked in logs, artifacts, or through file disclosure. File is only cleaned up in always() block which might not run if workflow is cancelled.","suggested_fix":"Use Google's official auth action which handles credentials securely without writing to disk. Or use base64 encode/pipe: echo $SECRET | base64 -d | gcloud auth activate-service-account --key-file=-. Ensure cleanup happens even on workflow cancellation.","acceptance_tests":["Credentials are never written to disk in plain text","Workflow cancellation doesn't leave credentials on runner","Credentials don't appear in any logs or artifacts"],"file":".github/workflows/deploy-firebase.yml","line":120,"description":"Lines 120-124 write service account JSON to $HOME/gcloud-key.json. If subsequent steps fail or are compromised, credentials could be leaked in logs, artifacts, or through file disclosure. File is only cleaned up in always() block which might not run if workflow is cancelled.","recommendation":"Use Google's official auth action which handles credentials securely without writing to disk. Or use base64 encode/pipe: echo $SECRET | base64 -d | gcloud auth activate-service-account --key-file=-. Ensure cleanup happens even on workflow cancellation.","id":"process::.github/workflows/deploy-firebase.yml::credentials-filesystem-risk"}
{"category":"process","title":"CI gap: Deleting functions uses continue-on-error hiding real failures","fingerprint":"process::.github/workflows/deploy-firebase.yml::function-delete-masked","severity":"S3","effort":"E1","confidence":"MEDIUM","files":[".github/workflows/deploy-firebase.yml:131-138"],"why_it_matters":"Line 138 uses continue-on-error for function deletion. This is intended to handle 'function doesn't exist' but also hides real errors like authentication failures, permission issues, or API outages. These failures should block deployment.","suggested_fix":"Check if function exists before deleting: firebase functions:list | grep -q functionName && firebase functions:delete functionName. Or capture error message and only ignore specific 404-style errors. Fail on auth/permission/API errors.","acceptance_tests":["Workflow fails on auth/permission errors during function deletion","Workflow succeeds when function doesn't exist (expected case)","Unexpected errors are surfaced, not hidden"],"file":".github/workflows/deploy-firebase.yml","line":131,"description":"Line 138 uses continue-on-error for function deletion. This is intended to handle 'function doesn't exist' but also hides real errors like authentication failures, permission issues, or API outages. These failures should block deployment.","recommendation":"Check if function exists before deleting: firebase functions:list | grep -q functionName && firebase functions:delete functionName. Or capture error message and only ignore specific 404-style errors. Fail on auth/permission/API errors.","id":"process::.github/workflows/deploy-firebase.yml::function-delete-masked"}
{"category":"process","title":"CI gap: Preview and production use different env var sources","fingerprint":"process::.github/workflows/deploy-firebase.yml::env-var-inconsistency","severity":"S3","effort":"E2","confidence":"HIGH","files":[".github/workflows/deploy-firebase.yml:51",".github/workflows/deploy-firebase.yml:104"],"why_it_matters":"Preview deploy (line 51) uses vars.* (GitHub environment variables) while production (line 104) uses secrets.*. This inconsistency means preview and production builds could have different configurations, making preview testing unreliable and potentially hiding config issues.","suggested_fix":"Use same source for both (either both vars or both secrets). Document why they're different if intentional. Add validation that all required env vars are present in both sources. Consider using a config file instead.","acceptance_tests":["Preview and production use identical env var values","Config differences are documented and intentional","Tests verify preview behaves like production"],"file":".github/workflows/deploy-firebase.yml","line":51,"description":"Preview deploy (line 51) uses vars.* (GitHub environment variables) while production (line 104) uses secrets.*. This inconsistency means preview and production builds could have different configurations, making preview testing unreliable and potentially hiding config issues.","recommendation":"Use same source for both (either both vars or both secrets). Document why they're different if intentional. Add validation that all required env vars are present in both sources. Consider using a config file instead.","id":"process::.github/workflows/deploy-firebase.yml::env-var-inconsistency"}
{"category":"process","title":"CI gap: Backlog check gracefully skips with no replacement validation","fingerprint":"process::.github/workflows/backlog-enforcement.yml::missing-replacement-check","severity":"S3","effort":"E1","confidence":"MEDIUM","files":[".github/workflows/backlog-enforcement.yml:35-42"],"why_it_matters":"Lines 35-42 gracefully skip if AUDIT_FINDINGS_BACKLOG.md doesn't exist (archived per comment), but there's no check that replacement MASTER_DEBT.jsonl exists and is valid. Backlog tracking could silently break if neither file exists.","suggested_fix":"Add elif check: if [ -f docs/technical-debt/MASTER_DEBT.jsonl ]; then run new validation; else fail with error. Or integrate with existing TDMS validation in ci.yml. Ensure one source of truth is always validated.","acceptance_tests":["Workflow fails if neither backlog file exists","MASTER_DEBT.jsonl is validated when present","Migration from old to new system is tracked"],"file":".github/workflows/backlog-enforcement.yml","line":35,"description":"Lines 35-42 gracefully skip if AUDIT_FINDINGS_BACKLOG.md doesn't exist (archived per comment), but there's no check that replacement MASTER_DEBT.jsonl exists and is valid. Backlog tracking could silently break if neither file exists.","recommendation":"Add elif check: if [ -f docs/technical-debt/MASTER_DEBT.jsonl ]; then run new validation; else fail with error. Or integrate with existing TDMS validation in ci.yml. Ensure one source of truth is always validated.","id":"process::.github/workflows/backlog-enforcement.yml::missing-replacement-check"}
{"category":"process","title":"CI gap: Security pattern check runs file-by-file inefficiently","fingerprint":"process::.github/workflows/backlog-enforcement.yml::inefficient-security-loop","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".github/workflows/backlog-enforcement.yml:147-150"],"why_it_matters":"Lines 147-150 run security-check.js in a loop for each changed file. This is inefficient (spawns N processes), doesn't aggregate results, and could hide failures in earlier iterations. Also prevents batch optimizations in the script.","suggested_fix":"Modify security-check.js to accept multiple files: node scripts/security-check.js --files file1 file2 file3. Or pass all files via stdin. Aggregate results and report summary. Run once instead of N times.","acceptance_tests":["Security check runs once per workflow, not per file","All violations are reported in single summary","Performance improves for PRs with many changed files"],"file":".github/workflows/backlog-enforcement.yml","line":147,"description":"Lines 147-150 run security-check.js in a loop for each changed file. This is inefficient (spawns N processes), doesn't aggregate results, and could hide failures in earlier iterations. Also prevents batch optimizations in the script.","recommendation":"Modify security-check.js to accept multiple files: node scripts/security-check.js --files file1 file2 file3. Or pass all files via stdin. Aggregate results and report summary. Run once instead of N times.","id":"process::.github/workflows/backlog-enforcement.yml::inefficient-security-loop"}
{"category":"process","title":"CI gap: Documentation linting skips archive files entirely","fingerprint":"process::.github/workflows/docs-lint.yml::archives-never-checked","severity":"S3","effort":"E1","confidence":"MEDIUM","files":[".github/workflows/docs-lint.yml:78-81"],"why_it_matters":"Lines 78-81 skip archive files completely. While archives are historical, broken links and formatting issues make them harder to reference. If someone needs to consult archived docs, broken content creates confusion and wastes time.","suggested_fix":"Create separate non-blocking job for archive linting. Report issues but don't block PRs. Or run archive lint on a schedule. Or document that archives are explicitly not maintained and add warning banner to archive docs.","acceptance_tests":["Archive files are linted separately","Archive lint issues are reported but non-blocking","Archive docs have warning banner about potential staleness"],"file":".github/workflows/docs-lint.yml","line":78,"description":"Lines 78-81 skip archive files completely. While archives are historical, broken links and formatting issues make them harder to reference. If someone needs to consult archived docs, broken content creates confusion and wastes time.","recommendation":"Create separate non-blocking job for archive linting. Report issues but don't block PRs. Or run archive lint on a schedule. Or document that archives are explicitly not maintained and add warning banner to archive docs.","id":"process::.github/workflows/docs-lint.yml::archives-never-checked"}
{"category":"process","title":"CI gap: Resolve debt workflow only runs on merged PRs","fingerprint":"process::.github/workflows/resolve-debt.yml::closed-pr-skip","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".github/workflows/resolve-debt.yml:11"],"why_it_matters":"Line 11 only triggers on merged PRs. If a PR mentions DEBT-123 but is closed without merging, the debt item is never updated to reflect the cancelled work. This causes debt tracking to become stale and inaccurate.","suggested_fix":"Add separate step for closed-without-merge PRs: update debt items to add comment 'PR #123 closed without merging' and revert status if it was changed. Or don't auto-update debt items at all, require manual resolution.","acceptance_tests":["Closed PRs update debt items with closure reason","Debt items track both merged and unmerged attempts","Debt status is accurate regardless of PR outcome"],"file":".github/workflows/resolve-debt.yml","line":11,"description":"Line 11 only triggers on merged PRs. If a PR mentions DEBT-123 but is closed without merging, the debt item is never updated to reflect the cancelled work. This causes debt tracking to become stale and inaccurate.","recommendation":"Add separate step for closed-without-merge PRs: update debt items to add comment 'PR #123 closed without merging' and revert status if it was changed. Or don't auto-update debt items at all, require manual resolution.","id":"process::.github/workflows/resolve-debt.yml::closed-pr-skip"}
{"category":"process","title":"CI gap: Debt resolution skips CI with [skip ci]","fingerprint":"process::.github/workflows/resolve-debt.yml::skip-ci-debt","severity":"S3","effort":"E1","confidence":"HIGH","files":[".github/workflows/resolve-debt.yml:88"],"why_it_matters":"Line 88 includes [skip ci] in commit message. This means debt resolution commits bypass all CI checks including validation of the debt file structure, pattern compliance, and any other checks. Malformed debt commits could merge without detection.","suggested_fix":"Remove [skip ci] and let normal CI run. Debt resolution should be validated like any other commit. If CI is too slow, optimize CI rather than skipping it. Or use more specific skip flag that only skips expensive tests.","acceptance_tests":["Debt resolution commits run through full CI","MASTER_DEBT.jsonl validation catches malformed resolutions","No commits bypass CI except explicitly documented exceptions"],"file":".github/workflows/resolve-debt.yml","line":88,"description":"Line 88 includes [skip ci] in commit message. This means debt resolution commits bypass all CI checks including validation of the debt file structure, pattern compliance, and any other checks. Malformed debt commits could merge without detection.","recommendation":"Remove [skip ci] and let normal CI run. Debt resolution should be validated like any other commit. If CI is too slow, optimize CI rather than skipping it. Or use more specific skip flag that only skips expensive tests.","id":"process::.github/workflows/resolve-debt.yml::skip-ci-debt"}
{"category":"process","title":"CI gap: Debt resolution has race condition on rebase","fingerprint":"process::.github/workflows/resolve-debt.yml::rebase-race","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".github/workflows/resolve-debt.yml:92"],"why_it_matters":"Line 92 does git pull --rebase to handle case where main moved after checkout. But if another workflow pushes between pull and push, this fails. Multiple merged PRs in quick succession can cause workflow failures and failed debt resolution.","suggested_fix":"Add retry loop like sync-readme.yml (lines 64-78). Or use GitHub's REST API to create commits instead of git push. Or add concurrency group to serialize debt resolution commits.","acceptance_tests":["Concurrent merges don't cause debt resolution failures","Retry logic handles race conditions","Failed debt resolutions are retried automatically"],"file":".github/workflows/resolve-debt.yml","line":92,"description":"Line 92 does git pull --rebase to handle case where main moved after checkout. But if another workflow pushes between pull and push, this fails. Multiple merged PRs in quick succession can cause workflow failures and failed debt resolution.","recommendation":"Add retry loop like sync-readme.yml (lines 64-78). Or use GitHub's REST API to create commits instead of git push. Or add concurrency group to serialize debt resolution commits.","id":"process::.github/workflows/resolve-debt.yml::rebase-race"}
{"category":"process","title":"CI gap: Review trigger check has fragile JSON validation","fingerprint":"process::.github/workflows/review-check.yml::complex-json-parse","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".github/workflows/review-check.yml:46-50"],"why_it_matters":"Lines 46-50 have complex JSON validation using piped node one-liner. If this fails, output is replaced with error JSON but parsing errors are silently swallowed. Malformed JSON could cause workflow to incorrectly mark PRs as needing review.","suggested_fix":"Simplify validation: use jq or node -p 'JSON.parse(process.argv[1])' $OUTPUT. If validation fails, fail the workflow explicitly rather than substituting error JSON. Log original output for debugging.","acceptance_tests":["Invalid JSON from script fails workflow with clear error","Error messages show actual script output","Review needed determination is accurate"],"file":".github/workflows/review-check.yml","line":46,"description":"Lines 46-50 have complex JSON validation using piped node one-liner. If this fails, output is replaced with error JSON but parsing errors are silently swallowed. Malformed JSON could cause workflow to incorrectly mark PRs as needing review.","recommendation":"Simplify validation: use jq or node -p 'JSON.parse(process.argv[1])' $OUTPUT. If validation fails, fail the workflow explicitly rather than substituting error JSON. Log original output for debugging.","id":"process::.github/workflows/review-check.yml::complex-json-parse"}
{"category":"process","title":"CI gap: Review check uses continue-on-error hiding crashes","fingerprint":"process::.github/workflows/review-check.yml::continue-hides-crashes","severity":"S3","effort":"E1","confidence":"MEDIUM","files":[".github/workflows/review-check.yml:33"],"why_it_matters":"Line 33 has continue-on-error which means if check-review-needed.js crashes (OOM, unhandled exception, etc), workflow continues and treats it as 'review needed'. This creates false positives and alert fatigue. Real errors should be fixed, not hidden.","suggested_fix":"Remove continue-on-error. Let script failures fail the workflow. Fix the script to handle errors gracefully and return proper exit codes. Use workflow retry for transient failures.","acceptance_tests":["Script crashes fail the workflow","Exit codes correctly map to review needed vs not needed","Transient failures are retried automatically"],"file":".github/workflows/review-check.yml","line":33,"description":"Line 33 has continue-on-error which means if check-review-needed.js crashes (OOM, unhandled exception, etc), workflow continues and treats it as 'review needed'. This creates false positives and alert fatigue. Real errors should be fixed, not hidden.","recommendation":"Remove continue-on-error. Let script failures fail the workflow. Fix the script to handle errors gracefully and return proper exit codes. Use workflow retry for transient failures.","id":"process::.github/workflows/review-check.yml::continue-hides-crashes"}
{"category":"process","title":"CI gap: Phase validation workflow is likely dead code","fingerprint":"process::.github/workflows/validate-plan.yml::dead-workflow","severity":"S3","effort":"E1","confidence":"HIGH","files":[".github/workflows/validate-plan.yml:7"],"why_it_matters":"Line 7 only triggers for changes to docs/archive/completed-plans/INTEGRATED_IMPROVEMENT_PLAN.md which is an archived document. This workflow never runs on modern changes. Dead code creates maintenance burden and confusion.","suggested_fix":"Delete the workflow and document in commit message that phase validation is now handled elsewhere. Or update path to current planning documents. Or disable workflow explicitly with if: false.","acceptance_tests":["Dead workflows are removed","Active workflows are documented","Workflow list is reviewed quarterly for dead code"],"file":".github/workflows/validate-plan.yml","line":7,"description":"Line 7 only triggers for changes to docs/archive/completed-plans/INTEGRATED_IMPROVEMENT_PLAN.md which is an archived document. This workflow never runs on modern changes. Dead code creates maintenance burden and confusion.","recommendation":"Delete the workflow and document in commit message that phase validation is now handled elsewhere. Or update path to current planning documents. Or disable workflow explicitly with if: false.","id":"process::.github/workflows/validate-plan.yml::dead-workflow"}
{"category":"process","title":"CI gap: Sync README has fragile retry logic","fingerprint":"process::.github/workflows/sync-readme.yml::fragile-retry","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".github/workflows/sync-readme.yml:64-78"],"why_it_matters":"Lines 64-78 retry push 3 times with 5-second sleep. This is fragile: assumes conflicts resolve within 5s, doesn't backoff exponentially, and 3 retries may not be enough if multiple workflows queue up. Also mixes pull --rebase with retry which could compound conflicts.","suggested_fix":"Use exponential backoff: sleep $((i * i * 5)). Increase retries to 5. Use GitHub API to create commits instead of git push to avoid git-level races. Or use concurrency group to serialize commits.","acceptance_tests":["Retry logic handles burst of concurrent pushes","Exponential backoff prevents thundering herd","Success rate is >99% for typical concurrent scenarios"],"file":".github/workflows/sync-readme.yml","line":64,"description":"Lines 64-78 retry push 3 times with 5-second sleep. This is fragile: assumes conflicts resolve within 5s, doesn't backoff exponentially, and 3 retries may not be enough if multiple workflows queue up. Also mixes pull --rebase with retry which could compound conflicts.","recommendation":"Use exponential backoff: sleep $((i * i * 5)). Increase retries to 5. Use GitHub API to create commits instead of git push to avoid git-level races. Or use concurrency group to serialize commits.","id":"process::.github/workflows/sync-readme.yml::fragile-retry"}
{"category":"process","title":"CI gap: Sync README uses --no-verify bypassing hooks","fingerprint":"process::.github/workflows/sync-readme.yml::no-verify-bypass","severity":"S3","effort":"E1","confidence":"HIGH","files":[".github/workflows/sync-readme.yml:57"],"why_it_matters":"Line 57 uses --no-verify which bypasses pre-commit hooks. If hooks check for commit message format, trailing whitespace, or other issues, README sync commits could violate standards. This creates inconsistency in commit history.","suggested_fix":"Remove --no-verify unless there's specific reason (document reason if so). Let hooks run to ensure consistency. If hooks are too slow for automation, optimize hooks rather than skipping them.","acceptance_tests":["README sync commits follow same standards as manual commits","Hooks run on all commits except explicitly documented exceptions","Commit history is consistent"],"file":".github/workflows/sync-readme.yml","line":57,"description":"Line 57 uses --no-verify which bypasses pre-commit hooks. If hooks check for commit message format, trailing whitespace, or other issues, README sync commits could violate standards. This creates inconsistency in commit history.","recommendation":"Remove --no-verify unless there's specific reason (document reason if so). Let hooks run to ensure consistency. If hooks are too slow for automation, optimize hooks rather than skipping them.","id":"process::.github/workflows/sync-readme.yml::no-verify-bypass"}
{"category":"process","title":"CI gap: Inconsistent GitHub Action version pinning","fingerprint":"process::.github/workflows/*::inconsistent-pinning","severity":"S3","effort":"E2","confidence":"HIGH","files":[".github/workflows/ci.yml:45",".github/workflows/auto-label-review-tier.yml:29",".github/workflows/backlog-enforcement.yml:18"],"why_it_matters":"Some workflows use SHA pinning for security (ci.yml line 45, backlog-enforcement.yml line 18) while others use semantic versions (auto-label-review-tier.yml line 29 uses @v46). Inconsistent pinning creates security gaps and makes supply chain attacks easier.","suggested_fix":"Adopt consistent pinning strategy: either pin all actions to SHAs with comments showing version, or use Dependabot to keep semantic versions updated. Document strategy in CONTRIBUTING.md.","acceptance_tests":["All critical workflows use SHA pinning","Dependabot keeps action versions updated","Pinning strategy is documented"],"file":".github/workflows/ci.yml","line":45,"description":"Some workflows use SHA pinning for security (ci.yml line 45, backlog-enforcement.yml line 18) while others use semantic versions (auto-label-review-tier.yml line 29 uses @v46). Inconsistent pinning creates security gaps and makes supply chain attacks easier.","recommendation":"Adopt consistent pinning strategy: either pin all actions to SHAs with comments showing version, or use Dependabot to keep semantic versions updated. Document strategy in CONTRIBUTING.md.","id":"process::.github/workflows/*::inconsistent-pinning"}
{"category":"process","title":"CI gap: No validation of Node.js version consistency","fingerprint":"process::.github/workflows/ci.yml::no-node-version-check","severity":"S3","effort":"E1","confidence":"MEDIUM","files":[".github/workflows/ci.yml:21"],"why_it_matters":"Line 21 hardcodes Node 22 but there's no check that this matches package.json engines field or .nvmrc. Developers could use different Node version locally, causing 'works on my machine' issues. CI should enforce version consistency.","suggested_fix":"Add .nvmrc or package.json engines field with required Node version. Change workflow to read version from file: node-version-file: '.nvmrc'. Add pre-commit hook to check local Node version matches.","acceptance_tests":["CI uses same Node version as specified in .nvmrc","Local development enforces correct Node version","Version mismatches are caught before CI"],"file":".github/workflows/ci.yml","line":21,"description":"Line 21 hardcodes Node 22 but there's no check that this matches package.json engines field or .nvmrc. Developers could use different Node version locally, causing 'works on my machine' issues. CI should enforce version consistency.","recommendation":"Add .nvmrc or package.json engines field with required Node version. Change workflow to read version from file: node-version-file: '.nvmrc'. Add pre-commit hook to check local Node version matches.","id":"process::.github/workflows/ci.yml::no-node-version-check"}
{"category":"process","title":"CI gap: Template file exclusion is brittle regex","fingerprint":"process::.github/workflows/docs-lint.yml::template-regex-brittle","severity":"S3","effort":"E1","confidence":"MEDIUM","files":[".github/workflows/docs-lint.yml:72-75"],"why_it_matters":"Lines 72-75 use regex patterns to skip template files: (TEMPLATE|_TEMPLATE)\\.md$. A file named TEMPLATE-proposal.md or my-TEMPLATE.md wouldn't match and would be incorrectly linted. Brittle pattern matching causes false positives.","suggested_fix":"Use more specific paths: if [[ $file =~ ^docs/templates/ ]]; then skip. Or maintain list of template files in config. Or add header to templates that linter detects. Make pattern matching more robust.","acceptance_tests":["All template files are correctly skipped","Non-template files with 'template' in name are linted","Pattern matching is tested with edge cases"],"file":".github/workflows/docs-lint.yml","line":72,"description":"Lines 72-75 use regex patterns to skip template files: (TEMPLATE|_TEMPLATE)\\.md$. A file named TEMPLATE-proposal.md or my-TEMPLATE.md wouldn't match and would be incorrectly linted. Brittle pattern matching causes false positives.","recommendation":"Use more specific paths: if [[ $file =~ ^docs/templates/ ]]; then skip. Or maintain list of template files in config. Or add header to templates that linter detects. Make pattern matching more robust.","id":"process::.github/workflows/docs-lint.yml::template-regex-brittle"}
{"category":"process","title":"CI gap: Markdown injection sanitization incomplete","fingerprint":"process::.github/workflows/docs-lint.yml::markdown-injection-incomplete","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".github/workflows/docs-lint.yml:91"],"why_it_matters":"Line 91 sanitizes ``` to prevent markdown injection but doesn't handle other vectors like [clickjacking](javascript:alert(1)) or HTML tags. Malicious or buggy docs could inject content into PR comments.","suggested_fix":"Use comprehensive sanitization library or render lint output as code block (which GitHub auto-escapes). Or limit output length and use GitHub's built-in comment rendering which sanitizes HTML.","acceptance_tests":["Malicious markdown in docs doesn't execute in PR comments","All user-controlled content is sanitized","XSS and injection vectors are tested"],"file":".github/workflows/docs-lint.yml","line":91,"description":"Line 91 sanitizes ``` to prevent markdown injection but doesn't handle other vectors like [clickjacking](javascript:alert(1)) or HTML tags. Malicious or buggy docs could inject content into PR comments.","recommendation":"Use comprehensive sanitization library or render lint output as code block (which GitHub auto-escapes). Or limit output length and use GitHub's built-in comment rendering which sanitizes HTML.","id":"process::.github/workflows/docs-lint.yml::markdown-injection-incomplete"}
{"category":"process","title":"CI gap: Changed files detection could miss merge commits","fingerprint":"process::.github/workflows/backlog-enforcement.yml::git-diff-merge-commits","severity":"S3","effort":"E2","confidence":"MEDIUM","files":[".github/workflows/backlog-enforcement.yml:127"],"why_it_matters":"Line 127 uses git diff origin/$BASE...HEAD which could miss files in merge commits depending on git configuration. Three-dot diff shows changes since common ancestor, but merge commits might introduce changes not in either parent.","suggested_fix":"Use two-dot diff: git diff origin/$BASE..HEAD. Or use GitHub's changed files API which is authoritative. Or use tj-actions/changed-files action like other workflows for consistency.","acceptance_tests":["All changed files are detected including merge commits","Changed file detection is consistent across workflows","Edge cases like merge commits are tested"],"file":".github/workflows/backlog-enforcement.yml","line":127,"description":"Line 127 uses git diff origin/$BASE...HEAD which could miss files in merge commits depending on git configuration. Three-dot diff shows changes since common ancestor, but merge commits might introduce changes not in either parent.","recommendation":"Use two-dot diff: git diff origin/$BASE..HEAD. Or use GitHub's changed files API which is authoritative. Or use tj-actions/changed-files action like other workflows for consistency.","id":"process::.github/workflows/backlog-enforcement.yml::git-diff-merge-commits"}
{"category":"process","title":"CI gap: Tier comment spam on every synchronize event","fingerprint":"process::.github/workflows/auto-label-review-tier.yml::comment-on-synchronize","severity":"S4","effort":"E1","confidence":"HIGH","files":[".github/workflows/auto-label-review-tier.yml:186"],"why_it_matters":"Line 186 only posts comment on opened/reopened, not synchronize. This is good for avoiding spam, but if tier changes due to new files added, PR author doesn't get notified. They might miss important tier escalation (e.g., tier 2 -> tier 4).","suggested_fix":"Post comment on synchronize only if tier label changed. Track previous tier in workflow state or by reading PR labels. Notify author when tier increases (escalation) but not when it stays same.","acceptance_tests":["Comment posted when tier changes","No comment spam on every push","Tier escalation notifications are prominent"],"file":".github/workflows/auto-label-review-tier.yml","line":186,"description":"Line 186 only posts comment on opened/reopened, not synchronize. This is good for avoiding spam, but if tier changes due to new files added, PR author doesn't get notified. They might miss important tier escalation (e.g., tier 2 -> tier 4).","recommendation":"Post comment on synchronize only if tier label changed. Track previous tier in workflow state or by reading PR labels. Notify author when tier increases (escalation) but not when it stays same.","id":"process::.github/workflows/auto-label-review-tier.yml::comment-on-synchronize"}
