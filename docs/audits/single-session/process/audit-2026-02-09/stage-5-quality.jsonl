{"category":"process","title":"Error handling: Empty catch blocks swallow errors in gsd-check-update.js","fingerprint":"process::.claude/hooks/global/gsd-check-update.js::empty-catch-blocks","severity":"S1","effort":"E1","confidence":"HIGH","files":[".claude/hooks/global/gsd-check-update.js:38",".claude/hooks/global/gsd-check-update.js:43"],"why_it_matters":"Silent failures in version checking hide network issues and file read errors, preventing users from knowing updates are available","suggested_fix":"Log errors to stderr or a debug log file. Example: catch (e) { console.error('Failed to check GSD version:', e.message); }","acceptance_tests":["Errors are logged when version file is unreadable","Errors are logged when npm registry is unreachable","Debug information helps troubleshoot update check failures"],"file":".claude/hooks/global/gsd-check-update.js","line":38,"description":"Silent failures in version checking hide network issues and file read errors, preventing users from knowing updates are available","recommendation":"Log errors to stderr or a debug log file. Example: catch (e) { console.error('Failed to check GSD version:', e.message); }","id":"process::.claude/hooks/global/gsd-check-update.js::empty-catch-blocks","evidence":[{"type":"code_reference","detail":".claude/hooks/global/gsd-check-update.js:38"},{"type":"description","detail":"Silent failures in version checking hide network issues and file read errors, preventing users from knowing updates are available"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".claude/hooks/global/gsd-check-update.js:38"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".claude/hooks/global/gsd-check-update.js:38"}}}
{"category":"process","title":"Error handling: 200+ empty catch blocks across hooks and scripts","fingerprint":"process::hooks-scripts::empty-catch-pattern","severity":"S1","effort":"E3","confidence":"HIGH","files":[".claude/hooks/component-size-check.js:47",".claude/hooks/component-size-check.js:111",".claude/hooks/typescript-strict-check.js:45",".claude/hooks/typescript-strict-check.js:109",".claude/hooks/track-agent-invocation.js:48",".claude/hooks/track-agent-invocation.js:81",".claude/hooks/compaction-handoff.js:66",".claude/hooks/compaction-handoff.js:82","scripts/validate-canon-schema.js:391","scripts/validate-audit.js:101","scripts/phase-complete-check.js:76"],"why_it_matters":"Silent failures hide real problems: JSON parse errors, file system issues, permission problems. Debugging becomes impossible when errors are swallowed without any logging","suggested_fix":"Add minimal error logging: catch (err) { console.error('Operation failed:', err.message); }. For non-critical operations, at least log to debug output","acceptance_tests":["File operation failures are logged","JSON parse errors are reported with context","Permission errors provide actionable guidance"],"file":".claude/hooks/component-size-check.js","line":47,"description":"Silent failures hide real problems: JSON parse errors, file system issues, permission problems. Debugging becomes impossible when errors are swallowed without any logging","recommendation":"Add minimal error logging: catch (err) { console.error('Operation failed:', err.message); }. For non-critical operations, at least log to debug output","id":"process::hooks-scripts::empty-catch-pattern","evidence":[{"type":"code_reference","detail":".claude/hooks/component-size-check.js:47"},{"type":"description","detail":"Silent failures hide real problems: JSON parse errors, file system issues, permission problems. Debugging becomes impossible when errors are swallowed without any logging"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".claude/hooks/component-size-check.js:47"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".claude/hooks/component-size-check.js:47"}}}
{"category":"process","title":"Error handling: Hook validation exits with 0 on security failures","fingerprint":"process::hooks::exit-code-on-security-fail","severity":"S2","effort":"E2","confidence":"HIGH","files":[".claude/hooks/typescript-strict-check.js:28",".claude/hooks/typescript-strict-check.js:72",".claude/hooks/component-size-check.js:32",".claude/hooks/track-agent-invocation.js:31"],"why_it_matters":"Security checks that detect path traversal or invalid input exit with 0 (success), making it appear operations succeeded when they should have been rejected. This could mask security issues","suggested_fix":"Distinguish between 'not applicable' (exit 0) and 'validation failed' (exit 1). When detecting security issues like path traversal, exit with non-zero code and log the security violation","acceptance_tests":["Path traversal attempts result in exit code 1","Invalid arguments result in exit code 1","Log messages clearly indicate security rejections","Normal 'not applicable' cases still exit 0"],"file":".claude/hooks/typescript-strict-check.js","line":28,"description":"Security checks that detect path traversal or invalid input exit with 0 (success), making it appear operations succeeded when they should have been rejected. This could mask security issues","recommendation":"Distinguish between 'not applicable' (exit 0) and 'validation failed' (exit 1). When detecting security issues like path traversal, exit with non-zero code and log the security violation","id":"process::hooks::exit-code-on-security-fail"}
{"category":"process","title":"Error handling: readFileSync without try/catch in multiple scripts","fingerprint":"process::scripts::unprotected-readfilesync","severity":"S1","effort":"E2","confidence":"HIGH","files":["scripts/verify-sonar-phase.js:134","scripts/verify-sonar-phase.js:213","scripts/validate-skill-config.js:105","scripts/update-readme-status.js:71"],"why_it_matters":"Unprotected file reads cause uncaught exceptions that crash scripts. Users see stack traces instead of helpful error messages. ENOENT errors don't explain what file was missing or why","suggested_fix":"Wrap all readFileSync calls in try/catch with helpful error messages. Example: try { content = fs.readFileSync(file, 'utf8'); } catch (err) { console.error(`Failed to read config file: ${err.message}\\nPlease ensure the file exists and is readable.`); process.exit(1); }","acceptance_tests":["Missing files produce helpful error messages","Permission errors explain what access is needed","Error messages suggest corrective actions","Scripts exit cleanly with appropriate exit codes"],"file":"scripts/verify-sonar-phase.js","line":134,"description":"Unprotected file reads cause uncaught exceptions that crash scripts. Users see stack traces instead of helpful error messages. ENOENT errors don't explain what file was missing or why","recommendation":"Wrap all readFileSync calls in try/catch with helpful error messages. Example: try { content = fs.readFileSync(file, 'utf8'); } catch (err) { console.error(`Failed to read config file: ${err.message}\\nPlease ensure the file exists and is readable.`); process.exit(1); }","id":"process::scripts::unprotected-readfilesync","evidence":[{"type":"code_reference","detail":"scripts/verify-sonar-phase.js:134"},{"type":"description","detail":"Unprotected file reads cause uncaught exceptions that crash scripts. Users see stack traces instead of helpful error messages. ENOENT errors don't explain what file was missing or why"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/verify-sonar-phase.js:134"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/verify-sonar-phase.js:134"}}}
{"category":"process","title":"Error handling: execSync without timeout or error handling","fingerprint":"process::scripts::execsync-no-timeout","severity":"S1","effort":"E2","confidence":"HIGH","files":["scripts/validate-audit.js:651",".claude/hooks/compaction-handoff.js:97",".claude/hooks/session-start.js:49"],"why_it_matters":"execSync calls without timeout can hang indefinitely if child processes freeze. Missing error handling means command failures crash the script with cryptic errors","suggested_fix":"Always include timeout option and wrap in try/catch. Example: try { const output = execSync(cmd, { timeout: 10000, encoding: 'utf8' }); } catch (err) { if (err.killed) { console.error('Command timed out after 10s'); } else { console.error('Command failed:', err.message); } process.exit(1); }","acceptance_tests":["Commands timeout after reasonable duration","Timeout errors are clearly reported","Command failures include the command that failed","Exit codes distinguish timeout vs other failures"],"file":"scripts/validate-audit.js","line":651,"description":"execSync calls without timeout can hang indefinitely if child processes freeze. Missing error handling means command failures crash the script with cryptic errors","recommendation":"Always include timeout option and wrap in try/catch. Example: try { const output = execSync(cmd, { timeout: 10000, encoding: 'utf8' }); } catch (err) { if (err.killed) { console.error('Command timed out after 10s'); } else { console.error('Command failed:', err.message); } process.exit(1); }","id":"process::scripts::execsync-no-timeout","evidence":[{"type":"code_reference","detail":"scripts/validate-audit.js:651"},{"type":"description","detail":"execSync calls without timeout can hang indefinitely if child processes freeze. Missing error handling means command failures crash the script with cryptic errors"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/validate-audit.js:651"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/validate-audit.js:651"}}}
{"category":"process","title":"Error handling: Error messages expose full system paths","fingerprint":"process::scripts::path-exposure-in-errors","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/validate-audit.js:110","scripts/lib/security-helpers.js:107","scripts/lib/security-helpers.js:114","scripts/analyze-learning-effectiveness.js:223"],"why_it_matters":"Error messages that include full absolute paths expose system structure (/home/username/, /Users/name/projects/). In logs or error reports, this leaks potentially sensitive information about deployment structure","suggested_fix":"Use path.basename() or relative paths in error messages. Example: Instead of 'Audit file not found: /home/user/project/file.jsonl', use 'Audit file not found: file.jsonl (expected in docs/audits/)'","acceptance_tests":["Error messages use relative paths or basenames only","No /home/, /Users/, or drive letters in error output","Path context is still clear for debugging","Security-sensitive paths are never logged"],"file":"scripts/validate-audit.js","line":110,"description":"Error messages that include full absolute paths expose system structure (/home/username/, /Users/name/projects/). In logs or error reports, this leaks potentially sensitive information about deployment structure","recommendation":"Use path.basename() or relative paths in error messages. Example: Instead of 'Audit file not found: /home/user/project/file.jsonl', use 'Audit file not found: file.jsonl (expected in docs/audits/)'","id":"process::scripts::path-exposure-in-errors"}
{"category":"process","title":"Error handling: State file operations fail silently","fingerprint":"process::state-utils::silent-write-failures","severity":"S1","effort":"E1","confidence":"HIGH","files":[".claude/hooks/state-utils.js:75",".claude/hooks/track-agent-invocation.js:90",".claude/hooks/session-start.js:85"],"why_it_matters":"State persistence failures mean hooks lose track of session context, agent invocations, and compaction data. Silent failures leave the system in an inconsistent state without alerting anyone","suggested_fix":"writeState() should return false on failure but caller should check the return value. Example: if (!writeState(data)) { console.error('⚠️  Failed to save session state - data may be lost after compaction'); }","acceptance_tests":["Failed state writes produce visible warnings","Return values are checked by callers","Error messages explain impact (e.g., 'compaction may lose context')","Critical state failures exit non-zero"],"file":".claude/hooks/state-utils.js","line":75,"description":"State persistence failures mean hooks lose track of session context, agent invocations, and compaction data. Silent failures leave the system in an inconsistent state without alerting anyone","recommendation":"writeState() should return false on failure but caller should check the return value. Example: if (!writeState(data)) { console.error('⚠️  Failed to save session state - data may be lost after compaction'); }","id":"process::state-utils::silent-write-failures","evidence":[{"type":"code_reference","detail":".claude/hooks/state-utils.js:75"},{"type":"description","detail":"State persistence failures mean hooks lose track of session context, agent invocations, and compaction data. Silent failures leave the system in an inconsistent state without alerting anyone"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".claude/hooks/state-utils.js:75"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".claude/hooks/state-utils.js:75"}}}
{"category":"process","title":"Error handling: JSON.parse failures without validation context","fingerprint":"process::hooks::json-parse-no-context","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/verify-skill-usage.js:136",".claude/hooks/track-agent-invocation.js:45",".claude/hooks/typescript-strict-check.js:42"],"why_it_matters":"When JSON.parse fails in hooks, empty catch blocks hide what was being parsed and why it failed. Malformed hook arguments or corrupted state files become impossible to debug","suggested_fix":"Log parse failures with context. Example: catch (err) { console.error('Failed to parse hook arguments:', arg.substring(0, 100), err.message); return null; }","acceptance_tests":["Parse errors indicate what was being parsed","First 100 chars of malformed JSON are shown","Clear distinction between missing vs malformed data","Errors suggest how to fix the input"],"file":"scripts/verify-skill-usage.js","line":136,"description":"When JSON.parse fails in hooks, empty catch blocks hide what was being parsed and why it failed. Malformed hook arguments or corrupted state files become impossible to debug","recommendation":"Log parse failures with context. Example: catch (err) { console.error('Failed to parse hook arguments:', arg.substring(0, 100), err.message); return null; }","id":"process::hooks::json-parse-no-context"}
{"category":"process","title":"Error handling: Missing error messages in file write operations","fingerprint":"process::scripts::write-no-error-msg","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/update-readme-status.js:107",".claude/hooks/compaction-handoff.js:74",".claude/hooks/pre-compaction-save.js:87"],"why_it_matters":"writeFileSync failures (disk full, permission denied, read-only filesystem) crash without explaining what failed to write. Users can't tell if their data was saved or lost","suggested_fix":"Wrap writes in try/catch with descriptive errors. Example: try { fs.writeFileSync(file, data); } catch (err) { console.error(`Failed to write ${path.basename(file)}: ${err.code === 'ENOSPC' ? 'Disk full' : err.message}`); process.exit(1); }","acceptance_tests":["Write failures explain which file failed","Common errors (ENOSPC, EACCES) have user-friendly messages","Atomic write failures clean up temp files","Exit codes indicate write failure vs success"],"file":"scripts/update-readme-status.js","line":107,"description":"writeFileSync failures (disk full, permission denied, read-only filesystem) crash without explaining what failed to write. Users can't tell if their data was saved or lost","recommendation":"Wrap writes in try/catch with descriptive errors. Example: try { fs.writeFileSync(file, data); } catch (err) { console.error(`Failed to write ${path.basename(file)}: ${err.code === 'ENOSPC' ? 'Disk full' : err.message}`); process.exit(1); }","id":"process::scripts::write-no-error-msg"}
{"category":"process","title":"Error handling: continueOnError used appropriately in settings.json","fingerprint":"process::.claude/settings.json::continue-on-error-usage","severity":"S0","effort":"E0","confidence":"HIGH","files":[".claude/settings.json:24",".claude/settings.json:31",".claude/settings.json:250"],"why_it_matters":"continueOnError is correctly used for non-critical operations: remote branch checks (network may be unavailable), dashboard cleanup (dev-only), and commit tracking (metadata only). These should not block the workflow","suggested_fix":"No fix needed - usage is appropriate. These hooks enhance the workflow but aren't critical path","acceptance_tests":["Session starts even if remote branch check fails","Workflow continues if dashboard cleanup fails","Commit tracking failures don't block operations"],"file":".claude/settings.json","line":24,"description":"continueOnError is correctly used for non-critical operations: remote branch checks (network may be unavailable), dashboard cleanup (dev-only), and commit tracking (metadata only). These should not block the workflow","recommendation":"No fix needed - usage is appropriate. These hooks enhance the workflow but aren't critical path","id":"process::.claude/settings.json::continue-on-error-usage","evidence":[{"type":"code_reference","detail":".claude/settings.json:24"},{"type":"description","detail":"continueOnError is correctly used for non-critical operations: remote branch checks (network may be unavailable), dashboard cleanup (dev-only), and commit tracking (metadata only). These should not block the workflow"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".claude/settings.json:24"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".claude/settings.json:24"}}}
{"category":"process","title":"Error handling: Validation scripts exit 0 with violations in non-strict mode","fingerprint":"process::scripts/verify-skill-usage.js::exit-zero-with-violations","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/verify-skill-usage.js:232","scripts/verify-skill-usage.js:240","scripts/verify-skill-usage.js:261"],"why_it_matters":"verify-skill-usage.js exits 0 even when violations exist (non-strict mode). This makes CI integration confusing - the script reports issues but signals success. Violations may be ignored","suggested_fix":"Exit code should reflect presence of violations regardless of mode. Use --quiet to suppress output, not to change exit behavior. Example: if (violations.length > 0) process.exit(1); else process.exit(0);","acceptance_tests":["Script exits 1 when violations exist","--quiet suppresses output but preserves exit code","CI can rely on exit code to detect issues","Documentation explains exit code behavior"],"file":"scripts/verify-skill-usage.js","line":232,"description":"verify-skill-usage.js exits 0 even when violations exist (non-strict mode). This makes CI integration confusing - the script reports issues but signals success. Violations may be ignored","recommendation":"Exit code should reflect presence of violations regardless of mode. Use --quiet to suppress output, not to change exit behavior. Example: if (violations.length > 0) process.exit(1); else process.exit(0);","id":"process::scripts/verify-skill-usage.js::exit-zero-with-violations"}
{"category":"process","title":"Error handling: Multiple exit(0) calls suggest unclear control flow","fingerprint":"process::.claude/hooks/typescript-strict-check.js::multiple-exit-zero","severity":"S2","effort":"E2","confidence":"MEDIUM","files":[".claude/hooks/typescript-strict-check.js:28",".claude/hooks/typescript-strict-check.js:35",".claude/hooks/typescript-strict-check.js:47",".claude/hooks/typescript-strict-check.js:52",".claude/hooks/typescript-strict-check.js:58"],"why_it_matters":"typescript-strict-check.js has 15+ process.exit(0) calls in validation logic. This pattern makes it unclear which exits are 'check passed' vs 'check not applicable' vs 'check skipped due to error'","suggested_fix":"Refactor to have a single exit point with clear exit code strategy. Use early returns instead of exit(0) in validation functions, then exit once at the end based on accumulated state","acceptance_tests":["Single exit point at end of script","Exit code clearly indicates: 0=passed/not-applicable, 1=failed","Comments explain each early return reason","Control flow is linear and easy to follow"],"file":".claude/hooks/typescript-strict-check.js","line":28,"description":"typescript-strict-check.js has 15+ process.exit(0) calls in validation logic. This pattern makes it unclear which exits are 'check passed' vs 'check not applicable' vs 'check skipped due to error'","recommendation":"Refactor to have a single exit point with clear exit code strategy. Use early returns instead of exit(0) in validation functions, then exit once at the end based on accumulated state","id":"process::.claude/hooks/typescript-strict-check.js::multiple-exit-zero"}
{"category":"process","title":"Error handling: Hook execution errors not propagated to user","fingerprint":"process::hooks::error-visibility","severity":"S1","effort":"E2","confidence":"HIGH","files":[".claude/hooks/component-size-check.js:47",".claude/hooks/pattern-check.js:60",".claude/hooks/audit-s0s1-validator.js:49"],"why_it_matters":"When PostToolUse hooks fail silently (empty catch blocks), users don't know validation ran or failed. They may proceed thinking code is validated when checks actually crashed","suggested_fix":"Hooks should output clear status messages: 'ok' on success, error description on failure. Log to stderr for errors while preserving stdout for hook protocol. Example: catch (err) { console.error('Hook failed:', err.message); console.log('error'); process.exit(1); }","acceptance_tests":["Users see when hooks fail vs pass","Error messages are actionable","Hook failures are distinguishable from 'not applicable'","Logs clearly show which hook failed"],"file":".claude/hooks/component-size-check.js","line":47,"description":"When PostToolUse hooks fail silently (empty catch blocks), users don't know validation ran or failed. They may proceed thinking code is validated when checks actually crashed","recommendation":"Hooks should output clear status messages: 'ok' on success, error description on failure. Log to stderr for errors while preserving stdout for hook protocol. Example: catch (err) { console.error('Hook failed:', err.message); console.log('error'); process.exit(1); }","id":"process::hooks::error-visibility","evidence":[{"type":"code_reference","detail":".claude/hooks/component-size-check.js:47"},{"type":"description","detail":"When PostToolUse hooks fail silently (empty catch blocks), users don't know validation ran or failed. They may proceed thinking code is validated when checks actually crashed"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":[".claude/hooks/component-size-check.js:47"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":".claude/hooks/component-size-check.js:47"}}}
{"category":"process","title":"Error handling: generate-pending-alerts.js throws error on write failure but doesn't clean up partial state","fingerprint":"process::scripts/generate-pending-alerts.js::no-cleanup-on-failure","severity":"S1","effort":"E2","confidence":"HIGH","files":["scripts/generate-pending-alerts.js:389","scripts/generate-pending-alerts.js:38","scripts/generate-pending-alerts.js:116"],"why_it_matters":"Script throws 'Failed to write alerts file' but doesn't rollback partial writes or clean up temp files. This can leave .alerts.json in inconsistent state, causing downstream tools to fail","suggested_fix":"Use atomic write pattern: write to temp file, validate, then rename. On failure, clean up temp file and preserve existing alerts file. Example: const tmp = file + '.tmp'; try { fs.writeFileSync(tmp, data); fs.renameSync(tmp, file); } catch (err) { fs.rmSync(tmp, {force:true}); throw err; }","acceptance_tests":["Failed writes don't corrupt existing alerts file","Temp files are cleaned up on error","Atomic rename ensures all-or-nothing updates","Error message explains what failed and why"],"file":"scripts/generate-pending-alerts.js","line":389,"description":"Script throws 'Failed to write alerts file' but doesn't rollback partial writes or clean up temp files. This can leave .alerts.json in inconsistent state, causing downstream tools to fail","recommendation":"Use atomic write pattern: write to temp file, validate, then rename. On failure, clean up temp file and preserve existing alerts file. Example: const tmp = file + '.tmp'; try { fs.writeFileSync(tmp, data); fs.renameSync(tmp, file); } catch (err) { fs.rmSync(tmp, {force:true}); throw err; }","id":"process::scripts/generate-pending-alerts.js::no-cleanup-on-failure","evidence":[{"type":"code_reference","detail":"scripts/generate-pending-alerts.js:389"},{"type":"description","detail":"Script throws 'Failed to write alerts file' but doesn't rollback partial writes or clean up temp files. This can leave .alerts.json in inconsistent state, causing downstream tools to fail"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/generate-pending-alerts.js:389"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/generate-pending-alerts.js:389"}}}
{"category":"process","title":"Error handling: sync-sonarcloud.js API errors expose implementation details","fingerprint":"process::scripts/debt/sync-sonarcloud.js::verbose-api-errors","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/debt/sync-sonarcloud.js:290"],"why_it_matters":"Error message includes full HTTP response status and potentially sensitive API error details. In logs, this could expose API keys or internal service details","suggested_fix":"Sanitize error messages before throwing. Example: throw new Error(`SonarCloud API request failed (${response.status}). Check SONARCLOUD_TOKEN environment variable.`); Don't include response body or headers in error messages","acceptance_tests":["API errors don't include response bodies","No tokens or sensitive headers in error messages","User-friendly guidance for common errors (401, 403, 429)","Detailed errors only in debug mode"],"file":"scripts/debt/sync-sonarcloud.js","line":290,"description":"Error message includes full HTTP response status and potentially sensitive API error details. In logs, this could expose API keys or internal service details","recommendation":"Sanitize error messages before throwing. Example: throw new Error(`SonarCloud API request failed (${response.status}). Check SONARCLOUD_TOKEN environment variable.`); Don't include response body or headers in error messages","id":"process::scripts/debt/sync-sonarcloud.js::verbose-api-errors"}
{"category":"process","title":"Error handling: execSync in validation scripts can hang on interactive prompts","fingerprint":"process::scripts::execsync-interactive-hang","severity":"S1","effort":"E1","confidence":"HIGH","files":["scripts/validate-audit.js:651","scripts/validate-audit.js:707"],"why_it_matters":"execSync('npm audit') and execSync('npm run lint') without stdio: 'pipe' can hang if these commands prompt for user input. Hook execution would freeze indefinitely","suggested_fix":"Already using stdio: ['ignore', 'pipe', 'pipe'] pattern correctly in validate-audit.js. Verify all other execSync calls use similar pattern to prevent stdin interaction","acceptance_tests":["Commands never wait for stdin","stdio is explicitly configured for all execSync calls","Timeout is set for all long-running commands","Scripts can run unattended in CI"],"file":"scripts/validate-audit.js","line":651,"description":"execSync('npm audit') and execSync('npm run lint') without stdio: 'pipe' can hang if these commands prompt for user input. Hook execution would freeze indefinitely","recommendation":"Already using stdio: ['ignore', 'pipe', 'pipe'] pattern correctly in validate-audit.js. Verify all other execSync calls use similar pattern to prevent stdin interaction","id":"process::scripts::execsync-interactive-hang","evidence":[{"type":"code_reference","detail":"scripts/validate-audit.js:651"},{"type":"description","detail":"execSync('npm audit') and execSync('npm run lint') without stdio: 'pipe' can hang if these commands prompt for user input. Hook execution would freeze indefinitely"}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/validate-audit.js:651"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/validate-audit.js:651"}}}
{"category":"process","title":"Quality: TOCTOU race condition in ai-review.js","fingerprint":"process::scripts/ai-review.js::toctou-existsSync-readFileSync","severity":"S1","effort":"E1","confidence":"HIGH","files":["scripts/ai-review.js:139"],"why_it_matters":"Classic TOCTOU (Time-of-Check-Time-of-Use) race condition. File existence is checked with existsSync() then read with readFileSync(). Between these calls, the file could be deleted, moved, or replaced with a symlink, causing crashes or reading wrong files. CODE_PATTERNS.md Rule #3 explicitly requires wrapping ALL file reads in try/catch.","suggested_fix":"Remove existsSync check and wrap readFileSync in try/catch. Pattern from CODE_PATTERNS.md: try { const content = readFileSync(filePath, 'utf-8'); return { success: true, content }; } catch (error) { if (error.code === 'ENOENT') { return { success: false, error: 'File not found' }; } ... }","acceptance_tests":["existsSync check removed","readFileSync wrapped in try/catch with error.code === 'ENOENT' handling"],"file":"scripts/ai-review.js","line":139,"description":"Classic TOCTOU (Time-of-Check-Time-of-Use) race condition. File existence is checked with existsSync() then read with readFileSync(). Between these calls, the file could be deleted, moved, or replaced with a symlink, causing crashes or reading wrong files. CODE_PATTERNS.md Rule #3 explicitly requires wrapping ALL file reads in try/catch.","recommendation":"Remove existsSync check and wrap readFileSync in try/catch. Pattern from CODE_PATTERNS.md: try { const content = readFileSync(filePath, 'utf-8'); return { success: true, content }; } catch (error) { if (error.code === 'ENOENT') { return { success: false, error: 'File not found' }; } ... }","id":"process::scripts/ai-review.js::toctou-existsSync-readFileSync","evidence":[{"type":"code_reference","detail":"scripts/ai-review.js:139"},{"type":"description","detail":"Classic TOCTOU (Time-of-Check-Time-of-Use) race condition. File existence is checked with existsSync() then read with readFileSync(). Between these calls, the file could be deleted, moved, or replaced with a symlink, causing crashes or reading wrong files. CODE_PATTERNS.md Rule #3 explicitly requires wrapping ALL file reads in try/catch."}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/ai-review.js:139"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/ai-review.js:139"}}}
{"category":"process","title":"Quality: TOCTOU race condition in check-consolidation-status.js","fingerprint":"process::scripts/check-consolidation-status.js::toctou-existsSync-readFileSync","severity":"S1","effort":"E1","confidence":"HIGH","files":["scripts/check-consolidation-status.js:89"],"why_it_matters":"Classic TOCTOU race condition. existsSync at line 89 followed by readFileSync at line 96. Violates CODE_PATTERNS.md Critical Pattern #3: 'Wrap ALL file reads in try/catch - existsSync has race conditions'. Between the check and read, file could be deleted causing crash.","suggested_fix":"Remove existsSync check at line 89. Change error handling to: try { const content = readFileSync(LOG_FILE, 'utf8'); ... } catch (err) { if (err.code === 'ENOENT') { console.error('File not found'); process.exitCode = 2; return; } throw err; }","acceptance_tests":["existsSync check removed","readFileSync moved into try block","error.code === 'ENOENT' checked in catch"],"file":"scripts/check-consolidation-status.js","line":89,"description":"Classic TOCTOU race condition. existsSync at line 89 followed by readFileSync at line 96. Violates CODE_PATTERNS.md Critical Pattern #3: 'Wrap ALL file reads in try/catch - existsSync has race conditions'. Between the check and read, file could be deleted causing crash.","recommendation":"Remove existsSync check at line 89. Change error handling to: try { const content = readFileSync(LOG_FILE, 'utf8'); ... } catch (err) { if (err.code === 'ENOENT') { console.error('File not found'); process.exitCode = 2; return; } throw err; }","id":"process::scripts/check-consolidation-status.js::toctou-existsSync-readFileSync","evidence":[{"type":"code_reference","detail":"scripts/check-consolidation-status.js:89"},{"type":"description","detail":"Classic TOCTOU race condition. existsSync at line 89 followed by readFileSync at line 96. Violates CODE_PATTERNS.md Critical Pattern #3: 'Wrap ALL file reads in try/catch - existsSync has race conditions'. Between the check and read, file could be deleted causing crash."}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/check-consolidation-status.js:89"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/check-consolidation-status.js:89"}}}
{"category":"process","title":"Quality: TOCTOU race condition in resolve-item.js","fingerprint":"process::scripts/debt/resolve-item.js::toctou-existsSync-readFileSync","severity":"S1","effort":"E1","confidence":"HIGH","files":["scripts/debt/resolve-item.js:53"],"why_it_matters":"TOCTOU race in loadMasterDebt(). existsSync at line 53 followed by readFileSync at line 56. File could be deleted between check and read. Violates CODE_PATTERNS.md Critical Pattern #3. In a concurrent environment (multiple debt resolution scripts), this can cause crashes.","suggested_fix":"Replace lines 52-59 with: function loadMasterDebt() { try { const content = fs.readFileSync(MASTER_FILE, 'utf8'); const lines = content.split('\\n').filter(line => line.trim()); return lines.map(line => JSON.parse(line)); } catch (err) { if (err.code === 'ENOENT') return []; throw err; } }","acceptance_tests":["existsSync check removed","readFileSync in try block","Empty array returned on ENOENT"],"file":"scripts/debt/resolve-item.js","line":53,"description":"TOCTOU race in loadMasterDebt(). existsSync at line 53 followed by readFileSync at line 56. File could be deleted between check and read. Violates CODE_PATTERNS.md Critical Pattern #3. In a concurrent environment (multiple debt resolution scripts), this can cause crashes.","recommendation":"Replace lines 52-59 with: function loadMasterDebt() { try { const content = fs.readFileSync(MASTER_FILE, 'utf8'); const lines = content.split('\\n').filter(line => line.trim()); return lines.map(line => JSON.parse(line)); } catch (err) { if (err.code === 'ENOENT') return []; throw err; } }","id":"process::scripts/debt/resolve-item.js::toctou-existsSync-readFileSync","evidence":[{"type":"code_reference","detail":"scripts/debt/resolve-item.js:53"},{"type":"description","detail":"TOCTOU race in loadMasterDebt(). existsSync at line 53 followed by readFileSync at line 56. File could be deleted between check and read. Violates CODE_PATTERNS.md Critical Pattern #3. In a concurrent environment (multiple debt resolution scripts), this can cause crashes."}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/debt/resolve-item.js:53"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/debt/resolve-item.js:53"}}}
{"category":"process","title":"Quality: Magic number - hardcoded port without explanation","fingerprint":"process::.claude/hooks/stop-serena-dashboard.js::magic-port-24282","severity":"S2","effort":"E1","confidence":"HIGH","files":[".claude/hooks/stop-serena-dashboard.js:30"],"why_it_matters":"Port 24282 is hardcoded without any comment explaining why this specific port. Makes it unclear if this is a well-known port, randomly chosen, or has significance. CODE_PATTERNS.md warns against magic numbers/strings without explanation. If port needs to change, developers won't know the constraints.","suggested_fix":"Add explanatory comment: // Port 24282: Official Serena MCP server port (assigned in .mcp.json). Or better: load from config file to have single source of truth matching .mcp.json configuration.","acceptance_tests":["Comment added explaining port selection","Or: PORT loaded from shared config file"],"file":".claude/hooks/stop-serena-dashboard.js","line":30,"description":"Port 24282 is hardcoded without any comment explaining why this specific port. Makes it unclear if this is a well-known port, randomly chosen, or has significance. CODE_PATTERNS.md warns against magic numbers/strings without explanation. If port needs to change, developers won't know the constraints.","recommendation":"Add explanatory comment: // Port 24282: Official Serena MCP server port (assigned in .mcp.json). Or better: load from config file to have single source of truth matching .mcp.json configuration.","id":"process::.claude/hooks/stop-serena-dashboard.js::magic-port-24282"}
{"category":"process","title":"Quality: Magic number - MAX_LENGTH without explanation","fingerprint":"process::.claude/hooks/analyze-user-request.js::magic-maxlength-2000","severity":"S2","effort":"E1","confidence":"HIGH","files":[".claude/hooks/analyze-user-request.js:37"],"why_it_matters":"MAX_LENGTH=2000 hardcoded without explanation of why 2000 characters. Is this to prevent DoS? Buffer overflow? UI limitation? Without context, future maintainers won't know if this can be safely adjusted.","suggested_fix":"Add comment explaining rationale: // DoS prevention: Limit input to 2000 chars (typical user prompt is <500 chars). Consider making this configurable if different contexts need different limits.","acceptance_tests":["Comment added explaining why 2000","Or: Value moved to config file with explanation"],"file":".claude/hooks/analyze-user-request.js","line":37,"description":"MAX_LENGTH=2000 hardcoded without explanation of why 2000 characters. Is this to prevent DoS? Buffer overflow? UI limitation? Without context, future maintainers won't know if this can be safely adjusted.","recommendation":"Add comment explaining rationale: // DoS prevention: Limit input to 2000 chars (typical user prompt is <500 chars). Consider making this configurable if different contexts need different limits.","id":"process::.claude/hooks/analyze-user-request.js::magic-maxlength-2000"}
{"category":"process","title":"Quality: Magic number - SINGLE_FILE_LINE_LIMIT without explanation","fingerprint":"process::.claude/hooks/large-context-warning.js::magic-line-limit-5000","severity":"S2","effort":"E1","confidence":"HIGH","files":[".claude/hooks/large-context-warning.js:20"],"why_it_matters":"SINGLE_FILE_LINE_LIMIT=5000 without explanation. Is this based on Claude token limits? Performance testing? Arbitrary choice? Future Claude model upgrades may allow larger contexts, but without documentation, developers won't know if this is safe to change.","suggested_fix":"Add comment: // Claude 3 context window = ~200K tokens. 5000 lines ≈ 50K tokens average, leaving headroom for conversation. Based on [reference to testing/decision doc if exists]. Consider loading from config for different model tiers.","acceptance_tests":["Comment added with rationale","Or: Document in docs/agent_docs/ and reference from code"],"file":".claude/hooks/large-context-warning.js","line":20,"description":"SINGLE_FILE_LINE_LIMIT=5000 without explanation. Is this based on Claude token limits? Performance testing? Arbitrary choice? Future Claude model upgrades may allow larger contexts, but without documentation, developers won't know if this is safe to change.","recommendation":"Add comment: // Claude 3 context window = ~200K tokens. 5000 lines ≈ 50K tokens average, leaving headroom for conversation. Based on [reference to testing/decision doc if exists]. Consider loading from config for different model tiers.","id":"process::.claude/hooks/large-context-warning.js::magic-line-limit-5000"}
{"category":"process","title":"Quality: Magic number - ARCHIVE_LINE_THRESHOLD without explanation","fingerprint":"process::scripts/check-consolidation-status.js::magic-archive-threshold-2500","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/check-consolidation-status.js:26"],"why_it_matters":"ARCHIVE_LINE_THRESHOLD=2500 has no explanation. Why 2500 lines? Performance issue? File size limit? Readability concern? This threshold triggers archival decisions but lacks documentation on how it was determined.","suggested_fix":"Add comment: // Archive threshold: 2500 lines keeps file manageable for editors (most IDEs struggle >3000 lines). Based on AI_REVIEW_LEARNINGS_LOG.md performance testing [if exists]. Consider making configurable.","acceptance_tests":["Comment added with rationale","Threshold moved to config if used in multiple places"],"file":"scripts/check-consolidation-status.js","line":26,"description":"ARCHIVE_LINE_THRESHOLD=2500 has no explanation. Why 2500 lines? Performance issue? File size limit? Readability concern? This threshold triggers archival decisions but lacks documentation on how it was determined.","recommendation":"Add comment: // Archive threshold: 2500 lines keeps file manageable for editors (most IDEs struggle >3000 lines). Based on AI_REVIEW_LEARNINGS_LOG.md performance testing [if exists]. Consider making configurable.","id":"process::scripts/check-consolidation-status.js::magic-archive-threshold-2500"}
{"category":"process","title":"Quality: Magic number - REQUEST_TIMEOUT_MS without explanation","fingerprint":"process::scripts/mcp/sonarcloud-server.js::magic-timeout-30000","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/mcp/sonarcloud-server.js:68"],"why_it_matters":"REQUEST_TIMEOUT_MS=30000 (30 seconds) hardcoded without explanation. Is this based on SonarCloud API SLA? Network timeout? If SonarCloud response times change or users have slow connections, they won't know if adjusting this is safe.","suggested_fix":"Add comment: // 30s timeout: SonarCloud API p95 response time ~5s, p99 ~15s (as of 2025-01). 30s provides 2x buffer for slow connections. Reference: [SonarCloud API docs]. Consider making configurable for different network conditions.","acceptance_tests":["Comment added explaining timeout rationale","Or: Load from config with fallback to 30000"],"file":"scripts/mcp/sonarcloud-server.js","line":68,"description":"REQUEST_TIMEOUT_MS=30000 (30 seconds) hardcoded without explanation. Is this based on SonarCloud API SLA? Network timeout? If SonarCloud response times change or users have slow connections, they won't know if adjusting this is safe.","recommendation":"Add comment: // 30s timeout: SonarCloud API p95 response time ~5s, p99 ~15s (as of 2025-01). 30s provides 2x buffer for slow connections. Reference: [SonarCloud API docs]. Consider making configurable for different network conditions.","id":"process::scripts/mcp/sonarcloud-server.js::magic-timeout-30000"}
{"category":"process","title":"Quality: Hardcoded path should be configurable","fingerprint":"process::.claude/hooks/state-utils.js::hardcoded-state-dir","severity":"S2","effort":"E2","confidence":"MEDIUM","files":[".claude/hooks/state-utils.js:22"],"why_it_matters":"STATE_DIR = '.claude/state' is hardcoded. In different project structures or CI environments, state might need to be stored elsewhere (temp dirs, mounted volumes). Makes the utility less reusable across different setups.","suggested_fix":"Make configurable: const STATE_DIR = process.env.CLAUDE_STATE_DIR || '.claude/state'; Document the environment variable in docs/agent_docs/ or CONTRIBUTING.md. This allows override without code changes.","acceptance_tests":["STATE_DIR reads from environment variable with fallback","Environment variable documented in project docs"],"file":".claude/hooks/state-utils.js","line":22,"description":"STATE_DIR = '.claude/state' is hardcoded. In different project structures or CI environments, state might need to be stored elsewhere (temp dirs, mounted volumes). Makes the utility less reusable across different setups.","recommendation":"Make configurable: const STATE_DIR = process.env.CLAUDE_STATE_DIR || '.claude/state'; Document the environment variable in docs/agent_docs/ or CONTRIBUTING.md. This allows override without code changes.","id":"process::.claude/hooks/state-utils.js::hardcoded-state-dir"}
{"category":"process","title":"Quality: Multiple hardcoded debt paths","fingerprint":"process::scripts/debt/intake-audit.js::hardcoded-debt-paths","severity":"S2","effort":"E2","confidence":"MEDIUM","files":["scripts/debt/intake-audit.js:53","scripts/debt/intake-audit.js:54","scripts/debt/intake-audit.js:55","scripts/debt/intake-audit.js:56"],"why_it_matters":"DEBT_DIR, MASTER_FILE, LOG_DIR, LOG_FILE all hardcoded to docs/technical-debt. In CI/CD or different repo structures, technical debt data might need different locations. Testing also becomes harder without configurability.","suggested_fix":"Load from config: const config = loadConfig('debt-paths'); const DEBT_DIR = config.debtDir || path.join(__dirname, '../../docs/technical-debt'); Or use environment variables with fallbacks. Document configuration in docs/agent_docs/.","acceptance_tests":["Paths loaded from config or env vars","Default values preserved for backward compatibility","Configuration method documented"],"file":"scripts/debt/intake-audit.js","line":53,"description":"DEBT_DIR, MASTER_FILE, LOG_DIR, LOG_FILE all hardcoded to docs/technical-debt. In CI/CD or different repo structures, technical debt data might need different locations. Testing also becomes harder without configurability.","recommendation":"Load from config: const config = loadConfig('debt-paths'); const DEBT_DIR = config.debtDir || path.join(__dirname, '../../docs/technical-debt'); Or use environment variables with fallbacks. Document configuration in docs/agent_docs/.","id":"process::scripts/debt/intake-audit.js::hardcoded-debt-paths"}
{"category":"process","title":"Security: Potential command injection in resolve-item.js execSync","fingerprint":"process::scripts/debt/resolve-item.js::execsync-string-interpolation","severity":"S0","effort":"E1","confidence":"MEDIUM","files":["scripts/debt/resolve-item.js:21"],"why_it_matters":"execSync imported from child_process at line 21. While not directly visible in first 100 lines, use of execSync with string concatenation is a critical security issue per CODE_PATTERNS.md. Need to verify later in file that execFileSync is used or execSync uses only array arguments.","suggested_fix":"If execSync is used with string templates: replace with execFileSync(cmd, [arg1, arg2], options). CODE_PATTERNS.md Security pattern: 'Use execFileSync(cmd, [arg1, arg2]) not execSync(`cmd ${var}`)' eliminates injection vectors even with validated inputs.","acceptance_tests":["Verify execSync usage in full file","If string interpolation found, replace with execFileSync array args","Add test case with malicious input (e.g., '; rm -rf /')"],"file":"scripts/debt/resolve-item.js","line":21,"description":"execSync imported from child_process at line 21. While not directly visible in first 100 lines, use of execSync with string concatenation is a critical security issue per CODE_PATTERNS.md. Need to verify later in file that execFileSync is used or execSync uses only array arguments.","recommendation":"If execSync is used with string templates: replace with execFileSync(cmd, [arg1, arg2], options). CODE_PATTERNS.md Security pattern: 'Use execFileSync(cmd, [arg1, arg2]) not execSync(`cmd ${var}`)' eliminates injection vectors even with validated inputs.","id":"process::scripts/debt/resolve-item.js::execsync-string-interpolation","evidence":[{"type":"code_reference","detail":"scripts/debt/resolve-item.js:21"},{"type":"description","detail":"execSync imported from child_process at line 21. While not directly visible in first 100 lines, use of execSync with string concatenation is a critical security issue per CODE_PATTERNS.md. Need to verify later in file that execFileSync is used or execSync uses only array arguments."}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/debt/resolve-item.js:21"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/debt/resolve-item.js:21"}}}
{"category":"process","title":"Quality: Missing validation on parsed JSON objects","fingerprint":"process::scripts/debt/intake-audit.js::json-parse-validation","severity":"S1","effort":"E2","confidence":"HIGH","files":["scripts/debt/intake-audit.js:119"],"why_it_matters":"mapDocStandardsToTdms() function processes untrusted JSONL input. While safeCloneObject filters __proto__, the function doesn't validate object shape before accessing properties. Malformed JSONL could cause undefined behavior or crashes when accessing nested properties.","suggested_fix":"Add input validation: function mapDocStandardsToTdms(item) { if (!item || typeof item !== 'object' || Array.isArray(item)) { return { item: {}, metadata: { format_detected: 'invalid', error: 'Expected object' }}; } ... } Also validate array types before .map(), .length access.","acceptance_tests":["Null input handled gracefully","Array input (not object) handled","String/number input handled","Nested property access wrapped in optional chaining or existence checks"],"file":"scripts/debt/intake-audit.js","line":119,"description":"mapDocStandardsToTdms() function processes untrusted JSONL input. While safeCloneObject filters __proto__, the function doesn't validate object shape before accessing properties. Malformed JSONL could cause undefined behavior or crashes when accessing nested properties.","recommendation":"Add input validation: function mapDocStandardsToTdms(item) { if (!item || typeof item !== 'object' || Array.isArray(item)) { return { item: {}, metadata: { format_detected: 'invalid', error: 'Expected object' }}; } ... } Also validate array types before .map(), .length access.","id":"process::scripts/debt/intake-audit.js::json-parse-validation","evidence":[{"type":"code_reference","detail":"scripts/debt/intake-audit.js:119"},{"type":"description","detail":"mapDocStandardsToTdms() function processes untrusted JSONL input. While safeCloneObject filters __proto__, the function doesn't validate object shape before accessing properties. Malformed JSONL could cause undefined behavior or crashes when accessing nested properties."}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/debt/intake-audit.js:119"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/debt/intake-audit.js:119"}}}
{"category":"process","title":"Quality: Unsafe regex patterns in pattern checker","fingerprint":"process::scripts/check-pattern-compliance.js::redos-risk","severity":"S1","effort":"E3","confidence":"MEDIUM","files":["scripts/check-pattern-compliance.js:106-300"],"why_it_matters":"ANTI_PATTERNS array contains many complex regex with nested quantifiers and unbounded lookaheads (e.g., line 137: /for\\s+\\w+\\s+in\\s+1\\s+2\\s+3\\s*;\\s*do[\\s\\S]{0,120}?&&\\s*break[\\s\\S]{0,80}?done(?![\\s\\S]{0,80}?...). On maliciously crafted input files, these could cause ReDoS (Regular Expression Denial of Service) hanging the checker.","suggested_fix":"CODE_PATTERNS.md Security: 'Use {1,64} not + for bounded user input' and 'Add heuristic detection (nested quantifiers, length limits)'. Add input size guards before regex matching: if (content.length > 100000) { console.warn('File too large, skipping pattern checks'); return; }. Review each regex for nested quantifiers and add explicit bounds.","acceptance_tests":["Input size limits added before regex execution","Regex timeout mechanism (if platform supports)","Test with large files (1MB+) to verify no hang","Review each pattern for nested quantifiers"],"file":"scripts/check-pattern-compliance.js","line":106,"description":"ANTI_PATTERNS array contains many complex regex with nested quantifiers and unbounded lookaheads (e.g., line 137: /for\\s+\\w+\\s+in\\s+1\\s+2\\s+3\\s*;\\s*do[\\s\\S]{0,120}?&&\\s*break[\\s\\S]{0,80}?done(?![\\s\\S]{0,80}?...). On maliciously crafted input files, these could cause ReDoS (Regular Expression Denial of Service) hanging the checker.","recommendation":"CODE_PATTERNS.md Security: 'Use {1,64} not + for bounded user input' and 'Add heuristic detection (nested quantifiers, length limits)'. Add input size guards before regex matching: if (content.length > 100000) { console.warn('File too large, skipping pattern checks'); return; }. Review each regex for nested quantifiers and add explicit bounds.","id":"process::scripts/check-pattern-compliance.js::redos-risk","evidence":[{"type":"code_reference","detail":"scripts/check-pattern-compliance.js:106"},{"type":"description","detail":"ANTI_PATTERNS array contains many complex regex with nested quantifiers and unbounded lookaheads (e.g., line 137: /for\\s+\\w+\\s+in\\s+1\\s+2\\s+3\\s*;\\s*do[\\s\\S]{0,120}?&&\\s*break[\\s\\S]{0,80}?done(?![\\s\\S]{0,80}?...). On maliciously crafted input files, these could cause ReDoS (Regular Expression Denial of Service) hanging the checker."}],"verification_steps":{"first_pass":{"method":"code_search","evidence_collected":["scripts/check-pattern-compliance.js:106"]},"second_pass":{"method":"contextual_review","confirmed":true},"tool_confirmation":{"tool":"NONE","result":"confirmed via manual code review","reference":"scripts/check-pattern-compliance.js:106"}}}
{"category":"process","title":"Inconsistent: Mixed CommonJS and ESM module systems","fingerprint":"process::scripts::module-system-mix","severity":"S3","effort":"E1","confidence":"HIGH","files":["scripts/append-hook-warning.js:1","scripts/seed-commit-log.js:1","scripts/debt/generate-metrics.js:1","scripts/debt/sync-sonarcloud.js:1","scripts/check-agent-compliance.js:1","scripts/archive-doc.js:1","scripts/ai-review.js:1"],"why_it_matters":"Mixing CommonJS (require) and ESM (import) makes codebase harder to maintain and can cause confusion about module resolution. Standardizing on one approach improves consistency and reduces cognitive load.","suggested_fix":"Standardize on ESM (import/export) for all new scripts. Create migration plan for remaining CommonJS scripts. ESM is the modern standard and provides better static analysis.","acceptance_tests":["All scripts in scripts/ directory use ESM syntax","No new scripts use require() unless justified","Migration plan documented for legacy CommonJS scripts"],"file":"scripts/append-hook-warning.js","line":1,"description":"Mixing CommonJS (require) and ESM (import) makes codebase harder to maintain and can cause confusion about module resolution. Standardizing on one approach improves consistency and reduces cognitive load.","recommendation":"Standardize on ESM (import/export) for all new scripts. Create migration plan for remaining CommonJS scripts. ESM is the modern standard and provides better static analysis.","id":"process::scripts::module-system-mix"}
{"category":"process","title":"Inconsistent: node: prefix usage in imports","fingerprint":"process::scripts::node-prefix-inconsistency","severity":"S3","effort":"E1","confidence":"HIGH","files":["scripts/validate-audit.js:18","scripts/ai-review.js:15","scripts/debt/generate-metrics.js:20","scripts/debt/sync-sonarcloud.js:29"],"why_it_matters":"Some scripts use 'node:fs' prefix for built-in modules, others use 'fs', and some use aliases like 'node_fs'. This inconsistency makes code reviews harder and creates unnecessary variation in import style.","suggested_fix":"Standardize on using 'node:' prefix for all Node.js built-in modules (node:fs, node:path, etc.) without aliases. This is the modern Node.js convention and makes built-in modules explicit.","acceptance_tests":["All scripts consistently use 'node:' prefix for built-in modules","No aliased imports like 'node_fs' unless necessary","ESLint rule enforces node: prefix usage"],"file":"scripts/validate-audit.js","line":18,"description":"Some scripts use 'node:fs' prefix for built-in modules, others use 'fs', and some use aliases like 'node_fs'. This inconsistency makes code reviews harder and creates unnecessary variation in import style.","recommendation":"Standardize on using 'node:' prefix for all Node.js built-in modules (node:fs, node:path, etc.) without aliases. This is the modern Node.js convention and makes built-in modules explicit.","id":"process::scripts::node-prefix-inconsistency"}
{"category":"process","title":"Inconsistent: Emoji usage in console output","fingerprint":"process::scripts::emoji-consistency","severity":"S3","effort":"E1","confidence":"MEDIUM","files":["scripts/seed-commit-log.js:105","scripts/dedupe-quotes.ts:248","scripts/check-agent-compliance.js:156","scripts/archive-doc.js:576"],"why_it_matters":"Most scripts use emojis for visual feedback (✅, ❌, ⚠️) but some don't, creating inconsistent UX across automation tools. Users expect consistent output formatting.","suggested_fix":"Establish emoji usage standard: use emojis for all user-facing scripts (✅ success, ❌ error, ⚠️ warning, 📊 info). Create shared constants file for emoji mappings to ensure consistency.","acceptance_tests":["All user-facing scripts use standard emoji set","Shared emoji constants file exists and is used","CI/non-interactive contexts can disable emojis via flag"],"file":"scripts/seed-commit-log.js","line":105,"description":"Most scripts use emojis for visual feedback (✅, ❌, ⚠️) but some don't, creating inconsistent UX across automation tools. Users expect consistent output formatting.","recommendation":"Establish emoji usage standard: use emojis for all user-facing scripts (✅ success, ❌ error, ⚠️ warning, 📊 info). Create shared constants file for emoji mappings to ensure consistency.","id":"process::scripts::emoji-consistency"}
{"category":"process","title":"Inconsistent: Exit code handling patterns","fingerprint":"process::scripts::exit-code-patterns","severity":"S3","effort":"E1","confidence":"HIGH","files":["scripts/check-agent-compliance.js:192","scripts/check-backlog-health.js:256","scripts/security-check.js:441","scripts/validate-audit.js:974"],"why_it_matters":"Scripts use different patterns for setting exit codes: some use process.exit() directly, others use process.exitCode assignment. This inconsistency makes error handling patterns harder to learn and maintain.","suggested_fix":"Standardize on process.exitCode assignment pattern (not direct process.exit()) to allow cleanup handlers to run. Reserve process.exit() for truly fatal errors only. Document pattern in CONTRIBUTING.md.","acceptance_tests":["All scripts use process.exitCode for normal termination","process.exit() only used for fatal unrecoverable errors","Scripts allow cleanup handlers (SIGINT, SIGTERM) to execute"],"file":"scripts/check-agent-compliance.js","line":192,"description":"Scripts use different patterns for setting exit codes: some use process.exit() directly, others use process.exitCode assignment. This inconsistency makes error handling patterns harder to learn and maintain.","recommendation":"Standardize on process.exitCode assignment pattern (not direct process.exit()) to allow cleanup handlers to run. Reserve process.exit() for truly fatal errors only. Document pattern in CONTRIBUTING.md.","id":"process::scripts::exit-code-patterns"}
{"category":"process","title":"Inconsistent: Verbose/debug logging approaches","fingerprint":"process::scripts::verbose-logging","severity":"S3","effort":"E2","confidence":"MEDIUM","files":["scripts/archive-doc.js:72","scripts/debt/generate-metrics.js:30","scripts/validate-audit.js:1"],"why_it_matters":"Some scripts have verbose() helper functions for debug output, others don't, leading to inconsistent debug capabilities. Makes troubleshooting harder when scripts don't expose internal state consistently.","suggested_fix":"Create shared logging utility (scripts/lib/logger.js) with consistent verbose/debug/info/warn/error methods. All scripts should import and use this utility for standardized output levels.","acceptance_tests":["Shared logging utility exists in scripts/lib/","All scripts use shared logger instead of raw console.*","Logger supports --verbose and --quiet flags consistently"],"file":"scripts/archive-doc.js","line":72,"description":"Some scripts have verbose() helper functions for debug output, others don't, leading to inconsistent debug capabilities. Makes troubleshooting harder when scripts don't expose internal state consistently.","recommendation":"Create shared logging utility (scripts/lib/logger.js) with consistent verbose/debug/info/warn/error methods. All scripts should import and use this utility for standardized output levels.","id":"process::scripts::verbose-logging"}
{"category":"process","title":"Inconsistent: Error message formatting","fingerprint":"process::scripts::error-message-format","severity":"S3","effort":"E1","confidence":"MEDIUM","files":["scripts/check-agent-compliance.js:163","scripts/check-backlog-health.js:103","scripts/security-check.js:415","scripts/validate-audit.js:753"],"why_it_matters":"Error messages use different formats: some use boxed separators (===, ---), some use simple prefixes. This creates inconsistent UX and makes it harder to parse errors programmatically.","suggested_fix":"Standardize error message format: [SCRIPT_NAME] LEVEL: message. Use consistent separator styles (=== for major sections, --- for subsections). Create error formatting utility function.","acceptance_tests":["All error messages follow standard format","Consistent use of separators across scripts","Error messages easily parseable by CI tools"],"file":"scripts/check-agent-compliance.js","line":163,"description":"Error messages use different formats: some use boxed separators (===, ---), some use simple prefixes. This creates inconsistent UX and makes it harder to parse errors programmatically.","recommendation":"Standardize error message format: [SCRIPT_NAME] LEVEL: message. Use consistent separator styles (=== for major sections, --- for subsections). Create error formatting utility function.","id":"process::scripts::error-message-format"}
{"category":"process","title":"Inconsistent: Command line argument parsing","fingerprint":"process::scripts::arg-parsing","severity":"S3","effort":"E2","confidence":"HIGH","files":["scripts/check-agent-compliance.js:29","scripts/archive-doc.js:52","scripts/debt/sync-sonarcloud.js:124"],"why_it_matters":"Scripts parse command line arguments differently: some use simple includes() checks, others have custom parseArgs() functions, creating inconsistent CLI interfaces and duplicated parsing logic.","suggested_fix":"Adopt a standard CLI parsing library (e.g., commander.js or yargs) for all scripts with complex arguments. For simple flags, use consistent pattern. Create shared argument parsing utilities.","acceptance_tests":["All scripts with 3+ arguments use standard CLI library","Simple flag-only scripts use consistent includes() pattern","Help text (--help) consistently formatted across scripts"],"file":"scripts/check-agent-compliance.js","line":29,"description":"Scripts parse command line arguments differently: some use simple includes() checks, others have custom parseArgs() functions, creating inconsistent CLI interfaces and duplicated parsing logic.","recommendation":"Adopt a standard CLI parsing library (e.g., commander.js or yargs) for all scripts with complex arguments. For simple flags, use consistent pattern. Create shared argument parsing utilities.","id":"process::scripts::arg-parsing"}
{"category":"process","title":"Inconsistent: File path validation and sanitization","fingerprint":"process::scripts::path-validation","severity":"S2","effort":"E2","confidence":"HIGH","files":["scripts/archive-doc.js:83","scripts/validate-audit.js:162","scripts/security-check.js:285"],"why_it_matters":"Path validation and sanitization logic is duplicated across scripts with slightly different implementations, risking security vulnerabilities if one implementation is weaker. Validation should be centralized.","suggested_fix":"Create shared path validation utilities in scripts/lib/validate-paths.js. Implement validatePathWithinRepo(), sanitizePath(), isSafeFilePath() once and reuse. Add comprehensive tests.","acceptance_tests":["Shared path validation utilities exist and are well-tested","All scripts use shared validation functions","Security team has reviewed centralized validation logic"],"file":"scripts/archive-doc.js","line":83,"description":"Path validation and sanitization logic is duplicated across scripts with slightly different implementations, risking security vulnerabilities if one implementation is weaker. Validation should be centralized.","recommendation":"Create shared path validation utilities in scripts/lib/validate-paths.js. Implement validatePathWithinRepo(), sanitizePath(), isSafeFilePath() once and reuse. Add comprehensive tests.","id":"process::scripts::path-validation"}
{"category":"process","title":"Inconsistent: Error sanitization approaches","fingerprint":"process::scripts::error-sanitization","severity":"S2","effort":"E1","confidence":"HIGH","files":["scripts/archive-doc.js:41","scripts/migrate-addresses.ts:14","scripts/debt/generate-metrics.js:49"],"why_it_matters":"Some scripts import sanitizeError utility, others inline error sanitization, and some don't sanitize at all. This creates security risk of exposing sensitive paths or tokens in error messages.","suggested_fix":"Ensure all scripts use shared sanitizeError() utility from scripts/lib/sanitize-error.js. Add ESLint rule to catch raw error.message usage. Document sanitization requirement in CONTRIBUTING.md.","acceptance_tests":["All scripts import and use sanitizeError() utility","No raw error.message in console.error() calls","ESLint catches unsanitized error output"],"file":"scripts/archive-doc.js","line":41,"description":"Some scripts import sanitizeError utility, others inline error sanitization, and some don't sanitize at all. This creates security risk of exposing sensitive paths or tokens in error messages.","recommendation":"Ensure all scripts use shared sanitizeError() utility from scripts/lib/sanitize-error.js. Add ESLint rule to catch raw error.message usage. Document sanitization requirement in CONTRIBUTING.md.","id":"process::scripts::error-sanitization"}
