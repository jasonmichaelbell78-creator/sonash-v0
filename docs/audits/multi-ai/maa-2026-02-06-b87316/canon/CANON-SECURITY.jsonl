{"category":"Headers","title":"Missing Content-Security-Policy and COEP hardening in Firebase Hosting headers","fingerprint":"Headers::firebase.json::missing_csp","severity":"S1","effort":"E2","confidence":98,"files":["firebase.json"],"vulnerability_details":{"description":"firebase.json config sets several security headers (HSTS, XFO, nosniff, Referrer-Policy, Permissions-Policy) but omits Content-Security-Policy (CSP) and Cross-Origin-Embedder-Policy (COEP).","exploitation":"Without CSP, an XSS flaw elsewhere is easier to weaponize (no script-src constraints). Without COEP (paired with COOP), the app can't enforce cross-origin isolation and is more exposed to certain browser cross-origin risks.","impact":"Reduced browser-side mitigation for XSS and other injection classes; weaker defense-in-depth.","affected_data":"All users of the hosted web app"},"remediation":{"steps":["Add a restrictive CSP tailored to Next.js static export + Firebase Hosting (script-src 'self' with required allowances; avoid unsafe-inline if possible).","If cross-origin isolation is desired, add COEP and ensure resources comply (or explicitly decide not to use it and document rationale).","Add CI check to ensure security headers include CSP at minimum."],"code_example":"{\n  \"key\": \"Content-Security-Policy\",\n  \"value\": \"default-src 'self'; img-src 'self' data: https:; style-src 'self' 'unsafe-inline'; script-src 'self'; connect-src 'self' https://*.googleapis.com https://*.firebaseio.com https://identitytoolkit.googleapis.com; frame-ancestors 'none'\"\n}","verification":["Deploy and confirm response headers include CSP on '**' routes.","Run a CSP evaluator and ensure no blocking of required Firebase endpoints.","Attempt inline script injection: should be blocked when CSP is tightened (where feasible)."]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":["firebase.json:30-56 headers list does not include Content-Security-Policy or Cross-Origin-Embedder-Policy","firebase.json:6-58: Headers section defines X-Frame-Options, HSTS, nosniff, COOP, Referrer-Policy, Permissions-Policy but NO Content-Security-Policy","firebase.json:6-57 - NO Content-Security-Policy header found in headers array"],"notes":"COOP is set to same-origin-allow-popups; ensure this is intended and compatible with any auth popups.","line":30,"sources":[{"source":"chatgpt","file":"security-chatgpt.jsonl","original_fingerprint":"Headers::firebase.json::missing_csp"},{"source":"claude-code","file":"security-claude-code.jsonl","original_fingerprint":"Headers::firebase.json::missing_csp"},{"source":"copilot","file":"security-copilot.jsonl","original_fingerprint":"Headers::firebase.json::missing_csp"}],"merged_from":["Headers::firebase.json::missing_csp","Headers::firebase.json::missing_csp","Headers::firebase.json::missing_csp"],"verified":true,"consensus_score":4,"canonical_id":"CANON-0001","status":"CONFIRMED"}
{"category":"Firebase","title":"App Check enforcement disabled on callable write endpoints","fingerprint":"Firebase::functions/src/index.ts::appcheck_disabled","severity":"S1","effort":"E2","confidence":90,"files":["functions/src/index.ts","lib/firebase.ts"],"vulnerability_details":{"description":"Multiple security-critical callable functions explicitly set requireAppCheck: false, disabling App Check verification.","exploitation":"An attacker can call callable functions from non-genuine clients (e.g., scripted requests using a stolen/abused Firebase Auth session) without needing App Check, increasing abuse/fraud risk against write endpoints (journal/daily logs/inventory).","impact":"Higher likelihood of automated abuse, quota exhaustion, write spam, and cost amplification; reduces defense-in-depth for auth-bound operations.","affected_data":"User journal/daily logs/inventory collections written via Admin SDK"},"remediation":{"steps":["Re-enable App Check for production by setting requireAppCheck: true (or omitting the override) for all non-admin callable functions.","If a temporary operational bypass is needed, gate it behind an explicit non-production environment check (e.g., FUNCTIONS_EMULATOR) and ensure CI prevents deployment with App Check disabled.","Add a release-blocking check/hook that fails builds when requireAppCheck: false is present outside emulator-only code paths."],"code_example":"// functions/src/index.ts\nwithSecurityChecks(request, {\n  functionName: \"saveDailyLog\",\n  rateLimiter: saveDailyLogLimiter,\n  ipRateLimiter: saveDailyLogIpLimiter,\n  validationSchema: dailyLogSchema.strict(),\n  requireAppCheck: true,\n  recaptchaAction: \"save_daily_log\",\n}, handler)","verification":["Attempt callable invocation without App Check token in prod: must fail with failed-precondition.","Run grep in CI to ensure no requireAppCheck: false exists in production paths."]},"owasp_category":"A05","cvss_estimate":"HIGH","evidence":["functions/src/index.ts:84 requireAppCheck: false // TEMPORARILY DISABLED","functions/src/index.ts:170 requireAppCheck: false","functions/src/index.ts:269 requireAppCheck: false","functions/src/index.ts:363 requireAppCheck: false","functions/src/index.ts:84 requireAppCheck: false","lib/firebase.ts:57-90 App Check initialization commented out"],"notes":"Evidence excerpt: functions/src/index.ts lines 81-86 show requireAppCheck: false.","line":84,"sources":[{"source":"chatgpt","file":"security-chatgpt.jsonl","original_fingerprint":"Firebase::functions/src/index.ts::appcheck_disabled"},{"source":"codex","file":"security-codex.jsonl","original_fingerprint":"Firebase::functions/src/index.ts::app-check-disabled"}],"merged_from":["Firebase::functions/src/index.ts::appcheck_disabled","Firebase::functions/src/index.ts::app-check-disabled","Firebase::functions/src/index.ts::app_check_disabled"],"verified":true,"consensus_score":3,"canonical_id":"CANON-0002","status":"CONFIRMED"}
{"category":"Firebase","title":"App Check disabled on all Cloud Functions","fingerprint":"Firebase::lib/firebase.ts::app_check_disabled","severity":"S1","effort":"E1","confidence":100,"files":["lib/firebase.ts","functions/src/index.ts","functions/src/security-wrapper.ts"],"line":57,"vulnerability_details":{"description":"Firebase App Check initialization is completely commented out in lib/firebase.ts lines 57-91. Every Cloud Function sets requireAppCheck: false in its withSecurityChecks options. This removes the bot-protection layer, allowing automated abuse of all Cloud Function endpoints.","exploitation":"An attacker scripts direct calls to Cloud Functions using the Firebase JS SDK without presenting a valid App Check attestation token. While authentication and rate limiting still apply, there is no bot-detection gate, enabling account-cycling attacks at scale.","impact":"Automated abuse of all 38+ Cloud Function endpoints; potential resource exhaustion via distributed bot attacks that exceed per-user rate limits by cycling anonymous accounts.","affected_data":"All Cloud Function endpoints: saveDailyLog, saveJournalEntry, softDeleteJournalEntry, saveInventoryEntry, migrateAnonymousUserData, and all admin functions"},"remediation":{"steps":["1. Uncomment App Check initialization block in lib/firebase.ts lines 57-91","2. Set requireAppCheck: true in withSecurityChecks options for saveDailyLog (index.ts:84), saveJournalEntry (index.ts:170), softDeleteJournalEntry (index.ts:~270), saveInventoryEntry (index.ts:~365)","3. Re-enable App Check verification in migrateAnonymousUserData (index.ts:506-511)","4. Configure App Check enforcement mode in Firebase Console","5. Test all Cloud Function calls succeed with valid App Check tokens and fail without"],"code_example":"// lib/firebase.ts - uncomment lines 57-91\n// functions/src/index.ts - change to:\nrequireAppCheck: true,","verification":["Verify request.app is non-null for all Cloud Function calls in production","Send a Cloud Function call without App Check token and confirm it returns failed-precondition error","Run full integration test suite after re-enabling"]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":["lib/firebase.ts:57: // TEMPORARILY DISABLED: App Check is disabled due to 24-hour throttle","lib/firebase.ts:58: // Will re-enable after throttle clears (Dec 31, ~01:02 UTC)","functions/src/index.ts:84: requireAppCheck: false, // TEMPORARILY DISABLED - waiting for throttle to clear","functions/src/index.ts:170: requireAppCheck: false, // TEMPORARILY DISABLED - waiting for throttle to clear","functions/src/index.ts:506-511: App Check verification block commented out"],"notes":"Disabled since Dec 31 2025 due to reCAPTCHA throttle. The throttle window is 24 hours; this has been disabled for over 5 weeks.","sources":[{"source":"claude-code","file":"security-claude-code.jsonl","original_fingerprint":"Firebase::lib/firebase.ts::app_check_disabled"},{"source":"copilot","file":"security-copilot.jsonl","original_fingerprint":"Firebase::lib/firebase.ts::app_check_disabled"}],"merged_from":["Firebase::lib/firebase.ts::app_check_disabled","Firebase::lib/firebase.ts::app_check_disabled"],"verified":true,"consensus_score":3,"canonical_id":"CANON-0003","status":"CONFIRMED"}
{"category":"SecretsManagement","title":"Committed .env.production and insufficient .gitignore env patterns (risk of secret leakage)","fingerprint":"SecretsManagement::.env.production::env_committed","severity":"S1","effort":"E1","confidence":90,"files":[".env.production",".gitignore"],"vulnerability_details":{"description":".env.production is present in the repository, and .gitignore only ignores .env*.local, not .env.production. This creates a high risk of accidental secret commits now or in the future.","exploitation":"If any true secrets (API tokens, admin keys, service credentials) are ever added to .env.production, they would be committed to git history and potentially exposed to anyone with repo access. Even if current values are intended to be public, the pattern is unsafe.","impact":"Potential credential exposure, account takeover, data breach depending on what gets committed.","affected_data":"Any environment secrets that may be introduced (Sentry tokens, Firebase service creds, API keys, etc.)"},"remediation":{"steps":["Remove .env.production from version control; rotate any secrets that were ever placed in it.","Update .gitignore to ignore .env* (with explicit allowlist for .env.example) and enforce via pre-commit/CI.","Keep a sanitized .env.example (present) with no real values."],"code_example":"# .gitignore\n.env*\n!.env.example\n!.env.local.example","verification":["Verify git status shows .env.production untracked and CI fails if env files are added.","Run secret scanners (gitleaks/trufflehog) over git history after removal; rotate any flagged credentials."]},"owasp_category":"A05","cvss_estimate":"HIGH","evidence":[".gitignore:31 .env*.local (does not ignore .env.production)","./.env.production contains NEXT_PUBLIC_* configuration and is committed"],"notes":"Even if Firebase web API keys are not secret, committed env files violate the mandatory secrets management standard.","line":1,"sources":[{"source":"chatgpt","file":"security-chatgpt.jsonl","original_fingerprint":"SecretsManagement::.env.production::env_committed"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0005","status":"CONFIRMED"}
{"category":"InputValidation","title":"Cloud Function Zod schemas are not strict; unknown fields accepted","fingerprint":"InputValidation::functions/src/schemas.ts::missing_strict","severity":"S2","effort":"E1","confidence":98,"files":["functions/src/schemas.ts","functions/src/security-wrapper.ts"],"vulnerability_details":{"description":"Schemas use z.object({...}) without .strict(). This allows unknown fields through validation, contrary to mandatory standards.","exploitation":"Attackers can supply unexpected fields to probe behavior, attempt schema smuggling, or prepare future exploitation if handlers begin trusting extra fields. It also complicates auditability and can enable log/telemetry pollution.","impact":"Reduced input robustness and future-proofing; increased risk of insecure handling of unexpected fields.","affected_data":"All callable function inputs validated by these schemas"},"remediation":{"steps":["Add .strict() to all z.object schemas used for external inputs (dailyLogSchema, journalEntrySchema, inventoryEntrySchema, softDeleteJournalEntrySchema, migrationDataSchema, and admin request wrappers where applicable).","Add explicit max length limits for optional string fields (e.g., mood, tags items) and array bounds where appropriate.","Prefer z.record with bounded keys/values or per-type schemas for journalEntry 'data' where feasible."],"code_example":"export const dailyLogSchema = z.object({\n  date: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/),\n  content: z.string().max(50000),\n  mood: z.string().max(64).nullable().optional(),\n  ...\n}).strict();","verification":["Send request with extra field (e.g., {date, content, extra: \"x\"}): must fail with invalid-argument.","Fuzz unknown fields at root and nested levels; confirm rejection."]},"owasp_category":"A03","cvss_estimate":"MEDIUM","evidence":["functions/src/schemas.ts:5-13 dailyLogSchema = z.object({ ... }) (no .strict())","functions/src/security-wrapper.ts:211-216 validationSchema.parse(request.data)","functions/src/schemas.ts:5-70 - No .strict() calls found in dailyLogSchema, journalEntrySchema, inventoryEntrySchema"],"notes":"This is a standards-compliance gap even if current handlers ignore unknown fields.","line":5,"sources":[{"source":"chatgpt","file":"security-chatgpt.jsonl","original_fingerprint":"InputValidation::functions/src/schemas.ts::missing_strict"},{"source":"copilot","file":"security-copilot.jsonl","original_fingerprint":"InputValidation::functions/src/schemas.ts::missing_strict"}],"merged_from":["InputValidation::functions/src/schemas.ts::missing_strict","InputValidation::functions/src/schemas.ts::missing_strict"],"verified":true,"consensus_score":3,"canonical_id":"CANON-0006","status":"CONFIRMED"}
{"category":"Headers","title":"Missing Cross-Origin-Embedder-Policy header","fingerprint":"Headers::firebase.json::missing_coep","severity":"S2","effort":"E0","confidence":100,"files":["firebase.json"],"line":29,"vulnerability_details":{"description":"Cross-Origin-Embedder-Policy (COEP) header is not configured in firebase.json. COOP is set to same-origin-allow-popups but COEP is absent.","exploitation":"Without COEP, the site cannot enable cross-origin isolation (required for SharedArrayBuffer). The primary risk is Spectre-class side-channel attacks reading cross-origin data, but this requires the attacker to already have script execution.","impact":"Minimal for this application. COEP is primarily needed for applications using SharedArrayBuffer or high-resolution timers.","affected_data":"N/A for current application scope"},"remediation":{"steps":["1. Add COEP header: Cross-Origin-Embedder-Policy: require-corp","2. Verify all cross-origin resources (reCAPTCHA script, Sentry, Google fonts if any) still load correctly","3. If resources break, use crossorigin attributes or CORS headers on those resources"],"code_example":"{\"key\": \"Cross-Origin-Embedder-Policy\", \"value\": \"require-corp\"}","verification":["Verify header present via curl -I","Test reCAPTCHA and Sentry still load correctly"]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":["firebase.json:29-57: Global headers section includes COOP but not COEP","firebase.json:6-57 - No Cross-Origin-Embedder-Policy header found"],"sources":[{"source":"claude-code","file":"security-claude-code.jsonl","original_fingerprint":"Headers::firebase.json::missing_coep"},{"source":"copilot","file":"security-copilot.jsonl","original_fingerprint":"Headers::firebase.json::missing_coep"}],"merged_from":["Headers::firebase.json::missing_coep","Headers::firebase.json::missing_coep"],"verified":true,"consensus_score":3,"canonical_id":"CANON-0007","status":"CONFIRMED"}
{"category":"RateLimiting","title":"IP-based rate limiting is supported but not applied to public callable endpoints","fingerprint":"RateLimiting::functions/src/security-wrapper.ts::missing_ip_limiters","severity":"S2","effort":"E2","confidence":85,"files":["functions/src/security-wrapper.ts","functions/src/index.ts"],"vulnerability_details":{"description":"Security wrapper supports ipRateLimiter, but core public callable functions only provide rateLimiter (user-based) and omit ipRateLimiter, violating the required IP+user limiting standard.","exploitation":"An attacker can cycle accounts (or use multiple compromised accounts) from a single IP to amplify request volume; user-only limiting is less effective against account cycling and bot swarms.","impact":"Increased abuse potential and cost risk; reduced throttling effectiveness for write endpoints.","affected_data":"Callable endpoints (saveDailyLog/saveJournalEntry/saveInventoryEntry/softDeleteJournalEntry/migrateAnonymousUserData)"},"remediation":{"steps":["Instantiate dedicated FirestoreRateLimiter instances for IP keys (separate points/duration per operation class).","Pass ipRateLimiter into withSecurityChecks for each public callable function.","Add logging/metrics to distinguish IP-based vs user-based throttling events."],"code_example":"// functions/src/index.ts\nconst saveDailyLogIpLimiter = new FirestoreRateLimiter({ points: 30, duration: 60 });\n...\nwithSecurityChecks(request, {\n  functionName: \"saveDailyLog\",\n  rateLimiter: saveDailyLogLimiter,\n  ipRateLimiter: saveDailyLogIpLimiter,\n  ...\n}, handler)","verification":["From a single IP, make requests across multiple accounts: IP limiter must eventually block even if per-user limits are not hit.","Confirm RATE_LIMIT_EXCEEDED logs include indicator for IP vs user limiting."]},"owasp_category":"A04","cvss_estimate":"MEDIUM","evidence":["functions/src/security-wrapper.ts:37 ipRateLimiter?: FirestoreRateLimiter;","functions/src/security-wrapper.ts:362 await checkIpRateLimit(ipRateLimiter, request, userId, functionName);","functions/src/index.ts:82 rateLimiter: saveDailyLogLimiter (no ipRateLimiter provided)"],"notes":"No ipRateLimiter passed in functions/src/index.ts option objects for public callables.","line":37,"sources":[{"source":"chatgpt","file":"security-chatgpt.jsonl","original_fingerprint":"RateLimiting::functions/src/security-wrapper.ts::missing_ip_limiters"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0008","status":"CONFIRMED"}
{"category":"RateLimiting","title":"Rate limit exceed is treated as generic failure in FirestoreRateLimiter, undermining graceful 429 behavior","fingerprint":"RateLimiting::functions/src/firestore-rate-limiter.ts::misclassified_exceed","severity":"S2","effort":"E1","confidence":90,"files":["functions/src/firestore-rate-limiter.ts","functions/src/security-wrapper.ts"],"vulnerability_details":{"description":"When the limiter exceeds, it throws Error(\"Too many requests...\") but the catch block only re-throws if message includes \"Rate limit exceeded\". This condition never matches the thrown message, so the limiter converts an exceed into a generic \"Service temporarily unavailable...\" error.","exploitation":"Abuse traffic causes the limiter to respond as if the service is unstable; clients may implement incorrect retries/backoff. This also weakens operational visibility and violates the requirement for predictable graceful 429/Retry-After semantics.","impact":"Unreliable throttling semantics; client retry storms; reduced abuse handling; observability confusion.","affected_data":"All endpoints using FirestoreRateLimiter"},"remediation":{"steps":["Use a distinct error type or a stable sentinel (e.g., throw new RateLimitExceededError) and detect it explicitly.","If you must keep messages generic, set an internal flag/property to identify rate limit exceeded.","In callable functions, map limiter errors to consistent resource-exhausted responses and optionally include a safe retry-after hint (even if coarse-grained)."],"code_example":"// functions/src/firestore-rate-limiter.ts\nclass RateLimitExceededError extends Error { constructor(){ super(\"RATE_LIMIT_EXCEEDED\"); } }\n...\nthrow new RateLimitExceededError();\n...\nif (error instanceof RateLimitExceededError) throw error;","verification":["Exceed limit: confirm the thrown error is classified as rate limit (not generic service unavailable).","Confirm wrapper logs RATE_LIMIT_EXCEEDED for true throttles and uses a consistent client-facing error."]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":["functions/src/firestore-rate-limiter.ts:116 throw new Error(\"Too many requests. Please try again later.\")","functions/src/firestore-rate-limiter.ts:133-142 catch only re-throws when message includes \"Rate limit exceeded\""],"notes":"This is a logic mismatch between the thrown message and the detection predicate.","line":116,"sources":[{"source":"chatgpt","file":"security-chatgpt.jsonl","original_fingerprint":"RateLimiting::functions/src/firestore-rate-limiter.ts::misclassified_exceed"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0009","status":"CONFIRMED"}
{"category":"OWASP","title":"3 high-severity npm audit dependency vulnerabilities","fingerprint":"OWASP::package.json::npm_audit_high","severity":"S2","effort":"E1","confidence":100,"files":["package.json","functions/package.json"],"line":1,"vulnerability_details":{"description":"npm audit reports 3 high-severity vulnerabilities across root and functions packages: (1) Root: @isaacs/brace-expansion ReDoS (GHSA-7h2j-956f-4vf2); (2) Functions: fast-xml-parser DoS via numeric entities (GHSA-37qj-frw5-hhjh, CVSS 7.5, range >=4.3.6 <=5.3.3); (3) Functions: @google-cloud/storage 7.12.1-7.18.0 (transitive dependency on vulnerable fast-xml-parser).","exploitation":"fast-xml-parser: A crafted XML payload with numeric entities can cause RangeError DoS. If @google-cloud/storage internally parses XML responses from GCP APIs (which it does for multi-part operations), a malicious or malformed GCP response could trigger this. brace-expansion: ReDoS via crafted glob patterns, primarily affects dev tooling.","impact":"Potential denial of service in Cloud Functions via fast-xml-parser. The brace-expansion issue affects build tooling only.","affected_data":"Cloud Function availability and responsiveness"},"remediation":{"steps":["1. cd functions && npm audit fix","2. If fix unavailable, check for @google-cloud/storage version > 7.18.0","3. cd / && npm audit fix for root brace-expansion","4. If no automatic fix available, document accepted risk with justification"],"verification":["npm audit --json shows 0 high/critical in both root and functions/"]},"owasp_category":"A06","cvss_estimate":"MEDIUM","evidence":["functions npm audit: fast-xml-parser severity:high CVSS:7.5 range:>=4.3.6 <=5.3.3 url:GHSA-37qj-frw5-hhjh","functions npm audit: @google-cloud/storage severity:high range:7.12.1-7.18.0 via fast-xml-parser","root npm audit: @isaacs/brace-expansion severity:high url:GHSA-7h2j-956f-4vf2"],"sources":[{"source":"claude-code","file":"security-claude-code.jsonl","original_fingerprint":"OWASP::package.json::npm_audit_high"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0010","status":"CONFIRMED"}
{"category":"Firebase","title":"Admin CRUD uses client Firestore writes, bypassing server validation and rate limiting","fingerprint":"Firebase::lib/db/quotes.ts::client-admin-writes","severity":"S2","effort":"E2","confidence":82,"files":["lib/db/quotes.ts","components/admin/quotes-tab.tsx","lib/db/slogans.ts","components/admin/slogans-tab.tsx","firestore.rules"],"vulnerability_details":{"description":"Admin tabs call client Firestore CRUD services directly for admin-managed collections, bypassing Cloud Functions' server-side validation, rate limiting, and audit logging.","exploitation":"Compromised admin sessions can write malformed or excessive data without server-side controls, increasing abuse and data integrity risks.","impact":"Administrative content collections can be tampered with outside server-side security controls.","affected_data":"daily_quotes, slogans, and other admin-managed collections."},"remediation":{"steps":["Route all admin CRUD through callable Cloud Functions with Zod validation and rate limiting.","Update Firestore rules to deny direct client writes to admin-managed collections (admin SDK only).","Add audit logging for admin writes in functions."]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":["components/admin/quotes-tab.tsx:102-121 admin uses QuotesService adapter","lib/db/quotes.ts:38-52 addDoc/updateDoc/deleteDoc client writes","components/admin/slogans-tab.tsx:105-120 admin uses SlogansService adapter","lib/db/slogans.ts:47-70 setDoc/updateDoc/deleteDoc client writes","firestore.rules:101-129 admin writes allowed for daily_quotes/slogans/quick_links/prayers"],"notes":"Policy expects server-side controls on admin operations.","line":102,"sources":[{"source":"codex","file":"security-codex.jsonl","original_fingerprint":"Firebase::lib/db/quotes.ts::client-admin-writes"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0011","status":"CONFIRMED"}
{"category":"SecretsManagement","title":"Production environment values committed with NEXT_PUBLIC* keys","fingerprint":"SecretsManagement::.env.production::public-env-committed","severity":"S2","effort":"E1","confidence":90,"files":[".env.production"],"vulnerability_details":{"description":"A committed .env.production file contains NEXT_PUBLIC_* values (API keys, App Check site key, Sentry DSN), violating the no-secrets-in-repo and no-client-secrets standard.","exploitation":"Attackers can scrape public repo history for identifiers and use them for abuse or reconnaissance.","impact":"Exposes production identifiers and violates mandatory secrets-management standard.","affected_data":"Firebase project identifiers and Sentry DSN."},"remediation":{"steps":["Remove .env.production from version control and rotate exposed keys where applicable.","Store secrets in environment/secret manager and provide a sanitized .env.example.","Ensure NEXT_PUBLIC values are limited to non-sensitive identifiers only."],"verification":["Verify .env.production is gitignored and removed from repo history.","Confirm deployment injects secrets via environment config, not committed files."]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":[".env.production:5-21 NEXT_PUBLIC_* values present in repo"],"notes":"Firebase API keys are public by design, but policy explicitly forbids secrets in NEXT_PUBLIC_* and committed env files.","line":5,"sources":[{"source":"codex","file":"security-codex.jsonl","original_fingerprint":"SecretsManagement::.env.production::public-env-committed"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0012","status":"CONFIRMED"}
{"category":"Headers","title":"Missing CSP and COEP headers in hosting configuration","fingerprint":"Headers::firebase.json::missing-csp-coep","severity":"S2","effort":"E1","confidence":84,"files":["firebase.json"],"vulnerability_details":{"description":"Firebase Hosting headers omit Content-Security-Policy (CSP) and Cross-Origin-Embedder-Policy (COEP).","exploitation":"Absent CSP increases XSS impact. Missing COEP weakens cross-origin isolation for security-sensitive features.","impact":"Higher exposure to script injection and weaker browser isolation.","affected_data":"All hosted pages."},"remediation":{"steps":["Add a restrictive CSP tuned for Next.js static exports.","Add COEP/COOP pair where required and test with App Check and Google OAuth flows.","Validate headers with security scanners or curl."]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":["firebase.json:6-56 headers list does not include CSP or COEP"],"notes":"COOP is present but COEP is missing.","line":6,"sources":[{"source":"codex","file":"security-codex.jsonl","original_fingerprint":"Headers::firebase.json::missing-csp-coep"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0013","status":"CONFIRMED"}
{"category":"FileHandling","title":"Missing File MIME Type Validation in Storage Rules","fingerprint":"FileHandling::storage.rules::missing_mime_validation","severity":"S2","effort":"E2","confidence":90,"files":["storage.rules"],"line":14,"vulnerability_details":{"description":"Storage rules do NOT validate file MIME types. User can upload arbitrary files (executables, scripts).","exploitation":"Upload malicious files disguised as images. If file sharing added, serve to other users.","impact":"Potential phishing, malware distribution, stored XSS (if files rendered as HTML).","affected_data":"All user uploads in Firebase Storage"},"remediation":{"steps":["Add MIME type validation to storage.rules","Restrict to allowed types (image/*, application/pdf)","Add file size limit (10MB)","Test file upload functionality"],"code_example":"match /users/{userId}/{allPaths=**} {\n  allow read: if request.auth != null && request.auth.uid == userId;\n  allow write: if request.auth != null \n    && request.auth.uid == userId\n    && request.resource.size < 10 * 1024 * 1024\n    && request.resource.contentType.matches('image/.*|application/pdf');\n}","verification":["Attempt to upload .exe file (should fail)","Upload valid image (should succeed)","Verify user-friendly error message"]},"owasp_category":"A01","cvss_estimate":"MEDIUM","evidence":["storage.rules:14-17 - No request.resource.contentType validation found"],"sources":[{"source":"copilot","file":"security-copilot.jsonl","original_fingerprint":"FileHandling::storage.rules::missing_mime_validation"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0014","status":"CONFIRMED"}
{"category":"Dependency","title":"High Severity Vulnerability in brace-expansion","fingerprint":"Dependency::package.json::brace-expansion","severity":"S2","effort":"E0","confidence":100,"files":["package-lock.json"],"vulnerability_details":{"description":"@isaacs/brace-expansion < 5.0.0 has Uncontrolled Resource Consumption.","exploitation":"DoS via crafted input if used in path expansion.","impact":"Service denial.","affected_data":"Availability"},"remediation":{"steps":["Run npm update @isaacs/brace-expansion"],"verification":["npm audit"]},"owasp_category":"A06","cvss_estimate":"HIGH","evidence":["npm audit output"],"line":1,"sources":[{"source":"jules","file":"security-jules.jsonl","original_fingerprint":"Dependency::package.json::brace-expansion"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0015","status":"CONFIRMED"}
{"category":"DependencySecurity","title":"Dependency vulnerability status unknown (npm audit unavailable in environment)","fingerprint":"DependencySecurity::package-lock.json::audit_unverified","severity":"S2","effort":"E2","confidence":30,"files":["package.json","package-lock.json"],"vulnerability_details":{"description":"Unable to confirm whether dependencies contain known critical/high vulnerabilities because npm audit cannot run against the configured registry in this environment.","exploitation":"If vulnerable transitive packages exist (e.g., SSRF, prototype pollution, ReDoS), they may be exploitable depending on runtime exposure.","impact":"Potential compromise depending on affected package and usage.","affected_data":"Varies by vulnerable component"},"remediation":{"steps":["Run `npm audit` in your normal dev environment (or GitHub Actions) against the same lockfile.","Supplement with `pnpm audit`/Snyk/Dependabot alerts and enforce a CI gate for critical/high findings.","Document and timebox any exceptions with compensating controls."],"code_example":"","verification":["CI job: run npm audit (or Snyk) and fail on critical/high.","Confirm Dependabot alerts are enabled and triaged."]},"owasp_category":"A06","cvss_estimate":"MEDIUM","evidence":["npm audit returned: \"Repo npm-public does not support npm audit\" (environment limitation)"],"notes":"Not a code defect; it's an evidence limitation that must be resolved externally.","line":1,"sources":[{"source":"chatgpt-suspected","file":"security-chatgpt-suspected.jsonl","original_fingerprint":"DependencySecurity::package-lock.json::audit_unverified"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0016","status":"SUSPECTED"}
{"category":"OWASP","title":"Dependency vulnerability status unknown due to blocked npm audit/outdated","fingerprint":"OWASP::package-lock.json::audit-blocked","severity":"S2","effort":"E1","confidence":30,"files":["package-lock.json"],"vulnerability_details":{"description":"Dependency vulnerability status could not be confirmed because npm audit/outdated requests returned 403.","exploitation":"Unknown; dependent on unresolved audit results.","impact":"Potential exposure to known vulnerabilities if outdated packages exist.","affected_data":"Application and build-time dependencies."},"remediation":{"steps":["Run npm audit and npm outdated in an environment with registry access.","Document and remediate any critical/high advisories."]},"owasp_category":"A06","cvss_estimate":"MEDIUM","evidence":["npm audit/outdated blocked by registry 403 (see command output)"],"notes":"Requires rerun in network-permitted environment.","line":1,"sources":[{"source":"codex-suspected","file":"security-codex-suspected.jsonl","original_fingerprint":"OWASP::package-lock.json::audit-blocked"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0017","status":"SUSPECTED"}
{"category":"RateLimiting","title":"IP-based rate limiting not enforced and Retry-After headers missing","fingerprint":"RateLimiting::functions/src/security-wrapper.ts::ip-rate-limit-missing","severity":"S2","effort":"E2","confidence":78,"files":["functions/src/security-wrapper.ts","functions/src/index.ts"],"vulnerability_details":{"description":"The security wrapper supports IP-based rate limiting but it is optional and not configured on user-facing callable functions. Rate limit errors use HttpsError without Retry-After guidance.","exploitation":"Attackers can rotate accounts from a single IP to bypass user-based limits. Clients do not get Retry-After guidance for backoff.","impact":"Higher risk of automated abuse and noisy clients under load.","affected_data":"All callable function endpoints."},"remediation":{"steps":["Configure ipRateLimiter for all public callable functions (user + IP).","Include retryAfterSeconds in error details and/or migrate to onRequest with explicit 429/Retry-After headers.","Log rate-limit hits with structured metadata for monitoring."]},"owasp_category":"A04","cvss_estimate":"MEDIUM","evidence":["functions/src/security-wrapper.ts:33-38 ipRateLimiter is optional","functions/src/security-wrapper.ts:88-109 HttpsError resource-exhausted without Retry-After","functions/src/index.ts:80-86 withSecurityChecks options omit ipRateLimiter"],"notes":"Standards require IP + user limits and Retry-After.","line":88,"sources":[{"source":"codex","file":"security-codex.jsonl","original_fingerprint":"RateLimiting::functions/src/security-wrapper.ts::ip-rate-limit-missing"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0018","status":"SUSPECTED"}
{"category":"InputValidation","title":"Zod schemas are not strict and allow unbounded fields","fingerprint":"InputValidation::functions/src/schemas.ts::non-strict-zod","severity":"S2","effort":"E2","confidence":76,"files":["functions/src/schemas.ts"],"vulnerability_details":{"description":"Schemas use z.object() without .strict(), and several inputs (tags arrays, data blobs) lack length limits. Unknown fields are accepted and large payloads can slip through.","exploitation":"Attackers can submit oversized or unexpected fields to increase processing/storage costs or smuggle data past intended validation.","impact":"Input validation gaps increase risk of injection-style payloads and resource exhaustion.","affected_data":"Callable function inputs for daily logs, journal entries, inventory entries, and admin data."},"remediation":{"steps":["Add .strict() to all top-level Zod schemas.","Add max length constraints for tags, searchableText, and free-form data fields.","Introduce per-type schemas for journal/inventory data payloads."]},"owasp_category":"A03","cvss_estimate":"MEDIUM","evidence":["functions/src/schemas.ts:5-55 z.object definitions without .strict() and unbounded tags/data"],"notes":"Requirement mandates strict schemas and length limits for all inputs.","line":5,"sources":[{"source":"codex","file":"security-codex.jsonl","original_fingerprint":"InputValidation::functions/src/schemas.ts::non-strict-zod"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0019","status":"SUSPECTED"}
{"category":"SecretsManagement","title":"Hardcoded reCAPTCHA Site Key Fallback","fingerprint":"SecretsManagement::functions/src/recaptcha-verify.ts::hardcoded_site_key","severity":"S3","effort":"E0","confidence":100,"files":["functions/src/recaptcha-verify.ts"],"line":66,"vulnerability_details":{"description":"reCAPTCHA site key has hardcoded fallback value: '6LdeazosAAAAAMDNCh1hTUDKh_UeS6xWY1-85B2O'. Site keys are public but hardcoding violates best practices.","exploitation":"Limited - site keys are designed to be public. Primary issue is difficulty rotating keys.","impact":"Harder key rotation, potential for using wrong environment's key.","affected_data":"reCAPTCHA verification in Cloud Functions"},"remediation":{"steps":["Remove hardcoded fallback from recaptcha-verify.ts:66","Ensure RECAPTCHA_SITE_KEY set in all environments","Throw error if env var missing"],"code_example":"const siteKey = process.env.RECAPTCHA_SITE_KEY;\nif (!siteKey) {\n  throw new Error('RECAPTCHA_SITE_KEY environment variable not configured');\n}","verification":["Deploy without env var (should fail on init)","Set env var and verify reCAPTCHA works"]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":["functions/src/recaptcha-verify.ts:66 const siteKey = process.env.RECAPTCHA_SITE_KEY || '6LdeazosAAAAAMDNCh1hTUDKh_UeS6xWY1-85B2O';"],"sources":[{"source":"copilot","file":"security-copilot.jsonl","original_fingerprint":"SecretsManagement::functions/src/recaptcha-verify.ts::hardcoded_site_key"},{"source":"kimi","file":"security-kimi.jsonl","original_fingerprint":"SecretsManagement::functions/src/recaptcha-verify.ts::hardcoded_key"}],"merged_from":["SecretsManagement::functions/src/recaptcha-verify.ts::hardcoded_site_key","SecretsManagement::functions/src/recaptcha-verify.ts::hardcoded_key"],"verified":true,"consensus_score":3,"canonical_id":"CANON-0020","status":"CONFIRMED"}
{"category":"InputValidation","title":"Zod schemas missing .strict() mode","fingerprint":"InputValidation::functions/src/schemas.ts::no_strict_mode","severity":"S3","effort":"E1","confidence":90,"files":["functions/src/schemas.ts"],"line":5,"vulnerability_details":{"description":"All Zod validation schemas (dailyLogSchema line 5, journalEntrySchema line 19, inventoryEntrySchema line 49, meetingSchema line 60, soberLivingSchema line 83, quoteSchema line 101, softDeleteJournalEntrySchema line 111, migrationDataSchema line 120) use z.object({}) without .strict(). Unknown fields pass through validation silently.","exploitation":"An attacker sends extra fields (e.g., {isAdmin: true, role: 'superuser'}) alongside valid data. If any Cloud Function handler uses spread operators to persist data, these fields could be written to Firestore. Current handlers destructure explicitly (mitigating this), but future code changes could introduce the vulnerability.","impact":"Low immediate risk due to explicit destructuring. Maintenance risk if future handlers use spread patterns on validated data.","affected_data":"All Cloud Function input data"},"remediation":{"steps":["1. Add .strict() to all schemas in functions/src/schemas.ts","2. Alternatively, use .strip() to silently remove unknown fields","3. Update any code that relies on passthrough behavior"],"code_example":"export const dailyLogSchema = z.object({\n  date: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/),\n  content: z.string().max(50000),\n  // ... other fields\n}).strict();","verification":["Send request with unknown field {extraField: 'test'} to saveDailyLog","Verify response is invalid-argument error (if .strict()) or field is stripped (if .strip())"]},"owasp_category":"A03","cvss_estimate":"LOW","evidence":["functions/src/schemas.ts:5: export const dailyLogSchema = z.object({  (no .strict())","functions/src/schemas.ts:19: export const journalEntrySchema = z.object({  (no .strict())","functions/src/schemas.ts:49: export const inventoryEntrySchema = z.object({  (no .strict())","functions/src/schemas.ts:60: export const meetingSchema = z.object({  (no .strict())"],"sources":[{"source":"claude-code","file":"security-claude-code.jsonl","original_fingerprint":"InputValidation::functions/src/schemas.ts::no_strict_mode"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0021","status":"CONFIRMED"}
{"category":"SecretsManagement","title":".env.production committed to git with Firebase config values","fingerprint":"SecretsManagement::.env.production::committed_config","severity":"S3","effort":"E1","confidence":95,"files":[".env.production"],"line":5,"vulnerability_details":{"description":".env.production is tracked in git (confirmed via git ls-files) and contains: NEXT_PUBLIC_FIREBASE_API_KEY, NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN, NEXT_PUBLIC_FIREBASE_PROJECT_ID, NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET, NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID, NEXT_PUBLIC_FIREBASE_APP_ID, NEXT_PUBLIC_FIREBASE_APPCHECK_RECAPTCHA_SITE_KEY, NEXT_PUBLIC_SENTRY_DSN. While these are all NEXT_PUBLIC_ (client-safe) values, the pattern of committing .env files to git normalizes a practice that can lead to accidental secret exposure.","exploitation":"Not directly exploitable. All committed values are designed for client-side exposure (Firebase API keys are restricted by Security Rules, not key secrecy). Risk is organizational: future developers might add actual secrets to this file.","impact":"Low. No actual secret exposure. Process/pattern risk only.","affected_data":"Firebase project configuration (public), reCAPTCHA site key (public), Sentry DSN (public)"},"remediation":{"steps":["1. Consider moving production config to CI/CD environment variables injected at build time","2. If keeping committed, add a prominent comment: '# WARNING: This file is committed to git. NEVER add actual secrets here.'","3. Add a pre-commit hook check that .env.production only contains NEXT_PUBLIC_ variables"],"verification":["Verify no non-NEXT_PUBLIC_ secrets exist in .env.production","Verify functions/.env contains no secrets"]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":[".env.production:5: NEXT_PUBLIC_FIREBASE_API_KEY=AIzaSyDGvM5kFwkgSTUS1Tbwt0piuhk9bcCeY7Q",".env.production:13: NEXT_PUBLIC_FIREBASE_APPCHECK_RECAPTCHA_SITE_KEY=6LdeazosAAAAAMDNCh1hTUDKh_UeS6xWY1-85B2O",".env.production:20: NEXT_PUBLIC_SENTRY_DSN=https://f585a8353ec50d104e5484fedca6c2f2@o4510530873589760.ingest.us.sentry.io/4510711416094720","git ls-files output includes: .env.production"],"notes":"Firebase API keys are public by design. Security is enforced by Firestore Security Rules and App Check, not by key secrecy.","sources":[{"source":"claude-code","file":"security-claude-code.jsonl","original_fingerprint":"SecretsManagement::.env.production::committed_config"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0022","status":"CONFIRMED"}
{"category":"Firebase","title":"migrateAnonymousUserData bypasses withSecurityChecks wrapper","fingerprint":"Firebase::functions/src/index.ts::migrate_manual_security","severity":"S3","effort":"E1","confidence":85,"files":["functions/src/index.ts"],"line":486,"vulnerability_details":{"description":"The migrateAnonymousUserData function (index.ts:486) implements manual auth, rate limiting, App Check, reCAPTCHA, and Zod validation instead of using the standardized withSecurityChecks wrapper used by all other user-facing functions. Critically, it makes reCAPTCHA optional (logs warning but continues without token at line 516-527) and has App Check verification commented out (lines 506-511).","exploitation":"An attacker can call migrateAnonymousUserData without a reCAPTCHA token and without App Check attestation. Combined with anonymous account creation, this could be used to repeatedly attempt data migration operations. Rate limiting (5 req/5min) still applies per-user.","impact":"Weaker bot protection on the migration endpoint compared to other endpoints. Migration is a sensitive operation that copies data between user accounts.","affected_data":"User migration data: journal entries, daily logs, inventory entries, profile data"},"remediation":{"steps":["1. Refactor migrateAnonymousUserData to use withSecurityChecks wrapper","2. Create a custom SecurityOptions configuration that handles the unique targetUid authorization logic","3. Ensure reCAPTCHA is required (not optional) for this sensitive operation","4. Re-enable App Check requirement"],"verification":["Send migration request without reCAPTCHA token, verify it is rejected","Verify function uses withSecurityChecks wrapper","Run existing migration tests to confirm no regressions"]},"owasp_category":"A04","cvss_estimate":"LOW","evidence":["functions/src/index.ts:486: export const migrateAnonymousUserData = onCall<MigrationData>(async (request) => {  // Manual checks, not withSecurityChecks","functions/src/index.ts:506-511: App Check verification block commented out","functions/src/index.ts:516-527: if (!token || token.trim() === '') { logSecurityEvent(...) // Continue without reCAPTCHA protection"],"sources":[{"source":"claude-code","file":"security-claude-code.jsonl","original_fingerprint":"Firebase::functions/src/index.ts::migrate_manual_security"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0023","status":"CONFIRMED"}
{"category":"Crypto","title":"Insecure Randomness in jobs.ts","fingerprint":"Crypto::functions/src/jobs.ts::math_random","severity":"S3","effort":"E1","confidence":100,"files":["functions/src/jobs.ts"],"vulnerability_details":{"description":"Math.random() used in security-sensitive context (storage path generation or similar).","exploitation":"Predictable random numbers can lead to collisions or guessing of tokens/paths.","impact":"Low (context dependent)","affected_data":"Storage paths"},"remediation":{"steps":["Use crypto.randomUUID() or crypto.getRandomValues()"],"verification":["Search for Math.random"]},"owasp_category":"A02","cvss_estimate":"LOW","evidence":["// SEC-REVIEW: Use cryptographically secure random bytes"],"line":354,"sources":[{"source":"jules","file":"security-jules.jsonl","original_fingerprint":"Crypto::functions/src/jobs.ts::math_random"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0024","status":"CONFIRMED"}
{"category":"Headers","title":"Content-Security-Policy header not configured","fingerprint":"Headers::firebase.json::csp_missing","severity":"S3","effort":"E1","confidence":100,"files":["firebase.json"],"line":1,"vulnerability_details":{"description":"The Content-Security-Policy (CSP) header is not configured in firebase.json.","exploitation":"XSS attacks could load external resources; no policy to restrict script/sources","impact":"Reduced XSS protection; attackers could load malicious resources","affected_data":"User session data, application data"},"remediation":{"steps":["Add CSP header to firebase.json","Test all app functionality still works","Use securityheaders.com to verify"],"code_example":"Add CSP header with appropriate directives for Firebase services","verification":["Verify CSP header present in response headers","Test all functionality works"]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":["firebase.json headers section missing Content-Security-Policy"],"notes":"CSP is a critical defense against XSS attacks","sources":[{"source":"kimi","file":"security-kimi.jsonl","original_fingerprint":"Headers::firebase.json::csp_missing"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0025","status":"CONFIRMED"}
{"category":"Headers","title":"Cross-Origin-Embedder-Policy not configured","fingerprint":"Headers::firebase.json::coep_missing","severity":"S3","effort":"E0","confidence":100,"files":["firebase.json"],"line":1,"vulnerability_details":{"description":"Cross-Origin-Embedder-Policy (COEP) header is not configured.","exploitation":"Certain cross-origin attacks may be possible without COEP","impact":"Reduced cross-origin attack protection","affected_data":"Minimal impact for this app architecture"},"remediation":{"steps":["Add COEP header to firebase.json","May need CORP header for Firebase resources"],"code_example":"Add Cross-Origin-Embedder-Policy: require-corp header","verification":["Verify header present in response headers"]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":["firebase.json headers section missing Cross-Origin-Embedder-Policy"],"notes":"Defense in depth - less critical for this app","sources":[{"source":"kimi","file":"security-kimi.jsonl","original_fingerprint":"Headers::firebase.json::coep_missing"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0026","status":"CONFIRMED"}
{"category":"InputValidation","title":"Journal/inventory data field accepts arbitrary nested objects","fingerprint":"InputValidation::functions/src/schemas.ts::flexible_data_field","severity":"S3","effort":"E2","confidence":35,"files":["functions/src/schemas.ts"],"line":32,"vulnerability_details":{"description":"journalEntrySchema (line 32) and inventoryEntrySchema (line 51) define data: z.record(z.string(), z.unknown()), allowing arbitrary nested object structures of unlimited depth and size. While the content string field has a 50KB limit, the data field has no size constraint.","exploitation":"An attacker could send deeply nested or very large objects in the data field, potentially causing Firestore write size limit errors or consuming excessive storage.","impact":"Potential for oversized Firestore documents. Firestore has a 1MB document size limit which provides a natural ceiling, but processing large payloads could impact function execution time.","affected_data":"Journal and inventory entry data"},"remediation":{"steps":["1. Add a JSON.stringify(data).length check in the Cloud Function handler before Firestore write","2. Consider adding per-type Zod schemas for the data field","3. Set a reasonable max like 100KB for the serialized data field"],"verification":["Send request with 500KB data object, verify it is rejected gracefully"]},"owasp_category":"A03","cvss_estimate":"LOW","evidence":["functions/src/schemas.ts:32: data: z.record(z.string(), z.unknown()),","functions/src/schemas.ts:51: data: z.record(z.string(), z.unknown()),"],"sources":[{"source":"claude-code-suspected","file":"security-claude-code-suspected.jsonl","original_fingerprint":"InputValidation::functions/src/schemas.ts::flexible_data_field"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0027","status":"SUSPECTED"}
{"category":"SecretsManagement","title":"functions/.env committed to git","fingerprint":"SecretsManagement::functions/.env::committed","severity":"S3","effort":"E0","confidence":30,"files":["functions/.env"],"line":1,"vulnerability_details":{"description":"functions/.env is tracked in git. Current contents are non-sensitive: SENTRY_ORG=sonash, SENTRY_PROJECT=javascript-nextjs, and a comment referencing AUTH_REST_API_KEY stored in GCP Secret Manager. No actual secrets are committed.","exploitation":"Not exploitable with current contents. The file explicitly documents that the actual API key is stored in GCP Secret Manager (line 9). Risk is future accidental addition of secrets.","impact":"None currently. Organizational risk only.","affected_data":"Sentry organization and project names (public information)"},"remediation":{"steps":["1. Consider renaming to functions/.env.example and adding functions/.env to .gitignore","2. Or add a comment header warning not to add secrets"],"verification":["Verify functions/.env contains no actual secret values"]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":["functions/.env:6: SENTRY_ORG=sonash","functions/.env:7: SENTRY_PROJECT=javascript-nextjs","functions/.env:9: # Firebase Web API Key - stored in GCP Secret Manager","git ls-files output includes: functions/.env"],"sources":[{"source":"claude-code-suspected","file":"security-claude-code-suspected.jsonl","original_fingerprint":"SecretsManagement::functions/.env::committed"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0028","status":"SUSPECTED"}
{"category":"Framework","title":"Client components access process.env directly","fingerprint":"Framework::components/providers/error-boundary.tsx::client-process-env","severity":"S3","effort":"E1","confidence":70,"files":["components/providers/error-boundary.tsx"],"vulnerability_details":{"description":"Client components reference process.env (NODE_ENV) directly, violating the stated framework boundary rule for client components.","exploitation":"May leak environment details or encourage additional unsafe env access in client code.","impact":"Low direct security impact but violates framework-specific security standard.","affected_data":"Client-side bundles."},"remediation":{"steps":["Replace direct process.env usage in client components with a compile-time flag or a shared config module that exposes only safe values.","Audit other client components for process.env usage and remove where possible."]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":["components/providers/error-boundary.tsx:1-3 use client component","components/providers/error-boundary.tsx:210-220 process.env.NODE_ENV usage"],"notes":"Standard explicitly disallows process.env in client components.","line":210,"sources":[{"source":"codex","file":"security-codex.jsonl","original_fingerprint":"Framework::components/providers/error-boundary.tsx::client-process-env"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0029","status":"SUSPECTED"}
{"category":"FileHandling","title":"Unused Storage Rules / Missing Client Upload","fingerprint":"FileHandling::storage.rules::missing_client","severity":"S3","effort":"E2","confidence":30,"files":["storage.rules","functions/src/jobs.ts"],"vulnerability_details":{"description":"Storage rules exist for 'users/{userId}' but jobs expect 'user-uploads/{userId}'. No client code found using Firebase Storage.","exploitation":"Confusion in storage paths can lead to misconfigured rules.","impact":"Potential data leakage or inability to use feature.","affected_data":"User uploads"},"remediation":{"steps":["Clarify storage requirements","Implement client upload or remove unused rules"],"verification":["Review architecture"]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":["Mismatch between rules and jobs"],"line":1,"sources":[{"source":"jules-suspected","file":"security-jules-suspected.jsonl","original_fingerprint":"FileHandling::storage.rules::missing_client"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0030","status":"SUSPECTED"}
