{"category":"Offline","title":"No service worker for offline shell","fingerprint":"engineering-productivity::public/sw.js::service-worker","severity":"S1","effort":"E2","confidence":90,"files":["public/sw.js","next.config.js","public/manifest.json"],"line":1,"why_it_matters":"Without a service worker, the app shell doesn't load offline. Users see a browser error page instead of the notebook interface. For a recovery tool where accessibility during crisis moments matters, this is a significant gap.","suggested_fix":"Create public/sw.js with Workbox for shell caching. Register in app/layout.tsx. Cache critical routes and static assets. Add offline.html fallback page.","acceptance_tests":["ls public/sw.js exists","navigator.serviceWorker.register called in app/layout.tsx","App loads offline with cached shell","Lighthouse PWA score includes registers a service worker"],"evidence":["ls public/sw.js returned MISSING","No service worker registration in app/layout.tsx","components/pwa/install-prompt.tsx suggests PWA intentions but no SW backing","ls public/sw.js → No such file","ls public/service-worker.js → No such file","grep -r 'serviceWorker' app/ → 0 matches","No next-pwa in package.json dependencies","PWA best practices: https://web.dev/offline-cookbook/","No service worker"],"sources":[{"source":"claude","file":"engineering-productivity-claude.jsonl","original_fingerprint":"engineering-productivity::public/sw.js::service-worker"},{"source":"claudecode","file":"engineering-productivity-claudecode.jsonl","original_fingerprint":"engineering-productivity::public/sw.js::missing-service-worker"},{"source":"codex","file":"engineering-productivity-codex.jsonl","original_fingerprint":"engineering-productivity::public/sw.js::missing-service-worker"}],"merged_from":["engineering-productivity::public/sw.js::service-worker","engineering-productivity::public/sw.js::missing-service-worker","engineering-productivity::public/sw.js::missing-service-worker"],"verified":true,"consensus_score":4,"canonical_id":"CANON-0001","status":"CONFIRMED"}
{"category":"Offline","title":"Firebase IndexedDB persistence not enabled","fingerprint":"engineering-productivity::lib/firebase.ts::persistence","severity":"S1","effort":"E1","confidence":88,"files":["lib/firebase.ts"],"line":1,"why_it_matters":"Without Firebase persistence, users lose all unsynced data when they close the app offline. The OfflineIndicator UI suggests offline support but no actual persistence layer exists. Critical for a recovery journal.","suggested_fix":"Import enableIndexedDbPersistence from firebase/firestore. Call after initializeFirestore(), wrapped in try/catch. Add NEXT_PUBLIC_ENABLE_PERSISTENCE env var for gradual rollout.","acceptance_tests":["grep enableIndexedDbPersistence lib/firebase.ts shows implementation","DevTools IndexedDB shows firestore cache","User can write offline, close browser, reopen - entry preserved"],"evidence":["grep -r enableIndexedDbPersistence lib/ returned no results","components/status/offline-indicator.tsx exists but no backing persistence layer","_db = getFirestore(_app);"],"sources":[{"source":"claude","file":"engineering-productivity-claude.jsonl","original_fingerprint":"engineering-productivity::lib/firebase.ts::persistence"},{"source":"codex","file":"engineering-productivity-codex.jsonl","original_fingerprint":"engineering-productivity::lib/firebase.ts::missing-indexeddb-persistence"}],"merged_from":["engineering-productivity::lib/firebase.ts::persistence","engineering-productivity::lib/firebase.ts::missing-indexeddb-persistence"],"verified":true,"consensus_score":3,"canonical_id":"CANON-0002","status":"CONFIRMED"}
{"category":"Offline","title":"Firebase IndexedDB persistence not enabled - no offline data support","fingerprint":"engineering-productivity::lib/firebase.ts::missing-offline-persistence","severity":"S1","effort":"E1","confidence":100,"files":["lib/firebase.ts"],"line":55,"why_it_matters":"Users lose all unsaved work when offline or with poor connectivity. Firebase SDK supports IndexedDB persistence for offline read/write caching, but it's not enabled. This is critical for a recovery journal where users may write in various connectivity conditions (subway, airplane, rural areas). Without persistence, data loss creates severe trust issues.","suggested_fix":"Add enableIndexedDbPersistence() or enableMultiTabIndexedDbPersistence() after Firestore initialization in lib/firebase.ts. Wrap in try-catch to handle scenarios where persistence is already enabled or unavailable (private browsing). Add UI indicator when offline mode is active. Consider implementing write queue for mutations made while offline.","acceptance_tests":["import { enableIndexedDbPersistence } from 'firebase/firestore' added","enableIndexedDbPersistence(_db).catch() added after line 55","Error handling for already-enabled and quota-exceeded cases","Test: Disconnect network, write journal entry, reconnect, verify sync","Test: Open two tabs, verify multi-tab persistence works","Documentation updated in DEVELOPMENT.md about offline capabilities"],"evidence":["grep -r 'enableIndexedDbPersistence' lib/ → 0 matches","grep -r 'enableMultiTabIndexedDbPersistence' lib/ → 0 matches","lib/firebase.ts:55 initializes Firestore but no persistence call","Firebase docs: https://firebase.google.com/docs/firestore/manage-data/enable-offline","lib/firebase.ts:55 — _db = getFirestore(_app) with no persistence call","No import of enableIndexedDbPersistence anywhere in lib/"],"sources":[{"source":"claudecode","file":"engineering-productivity-claudecode.jsonl","original_fingerprint":"engineering-productivity::lib/firebase.ts::missing-offline-persistence"},{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::lib/firebase.ts::no-persistence"}],"merged_from":["engineering-productivity::lib/firebase.ts::missing-offline-persistence","engineering-productivity::lib/firebase.ts::no-persistence"],"verified":true,"consensus_score":3,"canonical_id":"CANON-0003","status":"CONFIRMED"}
{"category":"GoldenPath","title":"DEVELOPMENT.md references npm script type-check that does not exist","fingerprint":"engineering-productivity::DEVELOPMENT.md::missing-npm-script-type-check","severity":"S1","effort":"E0","confidence":100,"files":["DEVELOPMENT.md","package.json"],"why_it_matters":"Onboarding instructions point to a command that fails immediately, creating trust erosion and wasted time during setup and troubleshooting.","suggested_fix":"Either add \"type-check\": \"tsc --noEmit\" to package.json or update DEVELOPMENT.md to reference the existing command (npx tsc --noEmit) consistently.","acceptance_tests":["npm run --list | grep type-check","npm run type-check (if added)"],"evidence":["DEVELOPMENT.md:848 - Check TypeScript errors: npm run type-check","package.json scripts: no type-check entry"],"line":848,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::DEVELOPMENT.md::missing-npm-script-type-check"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0004","status":"CONFIRMED"}
{"category":"Testing","title":"Tests require a compile step (tsc + tsc-alias) before running; slows local feedback and hooks","fingerprint":"engineering-productivity::package.json::tests-require-build-step","severity":"S1","effort":"E2","confidence":95,"files":["package.json","tsconfig.test.json"],"why_it_matters":"Requiring a build step before every test run increases iteration time and makes pre-commit slower, especially for small changes. Developers feel this daily.","suggested_fix":"Consider a faster test runner flow: (A) run Node tests directly on TS via tsx in dev, or (B) switch to a TS-native runner (Vitest) while keeping current build-based flow for CI if desired.","acceptance_tests":["Introduce npm run test:watch and confirm it runs in <5s startup","CI still runs a deterministic test command"],"evidence":["package.json:10-12 test requires test:build (tsc -p tsconfig.test.json && tsc-alias)"],"line":10,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::package.json::tests-require-build-step"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0005","status":"CONFIRMED"}
{"category":"Offline","title":"Offline UI promises changes will sync, but no service worker or Firestore persistence is enabled","fingerprint":"engineering-productivity::components/status/offline-indicator.tsx::offline-promise-no-infra","severity":"S1","effort":"E2","confidence":95,"files":["components/status/offline-indicator.tsx","public/manifest.json"],"why_it_matters":"Users/devs will assume offline writes are queued and safe. Without persistence/queue, offline edits can fail silently or be lost.","suggested_fix":"Either (A) implement real offline support (Firestore persistence + queued writes + conflict strategy), or (B) downgrade the messaging to a truthful indicator until infra exists.","acceptance_tests":["Confirm Firestore persistence call exists OR offline indicator text no longer claims sync","Add a basic offline write test plan in DEVELOPMENT.md"],"evidence":["components/status/offline-indicator.tsx:42-47 'Offline - changes will sync when reconnected'","No service worker found","No enableIndexedDbPersistence call found"],"line":46,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::components/status/offline-indicator.tsx::offline-promise-no-infra"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0006","status":"CONFIRMED"}
{"category":"Debugging","title":"No correlation ID system for distributed tracing","fingerprint":"engineering-productivity::lib/logger.ts::correlation-ids","severity":"S1","effort":"E2","confidence":100,"files":["lib/logger.ts","lib/firestore-service.ts"],"line":99,"why_it_matters":"Without correlation IDs, tracking a single user request across Cloud Functions, Firestore queries, and client-side operations is nearly impossible. Significantly increases MTTR for production incidents.","suggested_fix":"Add correlationId field to LogContext type. Create lib/correlation.ts with generateCorrelationId(). Pass correlationId to all httpsCallable functions. Update Firebase Functions to log correlationId.","acceptance_tests":["Logger interface includes correlationId in LogContext type","All Cloud Function calls include correlationId in payload","Sentry events include correlation_id tag","Can trace a single user action end-to-end using correlation ID"],"evidence":["grep -r correlationId lib/ returned 0 results","No X-Request-ID or similar tracing headers in secure-caller.ts"],"sources":[{"source":"claude","file":"engineering-productivity-claude.jsonl","original_fingerprint":"engineering-productivity::lib/logger.ts::correlation-ids"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0007","status":"CONFIRMED"}
{"category":"Offline","title":"No write queue for offline mutations","fingerprint":"engineering-productivity::lib/firestore-service.ts::offline-queue","severity":"S1","effort":"E3","confidence":90,"files":["lib/firestore-service.ts"],"line":223,"why_it_matters":"Firebase persistence only handles reads offline. Writes fail immediately when offline unless you implement a write queue. Users see changes will sync but writes are silently dropped. Could cause data loss in recovery journaling scenarios.","suggested_fix":"Create lib/offline-queue.ts with PendingWrite type and writeQueue using IndexedDB. Wrap all httpsCallable functions with queue-on-offline logic. On reconnection drain queue with exponential backoff.","acceptance_tests":["User can call saveDailyLog while offline","Write stored in IndexedDB offline-queue","On reconnection write is retried automatically","OfflineIndicator shows Syncing X changes during drain"],"evidence":["No queue references in lib/ related to offline writes","lib/firestore-service.ts:223 calls httpsCallable directly with no offline fallback"],"sources":[{"source":"claude","file":"engineering-productivity-claude.jsonl","original_fingerprint":"engineering-productivity::lib/firestore-service.ts::offline-queue"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0008","status":"CONFIRMED"}
{"category":"Testing","title":"Test coverage reporting broken - TypeScript compilation errors","fingerprint":"engineering-productivity::package.json::test-coverage","severity":"S1","effort":"E1","confidence":100,"files":["package.json","tsconfig.test.json"],"line":12,"why_it_matters":"npm run test:coverage fails with Cannot find type definition file for node. The coverage gate is completely broken. CI uploads empty coverage artifacts. Without working coverage reports, refactoring is risky.","suggested_fix":"Fix tsconfig.test.json: add node to types array. Verify test:build completes without errors. Run test:coverage and confirm c8 HTML report generates. Update CI to fail if coverage drops below threshold.","acceptance_tests":["npm run test:coverage completes without TypeScript errors","coverage/index.html generated with coverage metrics","CI shows coverage percentage in logs"],"evidence":["npm run test:coverage output: error TS2688: Cannot find type definition file for node","tsconfig.test.json likely missing @types/node reference"],"sources":[{"source":"claude","file":"engineering-productivity-claude.jsonl","original_fingerprint":"engineering-productivity::package.json::test-coverage"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0009","status":"CONFIRMED"}
{"category":"Offline","title":"No service worker — app cannot load at all when offline","fingerprint":"engineering-productivity::public/sw.js::no-service-worker","severity":"S1","effort":"E2","confidence":95,"files":["public/","next.config.mjs"],"why_it_matters":"Without a service worker, the app shows a blank page/browser error when offline. Users in poor-connectivity scenarios cannot access any functionality. PWA manifest exists but is incomplete without SW.","suggested_fix":"Implement service worker using next-pwa or workbox. Cache app shell, static assets, and runtime API responses.","acceptance_tests":["App loads cached shell when offline","Service worker registered and active","Network-first with cache fallback for APIs"],"evidence":["No public/sw.js file exists","manifest.json exists but no SW to activate it","components/pwa/install-prompt.tsx exists but is non-functional without SW"],"line":1,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::public/sw.js::no-service-worker"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0010","status":"CONFIRMED"}
{"category":"Offline","title":"No offline write queue — journal writes fail silently when offline","fingerprint":"engineering-productivity::hooks/use-journal.ts::no-offline-queue","severity":"S1","effort":"E3","confidence":90,"files":["hooks/use-journal.ts"],"why_it_matters":"Journal writes via httpsCallable fail immediately when offline with no queue or retry. For a recovery app where users may journal during meetings, this means DATA LOSS with no warning or recovery mechanism.","suggested_fix":"Implement IndexedDB-based write queue: queue writes locally when offline, sync on reconnection, handle conflicts.","acceptance_tests":["Writes queued when offline","Writes synced automatically on reconnection","User sees pending write indicator"],"evidence":["hooks/use-journal.ts calls httpsCallable directly with no offline handling","No offlineQueue/writeQueue/pendingWrites code exists in app"],"line":319,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::hooks/use-journal.ts::no-offline-queue"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0011","status":"CONFIRMED"}
{"category":"Debugging","title":"No correlation IDs for frontend-to-backend request tracing","fingerprint":"engineering-productivity::lib/logger.ts::no-correlation-ids","severity":"S1","effort":"E2","confidence":100,"files":["lib/logger.ts","lib/firestore-service.ts"],"why_it_matters":"Cannot trace a user's journey from frontend click through Cloud Function execution to Sentry error. Engineers must manually correlate timestamps — extremely time-consuming.","suggested_fix":"Generate UUID per request on client, pass as metadata to Cloud Functions, include in all logger.error/warn calls. Add correlationId to LogContext type.","acceptance_tests":["Each client request generates unique correlation ID","Cloud Function logs include correlation ID","Sentry events contain correlation ID in extra context"],"evidence":["lib/logger.ts has no correlationId field or generation","grep correlationId|requestId|traceId returns no app code matches"],"line":3,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::lib/logger.ts::no-correlation-ids"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0012","status":"CONFIRMED"}
{"category":"Engineering","title":"App Check has been disabled since December 2025 — security gap","fingerprint":"engineering-productivity::lib/firebase.ts::app-check-disabled","severity":"S1","effort":"E1","confidence":100,"files":["lib/firebase.ts"],"why_it_matters":"App Check (reCAPTCHA Enterprise bot protection) has been commented out since December 2025. Without App Check, Cloud Functions are unprotected from unauthorized API calls and bot abuse.","suggested_fix":"Re-enable App Check in lib/firebase.ts. If throttle issues persist, implement App Check in debug mode for development with proper production configuration.","acceptance_tests":["App Check initialized in production","Debug mode works in development","Cloud Functions protected from unauthorized calls"],"evidence":["lib/firebase.ts:57-90 — entire App Check block commented out","Comment says will re-enable after throttle clears (Dec 31) — 38 days overdue"],"line":57,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::lib/firebase.ts::app-check-disabled"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0013","status":"CONFIRMED"}
{"category":"Offline","title":"Firestore offline persistence disabled","fingerprint":"engineering-productivity::lib/firebase.ts::missing-persistence","severity":"S1","effort":"E1","confidence":100,"files":["lib/firebase.ts"],"why_it_matters":"Users lose access to their journal data immediately upon network loss, which is critical for a recovery support application.","suggested_fix":"Enable offline persistence in Firestore initialization using enableIndexedDbPersistence() or enableMultiTabIndexedDbPersistence().","acceptance_tests":["Load app, disconnect network, verify data is still accessible."],"evidence":["lib/firebase.ts initializes Firestore with getFirestore() but does not call enableIndexedDbPersistence()"],"line":43,"sources":[{"source":"jules","file":"engineering-productivity-jules.jsonl","original_fingerprint":"engineering-productivity::lib/firebase.ts::missing-persistence"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0014","status":"CONFIRMED"}
{"category":"Testing","title":"Playwright installed but not configured","fingerprint":"engineering-productivity::package.json::unused-playwright","severity":"S1","effort":"E2","confidence":100,"files":["package.json"],"why_it_matters":"End-to-end tests are critical for verifying user flows, but the tooling is installed without configuration or tests, leaving a coverage gap.","suggested_fix":"Create playwright.config.ts and add initial E2E tests for critical paths (e.g., login, journal entry).","acceptance_tests":["Run npx playwright test and verify it executes tests."],"evidence":["package.json has @playwright/test","No playwright.config.ts found","No e2e/ directory found"],"line":1,"sources":[{"source":"jules","file":"engineering-productivity-jules.jsonl","original_fingerprint":"engineering-productivity::package.json::unused-playwright"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0015","status":"CONFIRMED"}
{"category":"Testing","title":"E2E tests missing despite Playwright installation","fingerprint":"engineering-productivity::tests/e2e::missing-tests","severity":"S1","effort":"E2","confidence":85,"files":["tests/e2e"],"line":1,"why_it_matters":"Playwright is installed but zero E2E tests exist. Unit tests alone miss critical integration bugs like OAuth redirect failures or App Check misconfigurations. 477 unit test cases but can't catch integration issues.","suggested_fix":"Create tests/e2e/ directory with playwright.config.ts. Write critical path tests for auth flow, journal entry CRUD, and offline sync. Add npm run test:e2e script. Run in CI with Firebase emulators.","acceptance_tests":["tests/e2e/ contains 3+ .spec.ts files","npm run test:e2e passes locally","CI runs E2E tests in separate job after build"],"evidence":["find . -name '*.spec.ts' returned 0 test files","package.json:115 includes @playwright/test:^1.58.1","No playwright.config.ts in root or tests/"],"sources":[{"source":"claude","file":"engineering-productivity-claude.jsonl","original_fingerprint":"engineering-productivity::tests/e2e::missing-tests"}],"verified":false,"consensus_score":1.5,"canonical_id":"CANON-0016","status":"SUSPECTED"}
{"category":"GoldenPath","title":"Missing .env.example file - critical onboarding blocker","fingerprint":"engineering-productivity::.env.example::missing-file","severity":"S1","effort":"E0","confidence":85,"files":[".env.example"],"line":1,"why_it_matters":"New developers cannot start the project without Firebase credentials. DEVELOPMENT.md documents required environment variables but no .env.example template exists. This forces developers to manually copy/paste from documentation, increasing setup friction and error probability. Critical for golden path onboarding.","suggested_fix":"Create .env.example file with all required Firebase environment variables as placeholders. Include comments explaining where to get each value (Firebase Console → Project Settings → Your Apps). Add validation in lib/firebase.ts already handles missing vars with clear error messages.","acceptance_tests":["File .env.example exists in repository root","Contains all 6 Firebase variables (NEXT_PUBLIC_FIREBASE_API_KEY, AUTH_DOMAIN, PROJECT_ID, STORAGE_BUCKET, MESSAGING_SENDER_ID, APP_ID)","Contains App Check variable (NEXT_PUBLIC_FIREBASE_APPCHECK_RECAPTCHA_SITE_KEY)","Contains Sentry variables (NEXT_PUBLIC_SENTRY_DSN, NEXT_PUBLIC_SENTRY_ENABLED)","Has comments explaining where to get values","New developer can cp .env.example .env.local and fill in values"],"evidence":["cat .env.example → No such file","DEVELOPMENT.md lines 50-72 documents required env vars but no template","lib/firebase.ts:8-13 has validateEnv() that throws clear errors for missing vars"],"sources":[{"source":"claudecode","file":"engineering-productivity-claudecode.jsonl","original_fingerprint":"engineering-productivity::.env.example::missing-file"}],"verified":false,"consensus_score":1.5,"canonical_id":"CANON-0017","status":"SUSPECTED"}
{"category":"Debugging","title":"Logger is present but lacks correlation/request IDs; tracing across async flows is difficult","fingerprint":"engineering-productivity::lib/logger.ts::missing-correlation-ids","severity":"S2","effort":"E2","confidence":90,"files":["lib/logger.ts","components/providers/error-boundary.tsx","lib/firestore-service.ts"],"why_it_matters":"Without a correlation ID, it's hard to connect logs from UI actions, cloud function calls, and error boundaries into a single timeline.","suggested_fix":"Add optional requestId/correlationId to logger context and propagate it through: UI action → secure-caller → callable payload.","acceptance_tests":["grep -R 'correlationId|x-request-id' shows new implementation points","A single user action emits multiple logs sharing the same correlationId"],"evidence":["lib/logger.ts:99-106 payload has no request/correlation id field","repo-wide search for correlationId: no matches","grep -r 'correlationId' lib/ app/ components/ → 10 matches (scattered)","lib/logger.ts doesn't enforce correlationId parameter","lib/firestore-service.ts Cloud Function calls don't include request context","Sentry initialization doesn't configure correlationId as tag"],"line":99,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::lib/logger.ts::missing-correlation-ids"},{"source":"claudecode","file":"engineering-productivity-claudecode.jsonl","original_fingerprint":"engineering-productivity::lib/logger.ts::missing-correlation-ids"}],"merged_from":["engineering-productivity::lib/logger.ts::missing-correlation-ids","engineering-productivity::lib/logger.ts::missing-correlation-ids"],"verified":true,"consensus_score":3,"canonical_id":"CANON-0018","status":"CONFIRMED"}
{"category":"Debugging","title":"Logger payload lacks correlation/request IDs","fingerprint":"engineering-productivity::lib/logger.ts::missing-correlation-id","severity":"S2","effort":"E2","confidence":85,"files":["lib/logger.ts"],"why_it_matters":"Without correlation IDs, it is harder to trace requests across client/server and link logs to specific user actions.","suggested_fix":"Add a correlationId field to the logger payload, generate per request/session, and propagate via context helpers.","acceptance_tests":["Logger payload includes correlationId when provided in context","Spot-check log entries for correlationId presence"],"evidence":["const payload: Record<string, unknown> = { level, message, timestamp, environment, ...(context ? { context: sanitizeContext(context) } : {}) };","lib/logger.ts does not import or use AsyncLocalStorage","grep for correlationId returns no results"],"line":99,"sources":[{"source":"codex","file":"engineering-productivity-codex.jsonl","original_fingerprint":"engineering-productivity::lib/logger.ts::missing-correlation-id"},{"source":"jules","file":"engineering-productivity-jules.jsonl","original_fingerprint":"engineering-productivity::lib/logger.ts::missing-correlation-id"}],"merged_from":["engineering-productivity::lib/logger.ts::missing-correlation-id","engineering-productivity::lib/logger.ts::missing-correlation-id"],"verified":true,"consensus_score":3,"canonical_id":"CANON-0019","status":"CONFIRMED"}
{"category":"GoldenPath","title":"Install/build can fail due to missing local file dependency (@dataconnect/generated)","fingerprint":"engineering-productivity::package.json::missing-local-file-dependency","severity":"S0","effort":"E1","confidence":95,"files":["package.json","DOCUMENTATION_INDEX.md"],"why_it_matters":"A fresh clone may fail npm ci because a dependency points at a missing local folder. This blocks onboarding and makes CI brittle.","suggested_fix":"Decide the source of truth for src/dataconnect-generated: (A) commit it, (B) generate it deterministically in a preinstall/prepare step + CI, or (C) remove/replace the dependency with a published package.","acceptance_tests":["rm -rf node_modules && npm ci","npm run build","npm run test:coverage"],"evidence":["package.json:76 \"@dataconnect/generated\": \"file:src/dataconnect-generated\"","repo filesystem check: MISSING","DOCUMENTATION_INDEX.md:464+ links to src/dataconnect-generated/* that do not exist"],"line":76,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::package.json::missing-local-file-dependency"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0020","status":"CONFIRMED"}
{"category":"GoldenPath","title":"README lacks runnable Quick Start commands (no npm ci/dev/test instructions)","fingerprint":"engineering-productivity::README.md::missing-quick-start-commands","severity":"S2","effort":"E0","confidence":90,"files":["README.md","DEVELOPMENT.md"],"why_it_matters":"New contributors expect the README to get them to a running app fast. When Quick Start is not actionable, setup time increases and people bounce to other docs or guess.","suggested_fix":"Add a minimal Quick Start block to README: npm ci, copy .env.local.example → .env.local, npm run dev, and the fastest test command. Link to DEVELOPMENT.md for deeper setup.","acceptance_tests":["grep -n 'npm ci|npm run dev|npm test' README.md returns matches","Fresh clone: follow README only to start dev server"],"evidence":["README.md has a Quick Start bullet but no commands present"],"line":1,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::README.md::missing-quick-start-commands"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0021","status":"CONFIRMED"}
{"category":"Testing","title":"Repo context expects Jest but project uses Node's built-in test runner; tooling expectation mismatch","fingerprint":"engineering-productivity::package.json::jest-mismatch","severity":"S2","effort":"E0","confidence":90,"files":["package.json",".github/workflows/ci.yml"],"why_it_matters":"When teams assume Jest, they look for jest.config.* and Jest CLI flags. Mismatch causes confusion and slows debugging test failures.","suggested_fix":"Update DEVELOPMENT.md/README to explicitly state the test runner (node --test) and how to run focused tests.","acceptance_tests":["Docs clearly state runner and show a run one test file command","New contributors can run a single test without reading scripts"],"evidence":["package.json uses node --test (no jest dependency)"],"line":10,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::package.json::jest-mismatch"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0022","status":"CONFIRMED"}
{"category":"Debugging","title":"Console.log used in production paths (firestore-service, TodayPage) instead of logger with levels","fingerprint":"engineering-productivity::lib/firestore-service.ts::console-log-in-prod-paths","severity":"S2","effort":"E1","confidence":95,"files":["lib/firestore-service.ts","components/notebook/pages/today-page.tsx"],"why_it_matters":"Ad-hoc console logging is noisy, inconsistent, and hard to filter. It also risks leaking data and makes debugging harder because logs aren't normalized.","suggested_fix":"Replace non-example console logs with logger.debug/info. Add a single debug flag mechanism (env var) to enable verbose logs locally.","acceptance_tests":["grep -R 'console.log' app lib components returns only examples/docs or zero","Run a key flow and confirm logs are structured and level-controlled"],"evidence":["lib/firestore-service.ts:229 console.log sending to Cloud Function","components/notebook/pages/today-page.tsx:728+ console.log Weekly Stats Debug"],"line":229,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::lib/firestore-service.ts::console-log-in-prod-paths"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0023","status":"CONFIRMED"}
{"category":"Offline","title":"PWA install prompt exists but no service worker; offline shell likely incomplete","fingerprint":"engineering-productivity::components/pwa/install-prompt.tsx::pwa-without-sw","severity":"S2","effort":"E2","confidence":85,"files":["components/pwa/install-prompt.tsx","public/manifest.json"],"why_it_matters":"Developers will expect PWA install + offline shell to work together. Having install UX without the offline plumbing causes confusing QA and user-reported bugs.","suggested_fix":"Add a service worker strategy or clearly scope the feature as install-only until SW is implemented.","acceptance_tests":["public/sw.js exists and is registered OR docs/UX clearly state install-only","Manual: go offline and confirm app shell loads"],"evidence":["components/pwa/install-prompt.tsx includes offline install messaging","public contains manifest.json but no sw.js"],"line":104,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::components/pwa/install-prompt.tsx::pwa-without-sw"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0024","status":"CONFIRMED"}
{"category":"CI_CD","title":"CI is a single large job (lint+format+deps+tests+validations); missed parallelization opportunities","fingerprint":"engineering-productivity::.github/workflows/ci.yml::single-job-bottleneck","severity":"S2","effort":"E2","confidence":90,"files":[".github/workflows/ci.yml"],"why_it_matters":"When everything runs serially, CI latency increases and developers wait longer for feedback. Splitting independent steps into parallel jobs can materially improve throughput.","suggested_fix":"Split CI into parallel jobs: (1) lint/format/patterns, (2) typecheck, (3) tests+coverage, (4) docs/schema validations. Use needs/outputs to keep gating behavior.","acceptance_tests":["CI completes faster on typical PRs","All required checks still gate merges appropriately"],"evidence":[".github/workflows/ci.yml:8-16 only one job defined: lint-typecheck-test"],"line":8,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::.github/workflows/ci.yml::single-job-bottleneck"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0025","status":"CONFIRMED"}
{"category":"Engineering","title":"No single golden path command that mirrors CI gates (missing npm run check)","fingerprint":"engineering-productivity::package.json::missing-unified-check-command","severity":"S2","effort":"E0","confidence":95,"files":["package.json"],"why_it_matters":"Developers shouldn't have to remember many separate commands to match CI. A single local command reduces mistakes and speeds up pre-PR confidence checks.","suggested_fix":"Add npm run check that runs the same core gates as CI in a sensible order (lint → format:check → patterns:check → typecheck → test).","acceptance_tests":["npm run check exits 0 on clean tree","npm run check fails when lint/test/typecheck fails"],"evidence":["package.json includes many *:check scripts but none named check"],"line":1,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::package.json::missing-unified-check-command"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0026","status":"CONFIRMED"}
{"category":"Debugging","title":"46 console.log statements remain in production code","fingerprint":"engineering-productivity::lib/firestore-service.ts::console-logging","severity":"S2","effort":"E1","confidence":100,"files":["lib/firestore-service.ts","components/notebook/pages/today-page.tsx","lib/hooks/use-tab-refresh.ts","lib/utils/secure-caller.ts"],"line":62,"why_it_matters":"Console.log statements clutter production logs, lack structured context for debugging, and can leak sensitive data. The project has a structured logger but 77.5% adoption means 46 instances remain.","suggested_fix":"Run a codebase-wide migration replacing console.* with logger.* calls. Update eslint config to error on console.* usage except in scripts/.","acceptance_tests":["grep -r 'console.' lib/ components/ app/ --include='*.ts' --include='*.tsx' returns 0 results","npm run lint passes with no console.* warnings","All logger.* calls include structured context objects"],"evidence":["lib/firestore-service.ts:62: console.error()","lib/firestore-service.ts:229: console.log() with sanitized payload","components/notebook/pages/today-page.tsx:613-807: 12 console.log statements"],"sources":[{"source":"claude","file":"engineering-productivity-claude.jsonl","original_fingerprint":"engineering-productivity::lib/firestore-service.ts::console-logging"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0027","status":"CONFIRMED"}
{"category":"Offline","title":"No conflict resolution strategy","fingerprint":"engineering-productivity::lib/firestore-service.ts::conflicts","severity":"S2","effort":"E2","confidence":85,"files":["lib/firestore-service.ts"],"line":1,"why_it_matters":"If a user edits a journal entry on mobile offline then on desktop, the last write wins with no merge strategy. For recovery journals with timestamps, moods, and notes, losing data due to silent conflicts is unacceptable.","suggested_fix":"Add version field to all documents. In Cloud Functions check version on merge and return ConflictError if stale. Implement last-write-wins for mood but append-only for notes.","acceptance_tests":["Edit journal entry offline on device A","Edit same entry offline on device B","Both reconnect - user sees merge conflict UI","Merged result preserves all notes and latest mood"],"evidence":["No conflict resolution logic in lib/firestore-service.ts","No version fields in Firestore writes"],"sources":[{"source":"claude","file":"engineering-productivity-claude.jsonl","original_fingerprint":"engineering-productivity::lib/firestore-service.ts::conflicts"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0028","status":"CONFIRMED"}
{"category":"CI_CD","title":"No incremental builds configured for CI","fingerprint":"engineering-productivity::.github/workflows/ci.yml::incremental-builds","severity":"S2","effort":"E1","confidence":95,"files":[".github/workflows/ci.yml"],"line":151,"why_it_matters":"Every CI build recompiles the entire Next.js app from scratch. Next.js Remote Caching or Turborepo could cut build times by 50-70%. With 10 CI workflows this compounds into 15-20 minutes of redundant compilation per PR.","suggested_fix":"Add actions/cache step for .next/cache in ci.yml. Consider Vercel Remote Caching or self-hosted Turborepo cache. Measure build time before/after.","acceptance_tests":["CI build job shows Cache restored from key in logs","Second build on same branch completes 50%+ faster","Cache hit rate tracked in CI logs"],"evidence":[".github/workflows/ci.yml:151 runs npm run build with no caching","No .next/cache in actions/cache configuration"],"sources":[{"source":"claude","file":"engineering-productivity-claude.jsonl","original_fingerprint":"engineering-productivity::.github/workflows/ci.yml::incremental-builds"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0029","status":"CONFIRMED"}
{"category":"Testing","title":"Test build overhead slows feedback loop","fingerprint":"engineering-productivity::package.json::test-build","severity":"S2","effort":"E2","confidence":90,"files":["package.json"],"line":11,"why_it_matters":"Every test run requires tsc + tsc-alias compilation step adding ~10-30s overhead. For TDD workflows this breaks the fast feedback loop. Node native test runner supports TS directly via tsx making compile step potentially unnecessary.","suggested_fix":"Replace node --test with tsx --test to run tests directly from TypeScript. Remove test:build script or make it optional. Install tsx (already present at line 145).","acceptance_tests":["npm test completes in <30s for all unit tests","No tsc compilation step before test execution","All 477 test cases pass with tsx"],"evidence":["package.json:11 requires npm run test:build before every test run","test:build runs tsc + tsc-alias which compiles entire test suite"],"sources":[{"source":"claude","file":"engineering-productivity-claude.jsonl","original_fingerprint":"engineering-productivity::package.json::test-build"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0030","status":"CONFIRMED"}
{"category":"GoldenPath","title":"No automated setup script - manual 5-step installation process","fingerprint":"engineering-productivity::scripts/setup.js::missing-setup-script","severity":"S2","effort":"E1","confidence":100,"files":["scripts/setup.js","package.json"],"line":1,"why_it_matters":"New developers must manually run 5 commands to set up the project (clone, npm install, cd functions && npm install, create .env.local, copy values). This increases onboarding time from <2 minutes to 10-15 minutes and introduces error probability. Standard practice is 'npm run setup' that automates all steps. Missing setup script violates golden path principle.","suggested_fix":"Create scripts/setup.js that: (1) Checks Node.js version (>=18), (2) Runs npm install in root, (3) Runs npm install in functions/, (4) Checks for .env.local, creates from .env.example if missing, (5) Validates required environment variables or provides interactive prompts, (6) Runs npm run test:build to verify setup, (7) Prints success message with next steps. Add 'setup' script to package.json.","acceptance_tests":["scripts/setup.js exists and is executable","package.json has 'setup': 'node scripts/setup.js'","Script checks Node.js version and exits with clear error if wrong version","Script installs dependencies in root and functions/","Script creates .env.local from .env.example if missing","Script validates or prompts for Firebase credentials","Script runs test build to verify setup","New developer can run: npm run setup and be ready to code","Documentation updated: README.md shows 'npm run setup' as step 1"],"evidence":["ls scripts/ | grep -E 'setup|install|init' → 0 matches","DEVELOPMENT.md lines 40-47 shows 5 manual steps","No 'setup' script in package.json","Similar projects use setup scripts: create-react-app, Next.js, etc."],"sources":[{"source":"claudecode","file":"engineering-productivity-claudecode.jsonl","original_fingerprint":"engineering-productivity::scripts/setup.js::missing-setup-script"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0031","status":"CONFIRMED"}
{"category":"GoldenPath","title":".env.example missing for onboarding","fingerprint":"engineering-productivity::.env.example::missing-env-template","severity":"S2","effort":"E1","confidence":85,"files":[".env.example","DEVELOPMENT.md"],"why_it_matters":"New contributors must manually copy env vars from docs into .env.local, which is error-prone and slows onboarding.","suggested_fix":"Add a root .env.example that mirrors the required variables in DEVELOPMENT.md (with safe placeholder values).","acceptance_tests":["Verify .env.example exists in repo root","Compare .env.example keys to DEVELOPMENT.md env list"],"evidence":["No .env.example"],"line":1,"sources":[{"source":"codex","file":"engineering-productivity-codex.jsonl","original_fingerprint":"engineering-productivity::.env.example::missing-env-template"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0032","status":"CONFIRMED"}
{"category":"Debugging","title":"Debug console.log statements left in Today page","fingerprint":"engineering-productivity::components/notebook/pages/today-page.tsx::debug-console-log","severity":"S2","effort":"E1","confidence":90,"files":["components/notebook/pages/today-page.tsx"],"why_it_matters":"Ad-hoc console logging makes debugging noisy and inconsistent with structured logging, slowing down troubleshooting and signal-to-noise.","suggested_fix":"Replace console.log/console.error blocks with logger.* calls (or remove debug-only logs) and keep a consistent structured payload.","acceptance_tests":["rg -n 'console.log' components/notebook/pages/today-page.tsx returns 0","Logger emits expected context fields for save/debug paths"],"evidence":["if (process.env.NODE_ENV === 'development') { console.log('Attempting to save:', saveData); }"],"line":612,"sources":[{"source":"codex","file":"engineering-productivity-codex.jsonl","original_fingerprint":"engineering-productivity::components/notebook/pages/today-page.tsx::debug-console-log"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0033","status":"CONFIRMED"}
{"category":"Offline","title":"OfflineIndicator displays misleading changes will sync message","fingerprint":"engineering-productivity::components/status/offline-indicator.tsx::misleading-sync-message","severity":"S2","effort":"E0","confidence":95,"files":["components/status/offline-indicator.tsx"],"why_it_matters":"The OfflineIndicator tells users changes will sync when reconnected but no sync mechanism exists. This creates false trust and masks data loss.","suggested_fix":"Change message to 'Some features may be unavailable while offline' until a sync queue is implemented.","acceptance_tests":["Offline message accurately reflects capabilities","No mention of sync without sync mechanism"],"evidence":["offline-indicator.tsx misleading message confirmed","No sync queue exists to fulfill the promise"],"line":11,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::components/status/offline-indicator.tsx::misleading-sync-message"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0034","status":"CONFIRMED"}
{"category":"GoldenPath","title":"No single npm run setup bootstrap command","fingerprint":"engineering-productivity::package.json::no-setup-script","severity":"S2","effort":"E0","confidence":100,"files":["package.json"],"why_it_matters":"New developers must run 3+ manual steps: npm install, cd functions && npm install, create .env.local, firebase login. A single setup command would reduce onboarding time from ~10 min to ~2 min.","suggested_fix":"Add setup script to package.json that installs all dependencies and prints next steps for env vars.","acceptance_tests":["npm run setup installs all dependencies","Setup script prints next steps for env vars","New clone to running app in <5 min"],"evidence":["package.json:5-71 has 66 scripts but no setup","DEVELOPMENT.md:40-47 shows multi-step manual process"],"line":5,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::package.json::no-setup-script"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0035","status":"CONFIRMED"}
{"category":"GoldenPath","title":"No .env.example or .env.local.example file","fingerprint":"engineering-productivity::root::no-env-example","severity":"S2","effort":"E0","confidence":100,"files":["DEVELOPMENT.md"],"why_it_matters":"Environment variables are documented inline in DEVELOPMENT.md but there's no .env.example file to copy. Developers must manually find and copy env var names.","suggested_fix":"Create .env.local.example in project root with all required vars, documented comments, and optional vars clearly marked.","acceptance_tests":[".env.local.example exists with all required vars","cp .env.local.example .env.local works","All NEXT_PUBLIC_FIREBASE_* vars present"],"evidence":["No .env.example or .env.local.example file in root","DEVELOPMENT.md:52-72 documents vars inline"],"line":52,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::root::no-env-example"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0036","status":"CONFIRMED"}
{"category":"GoldenPath","title":"No environment validation/doctor script","fingerprint":"engineering-productivity::scripts/::no-doctor-script","severity":"S2","effort":"E1","confidence":100,"files":["scripts/","package.json"],"why_it_matters":"No automated way to verify development environment is correctly configured. Developers discover issues only when things fail.","suggested_fix":"Create scripts/doctor.js that checks: Node 22+, Firebase CLI installed, .env.local exists with required vars, functions/node_modules exists, functions/lib/ built.","acceptance_tests":["npm run doctor reports all prerequisites","Clear error messages for missing items","Exit code 1 if any check fails"],"evidence":["No scripts/doctor.js in scripts/ directory","package.json has no doctor script"],"line":1,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::scripts/::no-doctor-script"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0037","status":"CONFIRMED"}
{"category":"Debugging","title":"8:1 console.log to logger ratio — production observability gap","fingerprint":"engineering-productivity::app/::console-log-ratio","severity":"S2","effort":"E2","confidence":90,"files":["app/","lib/","components/"],"why_it_matters":"~3111 console.log calls vs ~394 logger calls means most production errors are invisible to Sentry. Console.log output is not redacted for PII, not structured, and not captured by monitoring.","suggested_fix":"Add ESLint rule no-console (warn level) to flag new console.log additions. Prioritize converting console.log in error paths to logger.error.","acceptance_tests":["ESLint warns on new console.log","Critical error paths use logger.error","Ratio improves to <4:1"],"evidence":["Prior audit: 3111 console.log vs 394 logger calls","lib/logger.ts exists but is underutilized"],"line":1,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::app/::console-log-ratio"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0038","status":"CONFIRMED"}
{"category":"CI_CD","title":"CI npm install runs twice — no dependency caching between jobs","fingerprint":"engineering-productivity::.github/workflows/ci.yml::duplicate-npm-ci","severity":"S2","effort":"E1","confidence":95,"files":[".github/workflows/ci.yml"],"why_it_matters":"The build job runs npm ci again after lint-typecheck-test already installed. npm cache helps but full install still takes time. Using artifacts or shared cache would save 1-2 minutes per run.","suggested_fix":"Use actions/cache or upload-artifact to share node_modules between jobs, or merge jobs since they are already sequential.","acceptance_tests":["Build job reuses dependencies from test job OR jobs are merged","CI total time reduced by 1-2 minutes"],"evidence":["ci.yml:24 npm ci in test job","ci.yml:149 npm ci in build job","Both use cache: npm but still run full install"],"line":133,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::.github/workflows/ci.yml::duplicate-npm-ci"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0039","status":"CONFIRMED"}
{"category":"Testing","title":"Playwright E2E tests configured but no test files exist","fingerprint":"engineering-productivity::package.json::phantom-e2e","severity":"S2","effort":"E2","confidence":85,"files":["package.json"],"why_it_matters":"@playwright/test is in devDependencies but no E2E test files are visible. This is dead dependency weight and a gap in test coverage for critical user flows.","suggested_fix":"Add basic E2E tests for critical flows (login, create journal entry, search meetings), or remove @playwright/test from devDependencies if E2E is not planned.","acceptance_tests":["E2E tests exist for at least 3 critical flows OR Playwright removed","E2E tests run in CI (if added)"],"evidence":["package.json:115 — @playwright/test: ^1.58.1","No .spec.ts or .e2e.ts files found"],"line":115,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::package.json::phantom-e2e"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0040","status":"CONFIRMED"}
{"category":"Testing","title":"Test compilation required before running — slow feedback loop","fingerprint":"engineering-productivity::package.json::test-build-step","severity":"S2","effort":"E1","confidence":90,"files":["package.json","tsconfig.test.json"],"why_it_matters":"Tests require tsc compilation step before running, adding 10-30 seconds to every test run. This slows the red-green-refactor cycle and discourages frequent testing.","suggested_fix":"Consider using tsx or ts-node/esm for direct TypeScript test execution, or use Node --experimental-strip-types flag (Node 22+). Alternatively cache compiled tests.","acceptance_tests":["npm test starts running tests within 5 seconds","No manual compilation step needed","Tests still type-check correctly"],"evidence":["package.json:10 — test script requires test:build first","package.json:11 — test:build runs tsc + tsc-alias"],"line":10,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::package.json::test-build-step"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0041","status":"CONFIRMED"}
{"category":"CI_CD","title":"Serial execution of CI jobs","fingerprint":"engineering-productivity::.github/workflows/ci.yml::serial-jobs","severity":"S2","effort":"E2","confidence":100,"files":[".github/workflows/ci.yml"],"why_it_matters":"Running linting, type checking, and testing sequentially in a single job slows down feedback loops for developers.","suggested_fix":"Split lint-typecheck-test into parallel jobs or use matrix strategy for tests to reduce total runtime.","acceptance_tests":["Verify CI pipeline runs stages in parallel where possible."],"evidence":["ci.yml lint-typecheck-test job runs steps sequentially"],"line":11,"sources":[{"source":"jules","file":"engineering-productivity-jules.jsonl","original_fingerprint":"engineering-productivity::.github/workflows/ci.yml::serial-jobs"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0042","status":"CONFIRMED"}
{"category":"CI_CD","title":"CI runtime may exceed 10 minutes for typical PRs due to serial job + coverage build step","fingerprint":"engineering-productivity::.github/workflows/ci.yml::ci-runtime-unknown","severity":"S2","effort":"E2","confidence":35,"files":[".github/workflows/ci.yml","package.json"],"why_it_matters":"If CI routinely runs long, developers batch changes and context-switch, which reduces velocity. Without measurements, this is a hypothesis.","suggested_fix":"Measure average CI duration on last 20 PRs, then apply the parallelization + test speedups if needed.","acceptance_tests":["Export CI timing metrics (GitHub Actions)","CI median time drops after changes"],"evidence":["No CI timing data is stored in repo; must be measured from GitHub Actions UI/logs."],"line":1,"sources":[{"source":"chatgpt-suspected","file":"engineering-productivity-chatgpt-suspected.jsonl","original_fingerprint":"engineering-productivity::.github/workflows/ci.yml::ci-runtime-unknown"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0043","status":"SUSPECTED"}
{"category":"Testing","title":"No E2E tests - only unit tests exist","fingerprint":"engineering-productivity::tests/e2e/::missing-e2e-tests","severity":"S2","effort":"E2","confidence":85,"files":["tests/e2e/"],"line":1,"why_it_matters":"Critical user workflows (signup, journal entry creation, data persistence) are not validated end-to-end. Unit tests verify individual functions but don't catch integration issues, UI regressions, or broken user flows. E2E tests are essential for a data-sensitive app like a recovery journal where data loss or auth failures have severe consequences. Currently have 477 unit tests but 0 E2E tests.","suggested_fix":"Implement Playwright E2E tests for critical paths: (1) User signup and onboarding flow, (2) Create journal entry and verify persistence, (3) Offline write and sync on reconnect, (4) Dashboard data display, (5) Settings and profile management. Create tests/e2e/ directory with Playwright config. Add 'test:e2e' npm script. Run in CI workflow. Target: 10-15 E2E tests covering golden paths.","acceptance_tests":["npm install --save-dev @playwright/test","playwright.config.ts created with base URL and browser configs","tests/e2e/ directory created","test:e2e script added to package.json","At least 3 E2E tests written: signup, journal-entry, offline-sync","CI workflow runs E2E tests after build","Test artifacts (screenshots, videos) uploaded on failure","Documentation: docs/TESTING_PLAN.md includes E2E testing section"],"evidence":["ls tests/e2e/ → No such directory","grep -r 'playwright' tests/ → 0 matches","grep -r '@playwright/test' package.json → 0 matches","tests/ directory has only unit tests (20 files, 477 test cases)","CI workflow has no E2E test step"],"sources":[{"source":"claudecode","file":"engineering-productivity-claudecode.jsonl","original_fingerprint":"engineering-productivity::tests/e2e/::missing-e2e-tests"}],"verified":false,"consensus_score":1.5,"canonical_id":"CANON-0044","status":"SUSPECTED"}
{"category":"Offline","title":"No offline write queue - mutations lost when offline","fingerprint":"engineering-productivity::lib/offline-queue.ts::missing-write-queue","severity":"S2","effort":"E2","confidence":80,"files":["lib/offline-queue.ts"],"line":1,"why_it_matters":"When users write journal entries offline, mutations fail silently or show errors instead of queueing for later sync. Even with IndexedDB persistence enabled, Firebase SDK doesn't automatically retry failed writes. Users expect 'write and forget' behavior - app should queue writes locally and sync when connectivity returns. Current implementation likely shows error toasts that users must manually retry.","suggested_fix":"Implement offline write queue: (1) Create lib/offline-queue.ts with IndexedDB-backed queue, (2) Wrap all mutations (saveDailyLog, saveJournalEntry) to detect offline state, (3) Queue mutations with timestamp and retry metadata, (4) Listen for online event and process queue, (5) Add UI indicator showing pending syncs count, (6) Handle conflict resolution for edited items. Use Firebase enableIndexedDbPersistence + custom queue for better UX.","acceptance_tests":["lib/offline-queue.ts exists with OfflineQueue class","Queue stores mutations in IndexedDB (not memory)","saveDailyLog and similar functions check offline state and queue if needed","window.addEventListener('online') triggers queue processing","UI shows 'X items pending sync' when offline","Test: Go offline, create 3 entries, go online, verify all 3 sync","Test: Conflict resolution - edit same entry offline twice, verify merge logic","Documentation: ARCHITECTURE.md explains offline queue design"],"evidence":["grep -r 'offline.*queue|write.*queue' lib/ → 0 matches","No IndexedDB queue implementation found","lib/firestore-service.ts mutations don't check navigator.onLine","No UI indicator for pending syncs","Standard pattern: https://web.dev/offline-cookbook/#on-background-sync"],"sources":[{"source":"claudecode","file":"engineering-productivity-claudecode.jsonl","original_fingerprint":"engineering-productivity::lib/offline-queue.ts::missing-write-queue"}],"verified":false,"consensus_score":1.5,"canonical_id":"CANON-0045","status":"SUSPECTED"}
{"category":"Offline","title":"Offline write queue for mutations not found","fingerprint":"engineering-productivity::components/notebook/pages/today-page.tsx::missing-offline-queue","severity":"S2","effort":"E2","confidence":35,"files":["components/notebook/pages/today-page.tsx"],"why_it_matters":"Without an explicit offline write queue, writes may fail silently or require manual retries, increasing support/debugging effort.","suggested_fix":"Introduce a queue for offline mutations and replay when online; surface retry status in UI.","acceptance_tests":["Simulate offline mutation and verify queued retry after reconnect"],"evidence":["Autosave writes go directly to Firestore without a queue abstraction in this module"],"line":616,"sources":[{"source":"codex-suspected","file":"engineering-productivity-codex-suspected.jsonl","original_fingerprint":"engineering-productivity::components/notebook/pages/today-page.tsx::missing-offline-queue"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0046","status":"SUSPECTED"}
{"category":"Testing","title":"14 logger test failures may mask real regressions","fingerprint":"engineering-productivity::tests/::logger-test-failures","severity":"S2","effort":"E1","confidence":35,"files":["tests/"],"why_it_matters":"14 known test failures in logger tests due to mock issues are accepted as not blocking for CI. If a real regression occurs in logger.ts, it would be hidden by these known failures.","suggested_fix":"Fix mock.calls issues in logger tests or properly skip them with clear documentation. Consider using a proper mocking library.","acceptance_tests":["All logger tests pass or are properly skipped with reason","No test failures accepted as known issues without a tracking issue"],"evidence":["Copilot instructions mention 14 failures in logger tests due to mock issues"],"line":1,"sources":[{"source":"copilot-suspected","file":"engineering-productivity-copilot-suspected.jsonl","original_fingerprint":"engineering-productivity::tests/::logger-test-failures"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0047","status":"SUSPECTED"}
{"category":"CI_CD","title":"Deploy workflow runs on every push to main without gate","fingerprint":"engineering-productivity::.github/workflows/deploy-firebase.yml::no-ci-gate","severity":"S2","effort":"E1","confidence":30,"files":[".github/workflows/deploy-firebase.yml"],"why_it_matters":"deploy-firebase.yml triggers on push to main independently of CI passing. If CI fails but a merge happens, broken code could deploy to production.","suggested_fix":"Add workflow_run trigger to require CI workflow completion, or use environment protection rules.","acceptance_tests":["Deploy only runs after CI passes","Failed CI blocks production deployment"],"evidence":["deploy-firebase.yml:3-6 triggers on push to main","No dependency on CI workflow"],"line":3,"sources":[{"source":"copilot-suspected","file":"engineering-productivity-copilot-suspected.jsonl","original_fingerprint":"engineering-productivity::.github/workflows/deploy-firebase.yml::no-ci-gate"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0048","status":"SUSPECTED"}
{"category":"Offline","title":"Missing Service Worker for PWA support","fingerprint":"engineering-productivity::public/sw.js::missing-service-worker","severity":"S2","effort":"E2","confidence":85,"files":["public/sw.js"],"why_it_matters":"The application cannot function as an installable PWA or cache assets for offline use, degrading user experience in poor network conditions.","suggested_fix":"Add a Service Worker (e.g., using next-pwa) to cache static assets and handle offline fallback.","acceptance_tests":["Verify sw.js is registered and application is installable."],"evidence":["public/sw.js does not exist","next.config.mjs does not configure PWA plugin"],"line":1,"sources":[{"source":"jules","file":"engineering-productivity-jules.jsonl","original_fingerprint":"engineering-productivity::public/sw.js::missing-service-worker"}],"verified":false,"consensus_score":1.5,"canonical_id":"CANON-0049","status":"SUSPECTED"}
{"category":"CI_CD","title":"No auto-retry on flaky test failures","fingerprint":"engineering-productivity::.github/workflows/ci.yml::retry-logic","severity":"S3","effort":"E0","confidence":93,"files":[".github/workflows/ci.yml"],"line":114,"why_it_matters":"Flaky tests cause false-negative CI failures, forcing manual rerun failed jobs clicks. This wastes time and trains developers to ignore CI failures.","suggested_fix":"Add nick-fields/retry-action@v2 to CI test step with timeout_minutes: 10 and max_attempts: 2.","acceptance_tests":["CI retries failed test once automatically","Retry count visible in GitHub Actions UI"],"evidence":["No retry logic in .github/workflows/ci.yml:114 test step",".github/workflows/ci.yml:114 runs tests with no retry","No 'retry' or 'continue-on-error' on test steps","actions/retry not used in workflow","Best practice: https://github.com/marketplace/actions/retry-action"],"sources":[{"source":"claude","file":"engineering-productivity-claude.jsonl","original_fingerprint":"engineering-productivity::.github/workflows/ci.yml::retry-logic"},{"source":"claudecode","file":"engineering-productivity-claudecode.jsonl","original_fingerprint":"engineering-productivity::.github/workflows/ci.yml::no-retry-logic"}],"merged_from":["engineering-productivity::.github/workflows/ci.yml::retry-logic","engineering-productivity::.github/workflows/ci.yml::no-retry-logic"],"verified":true,"consensus_score":3,"canonical_id":"CANON-0050","status":"CONFIRMED"}
{"category":"Engineering","title":"66 npm scripts lack discoverability","fingerprint":"engineering-productivity::package.json::script-documentation","severity":"S3","effort":"E1","confidence":65,"files":["package.json","scripts/README.md"],"line":5,"why_it_matters":"66 npm scripts is excellent automation but new developers face which script do I run paralysis. scripts/README.md exists but is not linked from main README.md.","suggested_fix":"Create npm run help script that categorizes scripts. Add scripts/README.md link to main README.md Quick Start section. Add examples for top 10 most-used scripts.","acceptance_tests":["npm run help shows categorized script list","README.md links to scripts/README.md","New contributor can find relevant scripts in <1 minute"],"evidence":["package.json has 66 scripts with no categorization","npm run output is unsorted wall of text","scripts/README.md exists but not linked from main README","package.json:5-71 contains 66 scripts","No SCRIPTS.md or script documentation exists"],"sources":[{"source":"claude-suspected","file":"engineering-productivity-claude-suspected.jsonl","original_fingerprint":"engineering-productivity::package.json::script-documentation"},{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::package.json::script-sprawl"}],"merged_from":["engineering-productivity::package.json::script-documentation","engineering-productivity::package.json::script-sprawl"],"verified":true,"consensus_score":2.5,"canonical_id":"CANON-0051","status":"CONFIRMED"}
{"category":"GoldenPath","title":"Environment example file naming is non-standard (.env.local.example; no .env.example)","fingerprint":"engineering-productivity::.env.local.example::nonstandard-env-example-naming","severity":"S3","effort":"E0","confidence":95,"files":[".env.local.example"],"why_it_matters":"Many tools and contributor expectations look for .env.example. Non-standard naming causes small but recurring friction and confusion in onboarding guides.","suggested_fix":"Either add a copy/symlinked .env.example or document explicitly in README Quick Start which file to copy and why.","acceptance_tests":["test -f .env.example (if added)","README Quick Start references the correct env example file"],"evidence":["Repo contains .env.local.example but not .env.example"],"line":1,"sources":[{"source":"chatgpt","file":"engineering-productivity-chatgpt.jsonl","original_fingerprint":"engineering-productivity::.env.local.example::nonstandard-env-example-naming"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0052","status":"CONFIRMED"}
{"category":"Testing","title":"Tests not organized by domain - flat structure in tests/ directory","fingerprint":"engineering-productivity::tests/::flat-test-structure","severity":"S3","effort":"E1","confidence":90,"files":["tests/"],"line":1,"why_it_matters":"Test files are all in flat tests/ directory rather than organized by feature domain (auth, journal, meetings, etc.). This makes it harder to: (1) Find tests for specific features, (2) Run tests for a specific domain, (3) Understand test coverage by module. As test count grows (currently 477 tests), organization becomes critical for maintainability. Minor issue now but will cause friction as project scales.","suggested_fix":"Reorganize tests by domain: tests/auth/, tests/journal/, tests/meetings/, tests/admin/, tests/lib/. Mirror the app/ and components/ directory structure. Update test:build script to compile from new structure. Consider using test naming convention: <feature>.test.ts. Add 'test:unit' and 'test:integration' scripts for filtering. Document test organization in docs/TESTING_PLAN.md.","acceptance_tests":["tests/ has subdirectories: auth/, journal/, meetings/, admin/, lib/","Each test file follows pattern: tests/<domain>/<feature>.test.ts","npm run test still runs all tests","New npm scripts: test:auth, test:journal for domain-specific runs","Documentation: TESTING_PLAN.md explains test organization","Developers can easily find tests for feature they're modifying"],"evidence":["ls tests/ shows flat structure (20 .test.ts files at root)","No subdirectories for domains: ls tests/*/ → No such directory","Current structure makes it hard to filter: npm run test tests/journal/*","Standard practice: Mirror app/ structure in tests/"],"sources":[{"source":"claudecode","file":"engineering-productivity-claudecode.jsonl","original_fingerprint":"engineering-productivity::tests/::flat-test-structure"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0053","status":"CONFIRMED"}
{"category":"GoldenPath","title":"No npm run doctor diagnostic script","fingerprint":"engineering-productivity::scripts/doctor.js::missing-doctor-script","severity":"S3","effort":"E1","confidence":80,"files":["scripts/doctor.js","package.json"],"line":1,"why_it_matters":"Developers have no single command to validate their environment setup. When things break, they must manually check: Node version, dependencies installed, env vars set, Firebase connection working, tests passing. A 'doctor' script automates all health checks and provides actionable error messages. Industry standard for mature projects (like create-react-app, Next.js). Low priority but high value for developer experience.","suggested_fix":"Create scripts/doctor.js that runs: (1) Check Node.js version (>=18), (2) Verify npm and dependencies installed, (3) Check .env.local exists and has required vars, (4) Test Firebase connection (try to initialize, don't write), (5) Run linter and type check, (6) Run test suite, (7) Check for circular dependencies. Output: checks passed, checks failed with fix instructions. Add 'doctor' script to package.json.","acceptance_tests":["scripts/doctor.js exists","package.json has 'doctor': 'node scripts/doctor.js'","Script checks all 7 health categories","Script exits with code 0 if all checks pass, code 1 if any fail","Output is color-coded and actionable (tells user what to fix)","Test: Break setup (remove .env.local), run doctor, verify clear error","Documentation: README.md mentions 'npm run doctor' for troubleshooting"],"evidence":["ls scripts/ | grep doctor → 0 matches","No 'doctor' script in package.json","DEVELOPMENT.md has manual troubleshooting section but no automated check","Similar pattern from process audit (suspected finding #3)"],"sources":[{"source":"claudecode","file":"engineering-productivity-claudecode.jsonl","original_fingerprint":"engineering-productivity::scripts/doctor.js::missing-doctor-script"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0054","status":"CONFIRMED"}
{"category":"CI_CD","title":"No CI step parallelization — all checks run sequentially","fingerprint":"engineering-productivity::.github/workflows/ci.yml::sequential-steps","severity":"S3","effort":"E2","confidence":80,"files":[".github/workflows/ci.yml"],"why_it_matters":"Lint, format, deps, patterns, doc check, type check, and tests all run sequentially in one job. Some are independent and could run in parallel.","suggested_fix":"Split into parallel jobs: lint+format+patterns, typecheck, tests+coverage. Use needs: for the build job to depend on all three.","acceptance_tests":["Independent checks run in parallel","Total CI time reduced","All checks still gate the build"],"evidence":["ci.yml:10-131 — all steps in single job","15+ sequential steps before tests run"],"line":10,"sources":[{"source":"copilot","file":"engineering-productivity-copilot.jsonl","original_fingerprint":"engineering-productivity::.github/workflows/ci.yml::sequential-steps"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0055","status":"CONFIRMED"}
{"category":"GoldenPath","title":"Missing setup automation script","fingerprint":"engineering-productivity::package.json::missing-setup-script","severity":"S3","effort":"E0","confidence":100,"files":["package.json"],"why_it_matters":"New developers must manually configure environment variables and hooks, increasing onboarding time and error risk.","suggested_fix":"Add a setup script to package.json that runs npm install, copies .env.example to .env.local, and initializes git hooks.","acceptance_tests":["Run npm run setup in a clean clone and verify environment is ready."],"evidence":["package.json scripts section missing setup command"],"line":1,"sources":[{"source":"jules","file":"engineering-productivity-jules.jsonl","original_fingerprint":"engineering-productivity::package.json::missing-setup-script"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0056","status":"CONFIRMED"}
{"category":"Testing","title":"Coverage percentage target and current baseline are not visible in repo docs; may cause unclear expectations","fingerprint":"engineering-productivity::package.json::coverage-baseline-unknown","severity":"S3","effort":"E0","confidence":40,"files":["package.json","DEVELOPMENT.md"],"why_it_matters":"When coverage expectations aren't explicit, teams argue about what's enough, and regressions slip in unnoticed.","suggested_fix":"Document current coverage baseline and a target (or no regression policy). If already tracked elsewhere, link it from DEVELOPMENT.md.","acceptance_tests":["CI logs/report publish the % and enforce policy"],"evidence":["package.json runs c8 coverage, but no visible threshold/policy in docs was confirmed in this pass."],"line":1,"sources":[{"source":"chatgpt-suspected","file":"engineering-productivity-chatgpt-suspected.jsonl","original_fingerprint":"engineering-productivity::package.json::coverage-baseline-unknown"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0057","status":"SUSPECTED"}
{"category":"GoldenPath","title":"Setup time from clone to first test unknown","fingerprint":"engineering-productivity::DEVELOPMENT.md::setup-time","severity":"S3","effort":"E0","confidence":40,"files":["DEVELOPMENT.md"],"line":40,"why_it_matters":"No documented or measured time from git clone to npm test passes metric. Best-in-class projects aim for <5 minutes. Without measuring we cannot optimize.","suggested_fix":"Add scripts/measure-setup-time.sh that times each setup step. Document expected time in DEVELOPMENT.md. Create scripts/quick-start.sh that automates Firebase emulator setup.","acceptance_tests":["New contributor can clone → npm install → npm test in <10 minutes using emulators","DEVELOPMENT.md includes Expected setup time section"],"evidence":["No timing benchmarks in DEVELOPMENT.md","Setup requires manual Firebase Console configuration"],"sources":[{"source":"claude-suspected","file":"engineering-productivity-claude-suspected.jsonl","original_fingerprint":"engineering-productivity::DEVELOPMENT.md::setup-time"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0058","status":"SUSPECTED"}
{"category":"GoldenPath","title":"Potentially missing troubleshooting documentation","fingerprint":"engineering-productivity::docs/TROUBLESHOOTING.md::missing-doc","severity":"S3","effort":"E0","confidence":40,"files":["docs/TROUBLESHOOTING.md","DEVELOPMENT.md"],"line":1,"why_it_matters":"DEVELOPMENT.md has setup instructions but may lack dedicated troubleshooting section for common issues (Firebase connection errors, dependency conflicts, test failures, etc.). Without troubleshooting docs, developers waste time on Stack Overflow or re-installing dependencies. Low confidence because DEVELOPMENT.md may have troubleshooting embedded (didn't read full file).","suggested_fix":"If DEVELOPMENT.md lacks troubleshooting section: Add '## Troubleshooting' section covering common issues: (1) Firebase connection errors (invalid credentials, quota exceeded), (2) Module not found errors (npm install), (3) Port already in use (kill process), (4) Test failures (clear cache), (5) Type errors (npx tsc --noEmit). Alternatively create dedicated docs/TROUBLESHOOTING.md. Link from README.md.","acceptance_tests":["DEVELOPMENT.md has ## Troubleshooting section with 5+ common issues","Each issue has: symptom, cause, solution","Or: docs/TROUBLESHOOTING.md exists with comprehensive guide","README.md links to troubleshooting documentation","Developer feedback: Issues are well-documented"],"evidence":["Read DEVELOPMENT.md:1-100 (partial) - setup instructions present","Did not see dedicated Troubleshooting section in first 100 lines","Need to read full DEVELOPMENT.md to confirm presence/absence","Standard practice: Most projects have troubleshooting docs"],"sources":[{"source":"claudecode-suspected","file":"engineering-productivity-claudecode-suspected.jsonl","original_fingerprint":"engineering-productivity::docs/TROUBLESHOOTING.md::missing-doc"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0059","status":"SUSPECTED"}
{"category":"Testing","title":"Unknown test coverage percentage - no baseline documented","fingerprint":"engineering-productivity::tests/::unknown-coverage","severity":"S3","effort":"E0","confidence":50,"files":["tests/","package.json"],"line":1,"why_it_matters":"Don't know current test coverage percentage. CI uploads coverage report (c8) but no baseline documented in DEVELOPMENT.md or README. Without baseline, can't track if coverage is improving or regressing. Low priority but useful for measuring test quality. Low confidence because coverage may be documented elsewhere (didn't read full docs).","suggested_fix":"Run 'npm run test:coverage' locally and document baseline in DEVELOPMENT.md: '## Test Coverage - Current: XX% (last updated YYYY-MM-DD)'. Set coverage threshold in package.json (c8 config) to prevent regressions. Add coverage badge to README.md if desired. Configure CI to fail if coverage drops below threshold.","acceptance_tests":["Coverage baseline documented in DEVELOPMENT.md","c8 configuration has coverage thresholds (branches, functions, lines, statements)","CI fails if coverage drops below threshold","Coverage report accessible: npm run test:coverage → open coverage/index.html","Team knows current coverage and tracks trends"],"evidence":["package.json has test:coverage script using c8","CI uploads coverage artifact (lines 125-131)","No coverage baseline found in README.md (first 50 lines)","No c8 thresholds configured in package.json (didn't see in read)","Need to check: .c8rc, coverage in package.json"],"sources":[{"source":"claudecode-suspected","file":"engineering-productivity-claudecode-suspected.jsonl","original_fingerprint":"engineering-productivity::tests/::unknown-coverage"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0060","status":"SUSPECTED"}
{"category":"Testing","title":"Playwright dependency present but no e2e script","fingerprint":"engineering-productivity::package.json::missing-e2e-script","severity":"S3","effort":"E1","confidence":65,"files":["package.json"],"why_it_matters":"Having @playwright/test installed without a runnable script leads to confusion and inconsistent e2e execution.","suggested_fix":"Add an npm script (e.g., 'test:e2e': 'playwright test') and document where e2e tests live.","acceptance_tests":["npm run test:e2e executes Playwright successfully"],"evidence":["@playwright/test: ^1.58.1 is present in devDependencies, but no e2e script exists in scripts"],"line":5,"sources":[{"source":"codex","file":"engineering-productivity-codex.jsonl","original_fingerprint":"engineering-productivity::package.json::missing-e2e-script"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0061","status":"SUSPECTED"}
{"category":"Debugging","title":"Production logging may miss warn/info level events","fingerprint":"engineering-productivity::lib/logger.ts::production-log-suppression","severity":"S3","effort":"E1","confidence":30,"files":["lib/logger.ts"],"why_it_matters":"logger.ts only sends errors to Sentry in production. Warnings and info logs are completely suppressed, making it impossible to debug non-error issues without reproducing locally.","suggested_fix":"Consider sending warnings to Sentry with lower sampling rate, or add a production debug mode toggled via feature flag.","acceptance_tests":["Critical warnings captured in production monitoring","Debug mode available without redeployment"],"evidence":["lib/logger.ts:120 — if (isProduction && level === 'error')","Info and warn completely suppressed in production"],"line":120,"sources":[{"source":"copilot-suspected","file":"engineering-productivity-copilot-suspected.jsonl","original_fingerprint":"engineering-productivity::lib/logger.ts::production-log-suppression"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0062","status":"SUSPECTED"}
{"category":"Engineering","title":"Potential unused dependencies","fingerprint":"engineering-productivity::package.json::unused-deps","severity":"S3","effort":"E1","confidence":40,"files":["package.json"],"why_it_matters":"Unused dependencies bloat the install size and increase security surface area.","suggested_fix":"Run knip and remove confirmed unused dependencies.","acceptance_tests":["Run npm run deps:unused and verify clean output."],"evidence":["knip is in scripts but I did not run it to confirm failures"],"line":1,"sources":[{"source":"jules-suspected","file":"engineering-productivity-jules-suspected.jsonl","original_fingerprint":"engineering-productivity::package.json::unused-deps"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0063","status":"SUSPECTED"}
{"category":"Performance","title":"Potentially missing performance monitoring","fingerprint":"engineering-productivity::lib/performance.ts::missing-monitoring","severity":"S3","effort":"E1","confidence":40,"files":["lib/performance.ts","next.config.js"],"line":1,"why_it_matters":"May lack runtime performance monitoring (Core Web Vitals, API latency, render times). Sentry is integrated but primarily for error tracking, not performance. Next.js has built-in performance monitoring but needs configuration. Without performance data, can't identify slow pages or regressions. Very low confidence - monitoring may exist but not obviously named.","suggested_fix":"If performance monitoring missing: (1) Enable Next.js Analytics in next.config.js, (2) Configure Sentry Performance monitoring (already have Sentry), (3) Add Web Vitals tracking with next/web-vitals, (4) Consider Firebase Performance Monitoring for API calls, (5) Add performance budgets in Lighthouse CI. Document baseline metrics in DEVELOPMENT.md.","acceptance_tests":["Performance monitoring configured (Next.js Analytics or Sentry Performance)","Web Vitals tracked: LCP, FID, CLS","API call latency tracked","Dashboard showing performance trends","Performance budgets defined","Documentation: DEVELOPMENT.md explains performance monitoring"],"evidence":["Sentry integrated (seen in DEVELOPMENT.md)","Don't know if Sentry Performance enabled (need to check Sentry init)","No obvious lib/performance.ts or lib/analytics.ts found","Next.js has built-in monitoring but needs opt-in","Need to verify: Sentry config, next.config.js, Firebase Performance"],"sources":[{"source":"claudecode-suspected","file":"engineering-productivity-claudecode-suspected.jsonl","original_fingerprint":"engineering-productivity::lib/performance.ts::missing-monitoring"}],"verified":false,"consensus_score":1,"canonical_id":"CANON-0064","status":"SUSPECTED"}
{"category":"Offline","title":"No UI indicator for online/offline state","fingerprint":"engineering-productivity::components/offline-indicator.tsx::missing-offline-ui","severity":"S3","effort":"E1","confidence":70,"files":["components/offline-indicator.tsx"],"line":1,"why_it_matters":"Users don't know when they're offline and may be confused why saves fail or data doesn't load. A simple online/offline indicator (banner, toast, status icon) provides critical feedback. Currently found 8 mentions of 'offline' in components but no dedicated UI indicator. Without visual feedback, users may think app is broken rather than their network. Low severity because app may work without obvious issues, but creates confusion when offline features are added.","suggested_fix":"Create components/offline-indicator.tsx that: (1) Listens to window online/offline events, (2) Shows banner at top when offline ('You are offline. Changes will sync when reconnected'), (3) Shows toast when transitioning online to offline and vice versa, (4) Optionally shows pending sync count if offline queue implemented. Use React Context to make online state available app-wide. Add to app/layout.tsx.","acceptance_tests":["components/offline-indicator.tsx created","Component listens to window.addEventListener('online/offline')","Banner appears at top when offline with appropriate message","Toast notification on network state change","Component uses React Context to share state app-wide","Test: Disconnect network, verify banner appears immediately","Test: Reconnect network, verify banner disappears and toast shows","Integration with offline queue to show pending sync count"],"evidence":["grep -r 'offline.*indicator|network.*status' components/ → 0 matches","grep -r 'navigator.onLine|window.addEventListener.*online' components/ → 8 mentions (scattered, no UI component)","No dedicated offline UI component found","Standard pattern: https://web.dev/offline-ux-design-guidelines/"],"sources":[{"source":"claudecode","file":"engineering-productivity-claudecode.jsonl","original_fingerprint":"engineering-productivity::components/offline-indicator.tsx::missing-offline-ui"}],"verified":false,"consensus_score":1,"canonical_id":"CANON-0065","status":"SUSPECTED"}