{"category":"Bundle Size","title":"Excessive client-component surface (\"use client\" appears 107 times) increases hydration + JS cost","fingerprint":"Bundle Size::app/components::use_client_overuse","severity":"S1","effort":"E3","confidence":90,"files":["app/admin/page.tsx","app/meetings/all/page.tsx","components/admin/admin-crud-table.tsx"],"symbols":["AdminPage","MeetingsAllPage","AdminCrudTable"],"performance_details":{"current_metric":"107 occurrences of \"use client\" across app/components/hooks/lib/types (high hydration surface)","expected_improvement":"20–40% reduction in initial JS/hydration work on non-interactive routes after moving logic to server components and narrowing client islands","affected_metric":"bundle"},"optimization":{"description":"Reduce client boundary: keep pages/layouts server by default; move only interactive subtrees to client components; prefer server-side data shaping for static/exported pages where possible.","code_example":"// app/some-route/page.tsx (Server)\nimport ClientWidget from './client-widget';\nexport default function Page(){\n  return (<>\n    <StaticSection />\n    <ClientWidget />\n  </>);\n}\n","verification":["Re-run grep count for \"use client\" and track down; ensure key routes remain interactive.","After changes, run bundle analyzer + Lighthouse to confirm reduced JS and improved INP."]},"evidence":["grep count: 107 lines match \"\\\"use client\\\"\" under app/components/hooks/lib/types","app/admin/page.tsx:1 \"use client\"","app/meetings/all/page.tsx:1 \"use client\""],"notes":"Scope note: routes like /dashboard, /daily-log, /analytics were not present in this repo snapshot; audit focuses on existing routes.","line":1,"sources":[{"source":"chatgpt","file":"performance-chatgpt.jsonl","original_fingerprint":"Bundle Size::app/components::use_client_overuse"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0001","status":"CONFIRMED"}
{"category":"Data Fetching","title":"Unbounded Firestore reads in AdminCrudTable (getDocs(collection)) can load entire collections","fingerprint":"Data Fetching::components/admin/admin-crud-table.tsx::unbounded_getdocs","severity":"S1","effort":"E2","confidence":95,"files":["components/admin/admin-crud-table.tsx"],"symbols":["AdminCrudTable","fetchItems"],"performance_details":{"current_metric":"getDocs(ref) on a collection ref without query/limit; client then filters in-memory","expected_improvement":"20–50% faster admin load time + lower Firestore cost once server-side filtering/pagination and limit() are added","affected_metric":"render"},"optimization":{"description":"Paginate and limit Firestore reads (limit + startAfter). Push filtering to query constraints where possible (e.g., where/orderBy). Add debounced search and server-side search strategy for large collections.","code_example":"// Prefer queries with limit + cursor\nconst q = query(collection(db, name), orderBy('createdAt','desc'), limit(50));\nconst snap = await getDocs(q);\n","verification":["Verify network payload size drops when loading admin tabs.","Confirm scrolling/pagination fetches additional pages rather than loading all documents."]},"evidence":["components/admin/admin-crud-table.tsx:60-62 const ref = collection(...); const snapshot = await getDocs(ref);","components/admin/admin-crud-table.tsx:92 filteredItems = items.filter(...) (client-side filtering after fetch)"],"notes":"Even if only admins use this, it still impacts perceived responsiveness and Firestore billing.","line":61,"sources":[{"source":"chatgpt","file":"performance-chatgpt.jsonl","original_fingerprint":"Data Fetching::components/admin/admin-crud-table.tsx::unbounded_getdocs"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0002","status":"CONFIRMED"}
{"category":"Rendering","title":"Today page re-subscribes Firestore onSnapshot when journalEntry changes (likely per-keystroke)","fingerprint":"Rendering::components/notebook/pages/today-page.tsx::effect_dep_resubscribe","severity":"S1","effort":"E2","confidence":90,"files":["components/notebook/pages/today-page.tsx"],"symbols":["TodayPage","useEffect","onSnapshot"],"performance_details":{"current_metric":"useEffect dependency array includes journalEntry; effect sets up Firestore listener and dynamic imports","expected_improvement":"20–50% improvement in typing responsiveness and reduced listener churn if dependency is stabilized (depends on how often journalEntry updates)","affected_metric":"INP"},"optimization":{"description":"Remove journalEntry from the subscription effect deps if not required for subscription correctness; split effect into (1) one-time restore, (2) listener subscription keyed only on user/referenceDate/handlers. Use refs to avoid stale closures instead of re-subscribing.","code_example":"useEffect(() => {\n  if (!user) return;\n  let unsub: (()=>void)|undefined;\n  let mounted = true;\n  (async()=>{\n    const { onSnapshot, doc } = await import('firebase/firestore');\n    const { db } = await import('@/lib/firebase');\n    const docRef = doc(db, buildPath.dailyLog(user.uid, getTodayDateId(referenceDate)));\n    if (mounted) unsub = onSnapshot(docRef, snap => handleSnapshotUpdate(snap, true));\n  })();\n  return () => { mounted = false; unsub?.(); };\n}, [user, referenceDate, handleSnapshotUpdate]);\n","verification":["Add temporary logging counter for listener setups; typing should not increase setup count.","React Profiler: reduced commits while editing journalEntry."]},"evidence":["components/notebook/pages/today-page.tsx:525-579 sets up onSnapshot + dynamic imports inside useEffect","components/notebook/pages/today-page.tsx:579 dependency array includes journalEntry"],"notes":"This is a high-leverage fix if journalEntry is tied to text input updates.","line":579,"sources":[{"source":"chatgpt","file":"performance-chatgpt.jsonl","original_fingerprint":"Rendering::components/notebook/pages/today-page.tsx::effect_dep_resubscribe"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0003","status":"CONFIRMED"}
{"category":"Bundle Size","title":"images.unoptimized: true disables all Next.js image optimization","fingerprint":"Bundle Size::next.config.mjs::images_unoptimized","severity":"S1","effort":"E2","confidence":100,"files":["next.config.mjs"],"line":15,"symbols":["nextConfig"],"performance_details":{"current_metric":"images.unoptimized: true - all images served as raw originals with no resizing, format conversion, or lazy loading optimization","expected_improvement":"30-60% reduction in image transfer size via WebP/AVIF conversion, responsive srcsets, and automatic lazy loading","affected_metric":"LCP"},"optimization":{"description":"The static export (output: 'export') forces unoptimized images because Next.js Image Optimization requires a server. Use a build-time image optimization pipeline (e.g., sharp via a script, or next-optimized-images plugin) to pre-generate WebP/AVIF variants and responsive sizes at build time.","code_example":"// Alternative: Use a custom loader with a CDN like Firebase Hosting's built-in image serving\n// Or pre-optimize images at build time with sharp","verification":["Check that images are served in modern formats (WebP/AVIF) after optimization","Verify LCP improvement with Lighthouse"]},"evidence":["next.config.mjs:14-16: images: { unoptimized: true }","output: 'export' forces this setting","5 files use next/image but optimization is disabled globally","Background image at app/page.tsx:26 uses raw url('/images/wood-table.jpg')"],"notes":"This is the single highest-impact optimization. The wood-table.jpg background is the likely LCP element on the landing page and is served unoptimized.","sources":[{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"Bundle Size::next.config.mjs::images_unoptimized"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0004","status":"CONFIRMED"}
{"category":"Bundle Size","title":"Framer Motion Overuse - Heavy Animation Library","fingerprint":"Bundle::package.json::framer_motion_size","severity":"S1","effort":"E2","confidence":90,"files":["package.json","components/notebook/sticky-note.tsx","components/celebrations/success-pulse.tsx","components/ui/empty-state.tsx","components/journal/entry-menu.tsx","components/journal/floating-pen.tsx","components/notebook/bookmark-ribbon.tsx","components/widgets/daily-quote-card.tsx"],"line":92,"symbols":["framer-motion"],"performance_details":{"current_metric":"~45KB gzipped for simple animations","expected_improvement":"Reduce bundle by 30-40KB using CSS animations","affected_metric":"bundle"},"optimization":{"description":"Replace framer-motion with CSS transitions for simple fade/scale animations. Keep for complex 3D transforms in notebook-shell.","code_example":"// Before (framer-motion):\n<motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} />\n\n// After (CSS):\n<div className=\"animate-fade-in\" /> // with @keyframes in CSS","verification":["Run npx @next/bundle-analyzer","Measure bundle size before/after","Test animation smoothness"]},"evidence":["10+ components import framer-motion for simple animations","sticky-note.tsx:15 - simple scale animation","floating-pen.tsx:14 - scale/rotate on hover","daily-quote-card.tsx:3 - fade-in animation"],"sources":[{"source":"copilot","file":"performance-copilot.jsonl","original_fingerprint":"Bundle::package.json::framer_motion_size"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0005","status":"CONFIRMED"}
{"category":"Rendering","title":"Admin Page Entire Page Marked as Client Component","fingerprint":"Bundle::app/admin/page.tsx::client_boundary","severity":"S1","effort":"E1","confidence":85,"files":["app/admin/page.tsx","app/dev/page.tsx"],"line":1,"symbols":["AdminPage","DevPage"],"performance_details":{"current_metric":"Entire page bundle sent to client","expected_improvement":"Reduce initial JS by extracting server-renderable parts","affected_metric":"bundle"},"optimization":{"description":"Split into server layout + client components for auth/interactive parts only","verification":["Check bundle size reduction","Verify SSR HTML includes static markup"]},"evidence":["app/admin/page.tsx:1 'use client' directive","app/dev/page.tsx:1 same pattern"],"sources":[{"source":"copilot","file":"performance-copilot.jsonl","original_fingerprint":"Bundle::app/admin/page.tsx::client_boundary"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0006","status":"CONFIRMED"}
{"category":"Core Web Vitals","title":"Notebook Animation Delays Interactivity","fingerprint":"CoreWebVitals::notebook-shell.tsx::animation_blocking","severity":"S1","effort":"E1","confidence":80,"files":["components/notebook/notebook-shell.tsx"],"line":189,"symbols":["NotebookShell"],"performance_details":{"current_metric":"500ms animation blocks First Input Delay","expected_improvement":"Immediate interactivity with progressive enhancement","affected_metric":"INP"},"optimization":{"description":"Make animation non-blocking by using CSS transforms and will-change","verification":["Measure INP with Lighthouse","Test interactivity during animation"]},"evidence":["notebook-shell.tsx:189-195 - motion.div with 500ms duration transition"],"sources":[{"source":"copilot","file":"performance-copilot.jsonl","original_fingerprint":"CoreWebVitals::notebook-shell.tsx::animation_blocking"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0007","status":"CONFIRMED"}
{"category":"Offline Support","title":"No Offline Detection or Sync Queue","fingerprint":"Offline::global::no_offline_support","severity":"S1","effort":"E3","confidence":100,"files":["lib/firebase.ts","hooks/use-journal.ts"],"line":1,"symbols":["N/A"],"performance_details":{"current_metric":"No offline capability - data loss on network failure","expected_improvement":"Graceful offline mode with sync queue","affected_metric":"memory"},"optimization":{"description":"Implement offline detection, IndexedDB cache, and sync queue for writes","verification":["Test offline mode in DevTools","Verify data syncs on reconnect","Check for duplicate writes"]},"evidence":["No navigator.onLine usage found","No IndexedDB or localStorage sync queue","Firebase SDK handles some offline but app doesn't manage UI state"],"sources":[{"source":"copilot","file":"performance-copilot.jsonl","original_fingerprint":"Offline::global::no_offline_support"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0008","status":"CONFIRMED"}
{"category":"Rendering Performance","title":"Tab switching unmounts components causing redundant fetches","fingerprint":"Rendering::components/notebook/notebook-shell.tsx::unnecessary_unmount","severity":"S1","effort":"E1","confidence":100,"files":["components/notebook/notebook-shell.tsx"],"symbols":["NotebookShell","renderPage"],"performance_details":{"current_metric":"Full remount on tab switch","expected_improvement":"Instant tab switching, 0 redundant fetches","affected_metric":"render"},"optimization":{"description":"Prevent unmounting of active tabs by using CSS visibility toggling or a 'KeepAlive' pattern instead of conditional rendering.","code_example":"<div style={{ display: active ? 'block' : 'none' }}>...","verification":["Switch tabs and observe network panel - should see 0 new requests"]},"evidence":["components/notebook/notebook-shell.tsx:180"],"line":180,"sources":[{"source":"jules","file":"performance-jules.jsonl","original_fingerprint":"Rendering::components/notebook/notebook-shell.tsx::unnecessary_unmount"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0009","status":"CONFIRMED"}
{"category":"Core Web Vitals","title":"Image optimization disabled globally","fingerprint":"Core Web Vitals::next.config.mjs::unoptimized_images","severity":"S1","effort":"E1","confidence":100,"files":["next.config.mjs"],"symbols":["nextConfig"],"performance_details":{"current_metric":"unoptimized: true","expected_improvement":"Reduced LCP and bandwidth","affected_metric":"LCP"},"optimization":{"description":"Remove unoptimized: true and configure a custom image loader compatible with Firebase Hosting (e.g., using Cloudinary or specialized Firebase loader).","verification":["Inspect image headers for WebP/AVIF format"]},"evidence":["next.config.mjs:15"],"line":15,"sources":[{"source":"jules","file":"performance-jules.jsonl","original_fingerprint":"Core Web Vitals::next.config.mjs::unoptimized_images"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0010","status":"CONFIRMED"}
{"category":"Offline Support","title":"Writes rely on Cloud Functions, failing when offline","fingerprint":"Offline Support::lib/firestore-service.ts::cloud_function_write","severity":"S1","effort":"E3","confidence":100,"files":["lib/firestore-service.ts"],"symbols":["saveDailyLog","retryCloudFunction"],"performance_details":{"current_metric":"Fails when offline","expected_improvement":"Queued local writes","affected_metric":"Offline Support"},"optimization":{"description":"Implement an offline queue using IndexedDB or Redux Persist. Store actions locally when offline and replay them when online. Alternatively, switch to direct Firestore writes with robust security rules for better offline support.","verification":["Disconnect network, try saving, verify queue size > 0"]},"evidence":["lib/firestore-service.ts:180"],"line":180,"sources":[{"source":"jules","file":"performance-jules.jsonl","original_fingerprint":"Offline Support::lib/firestore-service.ts::cloud_function_write"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0011","status":"CONFIRMED"}
{"category":"Data Fetching","title":"Duplicate Mood Data Fetches","fingerprint":"DataFetch::hooks/use-journal.ts::duplicate_fetch","severity":"S1","effort":"E1","confidence":40,"files":["hooks/use-journal.ts","components/widgets/mood-sparkline.tsx"],"line":1,"symbols":["useMoodHistory","MoodSparkline"],"performance_details":{"current_metric":"Same mood data fetched in multiple components","expected_improvement":"Single query shared via context","affected_metric":"render"},"optimization":{"description":"Consolidate mood fetches into shared hook or context","code_example":"N/A - requires seeing full hook implementations"},"evidence":["Previous audit (audit-performance-report.md) mentions PERF-003: duplicate mood history fetch"],"notes":"Requires verification of hook implementations","sources":[{"source":"copilot-suspected","file":"performance-copilot-suspected.jsonl","original_fingerprint":"DataFetch::hooks/use-journal.ts::duplicate_fetch"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0012","status":"SUSPECTED"}
{"category":"Core Web Vitals","title":"Landing page LCP risk: large background image via CSS url() without preload/priority","fingerprint":"Core Web Vitals::app/page.tsx::background_lcp_risk","severity":"S2","effort":"E1","confidence":88,"files":["app/page.tsx"],"symbols":["Home"],"performance_details":{"current_metric":"Hero background uses CSS background-image url('/images/wood-table.jpg')","expected_improvement":"5–15% LCP improvement (depends on image size and caching) by preloading and optimizing asset","affected_metric":"LCP"},"optimization":{"description":"Optimize wood-table.jpg (modern format, size), add preload via <link rel=\"preload\" as=\"image\"> in layout/head, ensure long-cache headers on Hosting, and consider using a smaller placeholder/gradient until image loads.","code_example":"// app/layout.tsx (or metadata)\nexport const metadata = { /* ... */ };\n// In <head> add:\n// <link rel=\"preload\" as=\"image\" href=\"/images/wood-table.jpg\" />\n","verification":["Lighthouse: confirm LCP resource is cached/preloaded; observe improved LCP.","Network waterfall: image starts earlier (preload hit)."]},"evidence":["app/page.tsx:25-27 backgroundImage: `url('/images/wood-table.jpg')`","app/page.tsx:26: style={{ backgroundImage: `url('/images/wood-table.jpg')` }}","No <link rel='preload'> for this image found in layout.tsx","This is likely the LCP element as it's the largest visible content on landing"],"notes":"Using next/image isn't applicable for CSS backgrounds, so preload + asset optimization is the main lever.","line":26,"sources":[{"source":"chatgpt","file":"performance-chatgpt.jsonl","original_fingerprint":"Core Web Vitals::app/page.tsx::background_lcp_risk"},{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"Core Web Vitals::app/page.tsx::background_not_preloaded"}],"merged_from":["Core Web Vitals::app/page.tsx::background_lcp_risk","Core Web Vitals::app/page.tsx::background_not_preloaded"],"verified":true,"consensus_score":3,"canonical_id":"CANON-0013","status":"CONFIRMED"}
{"category":"Bundle Size","title":"Framer Motion imported broadly (37 files) — consider LazyMotion and route-level code splitting","fingerprint":"Bundle Size::components::framer_motion_wide_import","severity":"S2","effort":"E2","confidence":85,"files":["components/notebook/notebook-shell.tsx","components/journal/entry-menu.tsx","components/celebrations/milestone-modal.tsx"],"symbols":["NotebookShell","EntryMenu","MilestoneModal"],"performance_details":{"current_metric":"37 framer-motion import hits in components/app/hooks/lib","expected_improvement":"5–15% reduction in client bundle (route-dependent) and faster hydration, especially on routes that don't need animations","affected_metric":"bundle"},"optimization":{"description":"Use Framer Motion's LazyMotion + domAnimation (or domMax if needed) and load heavier animated UI (modals/celebrations) via dynamic import when off-screen or route-scoped.","code_example":"import { LazyMotion, domAnimation, m } from 'framer-motion';\n\nexport function AnimatedCard(){\n  return (\n    <LazyMotion features={domAnimation}>\n      <m.div initial={{opacity:0}} animate={{opacity:1}} />\n    </LazyMotion>\n  );\n}\n","verification":["Confirm framer-motion code not included on routes without animations (bundle analyzer).","Check animation behavior parity (no regressions)."]},"evidence":["grep shows framer-motion imports (count=37) e.g., components/auth/sign-in-modal.tsx:11, components/home/home-client.tsx:6"],"notes":"Dynamic import already used for Leaflet map (good pattern to replicate for modal-heavy UI).","line":1,"sources":[{"source":"chatgpt","file":"performance-chatgpt.jsonl","original_fingerprint":"Bundle Size::components::framer_motion_wide_import"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0014","status":"CONFIRMED"}
{"category":"Rendering","title":"AdminCrudTable filters items on every render without memoization or debounced input","fingerprint":"Rendering::components/admin/admin-crud-table.tsx::unmemoized_filter","severity":"S2","effort":"E1","confidence":90,"files":["components/admin/admin-crud-table.tsx"],"symbols":["AdminCrudTable","filteredItems"],"performance_details":{"current_metric":"filteredItems computed via items.filter(...) each render; searchTerm changes trigger full scan","expected_improvement":"5–20% better typing responsiveness and lower CPU on large admin datasets (depends on item count)","affected_metric":"INP"},"optimization":{"description":"Wrap filtering in useMemo keyed on [items, searchTerm, filters]; debounce searchTerm updates; precompute lowercased searchable fields if needed.","code_example":"const filteredItems = useMemo(() => {\n  const q = searchTerm.toLowerCase();\n  return items.filter(i => /* ... */);\n}, [items, searchTerm, filters, config.searchFields]);\n","verification":["Profile render commits while typing in search box; verify reduced re-render time.","Confirm UI results remain correct with memoized filtering."]},"evidence":["components/admin/admin-crud-table.tsx:91-116 filteredItems = items.filter(...) computed inline"],"notes":"This compounds with the unbounded getDocs issue; fixing both yields the best gain.","line":92,"sources":[{"source":"chatgpt","file":"performance-chatgpt.jsonl","original_fingerprint":"Rendering::components/admin/admin-crud-table.tsx::unmemoized_filter"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0015","status":"CONFIRMED"}
{"category":"Data Fetching","title":"DailySloganWidget fetches entire slogans collection on mount (no limit/caching)","fingerprint":"Data Fetching::components/growth/DailySloganWidget.tsx::fetch_all_then_pick","severity":"S2","effort":"E1","confidence":95,"files":["components/growth/DailySloganWidget.tsx"],"symbols":["DailySloganWidget","fetchDailySlogan"],"performance_details":{"current_metric":"getDocs(collection('slogans')) then selects one slogan client-side","expected_improvement":"5–15% faster widget load + reduced reads; bigger gains as slogans collection grows","affected_metric":"render"},"optimization":{"description":"Fetch only what you need: store \"current slogan\" doc, or query scheduled slogans with constraints; cache result for session/day; optionally move selection to Cloud Function or a single doc updated periodically.","code_example":"// Option: single doc\nconst docRef = doc(db,'slogans','current');\nconst snap = await getDoc(docRef);\n","verification":["Confirm number of docs read is 1 (or small bounded set).","Widget still rotates correctly 3x/day."]},"evidence":["components/growth/DailySloganWidget.tsx:25-27 collection(db,'slogans'); await getDocs(slogansRef);"],"notes":"This matches a common AI anti-pattern: fetch-all then compute locally.","line":26,"sources":[{"source":"chatgpt","file":"performance-chatgpt.jsonl","original_fingerprint":"Data Fetching::components/growth/DailySloganWidget.tsx::fetch_all_then_pick"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0016","status":"CONFIRMED"}
{"category":"Offline Support","title":"UI claims offline writes will sync, but no persistence/queue implementation is evident","fingerprint":"Offline Support::components/status/offline-indicator.tsx::sync_claim_without_queue","severity":"S2","effort":"E2","confidence":85,"files":["components/status/offline-indicator.tsx"],"symbols":["OfflineIndicator"],"performance_details":{"current_metric":"Offline banner states changes will sync; codebase shows offline detection but no IndexedDB persistence enablement or write-queue state","expected_improvement":"Fewer failed writes/retries + better UX under flaky networks; avoids repeated network retries that degrade INP","affected_metric":"INP"},"optimization":{"description":"Either (A) implement offline persistence/queue: enable Firestore IndexedDB persistence (where supported), track pending writes + UI state, and reconcile on reconnect; or (B) change banner text to reflect actual behavior and surface failure states for writes.","code_example":"// If choosing Firestore persistence (browser only)\n// enableIndexedDbPersistence(db).catch(() => {/* fallback */});\n","verification":["Follow offline test recipe: create entry offline, see pending state; reconnect and verify single sync without duplicates.","Confirm no infinite retry loops when offline."]},"evidence":["components/status/offline-indicator.tsx:46 text: \"Offline - changes will sync when reconnected\"","grep for enableIndexedDbPersistence/persistentLocalCache returned no matches in app/components/hooks/lib"],"notes":"This is both a UX correctness issue and a potential performance issue if retries are naive elsewhere.","line":46,"sources":[{"source":"chatgpt","file":"performance-chatgpt.jsonl","original_fingerprint":"Offline Support::components/status/offline-indicator.tsx::sync_claim_without_queue"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0017","status":"CONFIRMED"}
{"category":"Bundle Size","title":"Leaflet + react-leaflet loaded eagerly despite being used in one component","fingerprint":"Bundle Size::components/maps/meeting-map.tsx::leaflet_not_lazy","severity":"S2","effort":"E0","confidence":95,"files":["components/maps/meeting-map.tsx","components/notebook/pages/resources-page.tsx"],"line":1,"symbols":["MeetingMap","leaflet","react-leaflet"],"performance_details":{"current_metric":"Leaflet (~40KB) + react-leaflet + leaflet.markercluster loaded in meeting-map.tsx. MeetingMap IS dynamically imported in resources-page.tsx:103 - but leaflet CSS/JS may still be bundled.","expected_improvement":"Leaflet libraries excluded from initial bundle for non-map pages","affected_metric":"bundle"},"optimization":{"description":"MeetingMap is already dynamically imported in resources-page.tsx (line 103), which is good. Verify that leaflet CSS is also lazily loaded (not in globals.css). Confirm tree-shaking works for leaflet.markercluster.","verification":["Check that leaflet JS is not in the initial page chunks using bundle analyzer","Verify leaflet CSS is loaded dynamically, not in globals.css"]},"evidence":["components/notebook/pages/resources-page.tsx:103: const MeetingMap = dynamic(() => import('@/components/maps/meeting-map'), { loading: () => null, ssr: false })","Only 1 component file imports leaflet directly"],"sources":[{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"Bundle Size::components/maps/meeting-map.tsx::leaflet_not_lazy"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0018","status":"CONFIRMED"}
{"category":"Rendering","title":"37 components import framer-motion without code splitting","fingerprint":"Rendering::components::framer_motion_widespread","severity":"S2","effort":"E2","confidence":80,"files":["components/journal/entry-card.tsx","components/journal/entry-forms/mood-form.tsx","components/notebook/book-cover.tsx","components/notebook/notebook-shell.tsx"],"line":1,"symbols":["motion","AnimatePresence"],"performance_details":{"current_metric":"37 component files import from framer-motion. This ensures the entire framer-motion library is in the critical path regardless of which page loads.","expected_improvement":"Reduced initial JS parse time by deferring animation library for below-fold components","affected_metric":"INP"},"optimization":{"description":"Framer Motion is imported in 37 files spanning journal forms, entry cards, notebook shell, celebrations, growth cards, widgets, and onboarding. While the landing page legitimately needs it for the book cover animation, journal entry forms and growth cards could use CSS animations instead or lazy-load the framer-motion dependency.","verification":["Check bundle analyzer to see framer-motion's contribution to initial load","Test that replacing framer-motion with CSS transitions on entry-card.tsx doesn't regress UX"]},"evidence":["37 files import from 'framer-motion' including: entry-card.tsx, all 5 entry forms, growth cards, widgets, celebrations, notebook shell","entry-card.tsx uses motion.div for simple fade-in that could be CSS"],"sources":[{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"Rendering::components::framer_motion_widespread"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0019","status":"CONFIRMED"}
{"category":"Offline Support","title":"No offline write queue - writes fail silently when offline","fingerprint":"Offline Support::components/status/offline-indicator.tsx::no_write_queue","severity":"S2","effort":"E3","confidence":90,"files":["components/status/offline-indicator.tsx","hooks/use-journal.ts"],"line":6,"symbols":["OfflineIndicator","useJournal"],"performance_details":{"current_metric":"OfflineIndicator shows 'changes will sync when reconnected' but there is no actual sync queue. No IndexedDB or localStorage queue for offline writes. Cloud Function calls (useJournal.addEntry) will fail with network error when offline, and the error is surfaced to user but data is lost.","expected_improvement":"Implementing an offline queue would prevent data loss during network interruptions","affected_metric":"render"},"optimization":{"description":"The OfflineIndicator at line 47 claims 'changes will sync when reconnected' but useJournal.addEntry calls Cloud Functions which require network. No IndexedDB/localStorage queue exists. Options: (1) Queue writes in localStorage/IndexedDB when offline, (2) Use Firestore's built-in offline persistence for direct writes (but writes go through Cloud Functions, not direct), (3) At minimum, update the offline message to accurately reflect behavior.","verification":["Go offline in DevTools, create a journal entry, verify behavior","Check if data is lost or queued"]},"evidence":["components/status/offline-indicator.tsx:47: 'Offline - changes will sync when reconnected'","hooks/use-journal.ts:354: retryCloudFunction(saveJournalEntry, ...) - requires network","grep for indexedDB/localStorage: no write queue found in hooks/ or lib/","5 files reference navigator.onLine but none implement write queuing"],"sources":[{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"Offline Support::components/status/offline-indicator.tsx::no_write_queue"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0020","status":"CONFIRMED"}
{"category":"Data Fetching","title":"Meetings-by-day query fetches entire day without limit or pagination","fingerprint":"Data Fetching::lib/db/meetings.ts::unbounded-query","severity":"S2","effort":"E1","confidence":80,"files":["lib/db/meetings.ts"],"symbols":["MeetingsService.getMeetingsByDay"],"performance_details":{"current_metric":"getMeetingsByDay uses a where() query without limit(), then sorts client-side.","expected_improvement":"Reduce Firestore read volume and client processing time for meeting-heavy days by adding limit/pagination or server-side time windowing.","affected_metric":"memory"},"optimization":{"description":"Add limit() and paginate by time or use a time window query (e.g., upcoming meetings). Prefer indexed orderBy('time') once index is available.","verification":["Check Firestore read counts before/after","Profile client CPU during meeting fetch"]},"evidence":["getMeetingsByDay builds a query with where('day','==',day) but no limit() and fetches all docs before sorting."],"line":106,"sources":[{"source":"codex","file":"performance-codex.jsonl","original_fingerprint":"Data Fetching::lib/db/meetings.ts::unbounded-query"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0021","status":"CONFIRMED"}
{"category":"Core Web Vitals","title":"Global next/image optimization disabled","fingerprint":"Core Web Vitals::next.config.mjs::images-unoptimized","severity":"S2","effort":"E1","confidence":80,"files":["next.config.mjs"],"symbols":["nextConfig"],"performance_details":{"current_metric":"next/image optimization is disabled via images.unoptimized=true.","expected_improvement":"Enable image optimization (or a custom loader) to reduce LCP and bandwidth on image-heavy routes.","affected_metric":"LCP"},"optimization":{"description":"If static export constraints require unoptimized, consider a custom image loader or pre-optimized images. Otherwise, remove unoptimized: true.","verification":["Compare image payload sizes before/after","Lighthouse LCP improvements"]},"evidence":["next.config.mjs sets images.unoptimized to true."],"line":12,"sources":[{"source":"codex","file":"performance-codex.jsonl","original_fingerprint":"Core Web Vitals::next.config.mjs::images-unoptimized"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0022","status":"CONFIRMED"}
{"category":"Bundle Size","title":"Tabs Array Recreated on Every Render","fingerprint":"Rendering::notebook-shell.tsx::array_recreation","severity":"S2","effort":"E0","confidence":95,"files":["components/notebook/notebook-shell.tsx"],"line":146,"symbols":["NotebookShell","tabs"],"performance_details":{"current_metric":"Array with 7 items recreated every render","expected_improvement":"Eliminate 6-10 unnecessary renders per second","affected_metric":"render"},"optimization":{"description":"Wrap tabs array creation in useMemo to prevent recreation on every render","code_example":"const tabs = useMemo(() => notebookModules.map((module) => ({\n  id: module.id,\n  label: module.label,\n  color: module.color,\n  planned: moduleIsStubbed(module),\n})), []);","verification":["Use React DevTools Profiler to measure render count","Verify tabs array reference stays stable"]},"evidence":["notebook-shell.tsx:146-151 - tabs created in component body"],"notes":"Quick win - 5 minute fix","sources":[{"source":"copilot","file":"performance-copilot.jsonl","original_fingerprint":"Rendering::notebook-shell.tsx::array_recreation"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0023","status":"CONFIRMED"}
{"category":"Rendering","title":"Lined Paper Divs Created in Render","fingerprint":"Rendering::notebook-shell.tsx::dom_array_creation","severity":"S2","effort":"E1","confidence":100,"files":["components/notebook/notebook-shell.tsx"],"line":245,"symbols":["NotebookShell"],"performance_details":{"current_metric":"25 DOM elements created every render","expected_improvement":"Zero re-renders for static decorations","affected_metric":"render"},"optimization":{"description":"Replace JavaScript-generated lines with CSS repeating-linear-gradient","code_example":"// CSS approach:\n.notebook-lines {\n  background-image: repeating-linear-gradient(\n    to bottom,\n    transparent 0px,\n    transparent 21px,\n    rgba(186, 230, 253, 0.3) 22px\n  );\n}","verification":["Use React DevTools to verify DOM count reduction","Measure render performance"]},"evidence":["notebook-shell.tsx:244-251 - [...Array(25)].map creates new array + 25 divs per render"],"sources":[{"source":"copilot","file":"performance-copilot.jsonl","original_fingerprint":"Rendering::notebook-shell.tsx::dom_array_creation"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0024","status":"CONFIRMED"}
{"category":"Rendering","title":"Touch Handlers Recreated on Every Render","fingerprint":"Rendering::notebook-shell.tsx::inline_handlers","severity":"S2","effort":"E0","confidence":95,"files":["components/notebook/notebook-shell.tsx"],"line":262,"symbols":["NotebookShell"],"performance_details":{"current_metric":"3 touch handlers recreated every render","expected_improvement":"Stable function references, reduced re-renders","affected_metric":"INP"},"optimization":{"description":"Wrap touch handlers in useCallback to prevent recreation","code_example":"const handleTouchStart = useCallback((e: TouchEvent) => {\n  setTouchEnd(null);\n  setTouchStart(e.targetTouches[0].clientX);\n}, []);","verification":["Verify function reference stability with React DevTools","Test touch gestures still work"]},"evidence":["notebook-shell.tsx:262-270 - inline arrow functions in onTouchStart, onTouchMove, onTouchEnd"],"sources":[{"source":"copilot","file":"performance-copilot.jsonl","original_fingerprint":"Rendering::notebook-shell.tsx::inline_handlers"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0025","status":"CONFIRMED"}
{"category":"Rendering","title":"AccountSecuritySection Not Memoized","fingerprint":"Rendering::notebook-shell.tsx::missing_memo","severity":"S2","effort":"E0","confidence":90,"files":["components/notebook/notebook-shell.tsx"],"line":49,"symbols":["AccountSecuritySection"],"performance_details":{"current_metric":"Re-renders on every notebook shell update","expected_improvement":"Eliminate unnecessary re-renders when props unchanged","affected_metric":"render"},"optimization":{"description":"Wrap component in React.memo","verification":["Use React DevTools Profiler to verify render count","Test conditional rendering still works"]},"evidence":["notebook-shell.tsx:49-98 - functional component without memo"],"sources":[{"source":"copilot","file":"performance-copilot.jsonl","original_fingerprint":"Rendering::notebook-shell.tsx::missing_memo"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0026","status":"CONFIRMED"}
{"category":"Rendering Performance","title":"High-frequency re-renders during typing in RecoveryNotepad","fingerprint":"Rendering::components/notebook/pages/today-page.tsx::typing_rerender","severity":"S2","effort":"E1","confidence":95,"files":["components/notebook/pages/today-page.tsx"],"symbols":["TodayPage","RecoveryNotepad"],"performance_details":{"current_metric":"Re-render per keystroke","expected_improvement":"Re-render only on debounce","affected_metric":"INP"},"optimization":{"description":"Isolate the notepad state into the child component or separate component, and only bubble up changes on blur or debounce.","verification":["React DevTools Profiler: Type in notepad, observe parent render count"]},"evidence":["components/notebook/pages/today-page.tsx:350"],"line":350,"sources":[{"source":"jules","file":"performance-jules.jsonl","original_fingerprint":"Rendering::components/notebook/pages/today-page.tsx::typing_rerender"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0027","status":"CONFIRMED"}
{"category":"Data Fetching & Caching","title":"Multiple disjoint fetches for daily logs","fingerprint":"Data Fetching::components/notebook/pages/today-page.tsx::redundant_fetch","severity":"S2","effort":"E2","confidence":100,"files":["components/notebook/pages/today-page.tsx","components/notebook/visualizations/mood-sparkline.tsx"],"symbols":["TodayPage","MoodSparkline"],"performance_details":{"current_metric":"3 separate Firestore reads on load","expected_improvement":"1 consolidated read","affected_metric":"bundle"},"optimization":{"description":"Consolidate getHistory, calculateWeeklyStats (last 7 days), and onSnapshot (today) into a single context provider or hook that shares the data.","verification":["Network tab: Count firestore network requests on page load"]},"evidence":["components/notebook/pages/today-page.tsx:550","components/notebook/visualizations/mood-sparkline.tsx:20"],"line":550,"sources":[{"source":"jules","file":"performance-jules.jsonl","original_fingerprint":"Data Fetching::components/notebook/pages/today-page.tsx::redundant_fetch"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0028","status":"CONFIRMED"}
{"category":"Core Web Vitals","title":"Large background image loads unoptimized","fingerprint":"Core Web Vitals::app/page.tsx::lcp_background","severity":"S2","effort":"E0","confidence":90,"files":["app/page.tsx"],"symbols":["Home"],"performance_details":{"current_metric":"Full JPEG load","expected_improvement":"Optimized WebP/AVIF","affected_metric":"LCP"},"optimization":{"description":"Optimize wood-table.jpg and serve via next/image (once enabled) or use a smaller placeholder/CSS gradient for immediate paint.","verification":["Lighthouse LCP score"]},"evidence":["app/page.tsx:25"],"line":25,"sources":[{"source":"jules","file":"performance-jules.jsonl","original_fingerprint":"Core Web Vitals::app/page.tsx::lcp_background"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0029","status":"CONFIRMED"}
{"category":"Core Web Vitals","title":"Image optimization disabled in Next.js config","fingerprint":"CoreWebVitals::next.config.mjs::image_unoptimized","severity":"P2","effort":"E1","confidence":100,"files":["next.config.mjs"],"symbols":[],"line":12,"performance_details":{"current_metric":"Images served unoptimized","expected_improvement":"30-50% reduction in image payload","affected_metric":"LCP"},"optimization":{"description":"Enable Next.js image optimization by setting unoptimized: false","code_example":"images: { unoptimized: false, formats: ['image/webp', 'image/avif'] }","verification":["Run Lighthouse audit","Check image sizes in Network tab"]},"evidence":["images: { unoptimized: true }"],"notes":"Affects LCP significantly on image-heavy pages","sources":[{"source":"kimi","file":"performance-kimi.jsonl","original_fingerprint":"CoreWebVitals::next.config.mjs::image_unoptimized"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0030","status":"CONFIRMED"}
{"category":"Bundle Size","title":"No code splitting strategy implemented","fingerprint":"BundleSize::app/::no_code_splitting","severity":"P3","effort":"E2","confidence":80,"files":["app/"],"symbols":[],"line":1,"performance_details":{"current_metric":"Single monolithic bundle","expected_improvement":"20-30% faster initial load","affected_metric":"FCP, TTI"},"optimization":{"description":"Implement route-based code splitting with dynamic imports","code_example":"Use dynamic imports for each page section","verification":["Analyze bundle chunks","Verify lazy loading works"]},"evidence":["No dynamic imports observed in codebase"],"notes":"Next.js supports automatic code splitting with dynamic imports","sources":[{"source":"kimi","file":"performance-kimi.jsonl","original_fingerprint":"BundleSize::app/::no_code_splitting"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0031","status":"CONFIRMED"}
{"category":"Rendering","title":"No list virtualization for journal entries","fingerprint":"Rendering::components/journal/entry-feed.tsx::no_virtualization","severity":"P3","effort":"E2","confidence":90,"files":["components/journal/entry-feed.tsx"],"symbols":["EntryFeed"],"line":1,"performance_details":{"current_metric":"All 100 entries rendered in DOM","expected_improvement":"60-80% fewer DOM nodes","affected_metric":"INP"},"optimization":{"description":"Use react-window or react-virtualized for long lists","code_example":"import { FixedSizeList } from 'react-window'","verification":["Check DOM node count","Measure INP with Chrome DevTools"]},"evidence":["QUERY_LIMITS.JOURNAL_MAX = 100 entries"],"notes":"Virtualization only renders visible items","sources":[{"source":"kimi","file":"performance-kimi.jsonl","original_fingerprint":"Rendering::components/journal/entry-feed.tsx::no_virtualization"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0032","status":"CONFIRMED"}
{"category":"Data Fetching","title":"No pagination - only limit() used","fingerprint":"DataFetching::hooks/use-journal.ts::no_pagination","severity":"P3","effort":"E2","confidence":100,"files":["hooks/use-journal.ts"],"symbols":["useJournal"],"line":180,"performance_details":{"current_metric":"100 entries loaded at once","expected_improvement":"Faster initial load with progressive loading","affected_metric":"LCP, data transfer"},"optimization":{"description":"Implement cursor-based pagination with Load More button","code_example":"Use startAfter() for cursor pagination","verification":["Measure initial load time","Check data transfer"]},"evidence":["limit(QUERY_LIMITS.JOURNAL_MAX) - no pagination"],"notes":"Consider infinite scroll or Load More pattern","sources":[{"source":"kimi","file":"performance-kimi.jsonl","original_fingerprint":"DataFetching::hooks/use-journal.ts::no_pagination"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0033","status":"CONFIRMED"}
{"category":"Data Fetching","title":"No stale-while-revalidate caching","fingerprint":"DataFetching::hooks/use-journal.ts::no_swr_caching","severity":"P3","effort":"E2","confidence":90,"files":["hooks/use-journal.ts"],"symbols":["useJournal"],"line":1,"performance_details":{"current_metric":"Fresh fetch on every mount","expected_improvement":"Instant data from cache + background refresh","affected_metric":"Perceived performance"},"optimization":{"description":"Consider SWR or React Query for intelligent caching","code_example":"import useSWR from 'swr'","verification":["Measure time-to-first-content","Check cache hits"]},"evidence":["Direct onSnapshot usage without caching layer"],"notes":"SWR provides stale-while-revalidate out of the box","sources":[{"source":"kimi","file":"performance-kimi.jsonl","original_fingerprint":"DataFetching::hooks/use-journal.ts::no_swr_caching"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0034","status":"CONFIRMED"}
{"category":"Memory","title":"All journal entries held in memory","fingerprint":"Memory::hooks/use-journal.ts::entries_in_state","severity":"P3","effort":"E1","confidence":100,"files":["hooks/use-journal.ts"],"symbols":["entries"],"line":65,"performance_details":{"current_metric":"100 entries in React state","expected_improvement":"Reduced memory footprint","affected_metric":"Memory usage"},"optimization":{"description":"Consider virtualization or pagination to limit in-memory data","code_example":"Use react-window for virtualization","verification":["Measure memory usage in DevTools","Check for memory leaks"]},"evidence":["const [entries, setEntries] = useState<JournalEntry[]>([])"],"notes":"100 entries may be acceptable, but monitor for growth","sources":[{"source":"kimi","file":"performance-kimi.jsonl","original_fingerprint":"Memory::hooks/use-journal.ts::entries_in_state"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0035","status":"CONFIRMED"}
{"category":"Core Web Vitals","title":"No Suspense boundaries for loading states","fingerprint":"CoreWebVitals::app/::no_suspense","severity":"P3","effort":"E1","confidence":80,"files":["app/"],"symbols":[],"line":1,"performance_details":{"current_metric":"No streaming SSR","expected_improvement":"Better perceived loading","affected_metric":"LCP, CLS"},"optimization":{"description":"Add Suspense boundaries around data-dependent components","code_example":"<Suspense fallback={<Skeleton />}><DataComponent /></Suspense>","verification":["Check loading UX","Measure LCP improvement"]},"evidence":["No Suspense usage observed in app directory"],"notes":"Next.js App Router supports React Suspense","sources":[{"source":"kimi","file":"performance-kimi.jsonl","original_fingerprint":"CoreWebVitals::app/::no_suspense"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0036","status":"CONFIRMED"}
{"category":"AI Performance Patterns","title":"Full documents fetched without field selection","fingerprint":"AIPerformance::hooks/use-journal.ts::no_field_selection","severity":"P3","effort":"E1","confidence":90,"files":["hooks/use-journal.ts"],"symbols":["onSnapshot"],"line":175,"performance_details":{"current_metric":"All document fields fetched","expected_improvement":"20-40% less data transfer","affected_metric":"Data usage, load time"},"optimization":{"description":"Select only needed fields in Firestore queries","code_example":"Use query constraints to limit fields if possible","verification":["Measure data transfer","Check Firestore usage"]},"evidence":["onSnapshot fetches entire document"],"notes":"Firestore doesn't support field selection in queries directly","sources":[{"source":"kimi","file":"performance-kimi.jsonl","original_fingerprint":"AIPerformance::hooks/use-journal.ts::no_field_selection"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0037","status":"CONFIRMED"}
{"category":"Bundle Size","title":"Overall JS chunk sizes and route-level bundle split unknown (needs next build output + analyzer)","fingerprint":"Bundle Size::next_build::unknown_chunk_sizes","severity":"S2","effort":"E2","confidence":40,"files":["package.json","next.config.mjs"],"symbols":["nextConfig"],"performance_details":{"current_metric":"No measured .next/static/chunks output in this environment","expected_improvement":"Varies; typically 10–30% by splitting heavy routes and trimming deps","affected_metric":"bundle"},"optimization":{"description":"Run production build and bundle analyzer; identify top chunks; split heavy routes (admin/notebook/maps) and lazy-load modals and optional widgets.","code_example":"// next.config.mjs\n// withBundleAnalyzer({ enabled: process.env.ANALYZE === 'true' })","verification":["Run build + analyzer; record top 20 chunks and compare after changes."]},"evidence":["Repo contains next build script but build artifacts not generated here"],"notes":"Needs real build to confirm magnitude.","line":1,"sources":[{"source":"chatgpt-suspected","file":"performance-chatgpt-suspected.jsonl","original_fingerprint":"Bundle Size::next_build::unknown_chunk_sizes"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0038","status":"SUSPECTED"}
{"category":"Core Web Vitals","title":"Real LCP/INP/CLS values unknown (needs Lighthouse against deployed Firebase Hosting)","fingerprint":"Core Web Vitals::lighthouse::needs_measurement","severity":"S2","effort":"E1","confidence":40,"files":["package.json"],"symbols":["lighthouse script"],"performance_details":{"current_metric":"Baseline metrics not recorded","expected_improvement":"Depends on findings applied; likely measurable gains on INP and LCP","affected_metric":"LCP"},"optimization":{"description":"Run Lighthouse (desktop+mobile) on deployed site; capture LCP element, TBT/INP contributors, and CLS sources; repeat after fixes.","code_example":"npm run lighthouse\nnpm run lighthouse:desktop\n","verification":["Store JSON reports; compare before/after deltas for LCP/INP/CLS and main-thread work."]},"evidence":["package.json includes scripts \"lighthouse\" and \"lighthouse:desktop\" but no reports committed"],"notes":"Must be run in an environment with Chrome + deploy URL.","line":1,"sources":[{"source":"chatgpt-suspected","file":"performance-chatgpt-suspected.jsonl","original_fingerprint":"Core Web Vitals::lighthouse::needs_measurement"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0039","status":"SUSPECTED"}
{"category":"Bundle Size","title":"626KB largest chunk likely contains Firebase + Framer Motion","fingerprint":"Bundle Size::out/_next/static/chunks::largest_chunk_626k","severity":"S2","effort":"E2","confidence":75,"files":["package.json"],"line":91,"symbols":["firebase","framer-motion"],"performance_details":{"current_metric":"Largest JS chunk: 626KB. Top 5 chunks: 626KB, 357KB, 277KB, 253KB, 218KB. Total static JS: 3.4MB across 42 chunks.","expected_improvement":"20-40% reduction in initial JS by lazy-loading firebase/firestore and framer-motion modules","affected_metric":"LCP"},"optimization":{"description":"Firebase SDK (firebase: ^12.6.0) and Framer Motion (framer-motion: ^12.23.0) are heavy libraries. Firebase is imported in 37+ files. Framer Motion is imported in 37 component files. Consider: (1) dynamic imports for Framer Motion components not visible on initial load, (2) ensure Firebase modular tree-shaking is effective by avoiding re-exports through barrel files.","code_example":"// Lazy-load framer-motion for components below the fold:\nconst MotionDiv = dynamic(() => import('framer-motion').then(m => m.motion.div), { ssr: false });","verification":["Run npx @next/bundle-analyzer to identify which libraries are in which chunks","Compare largest chunk size before and after optimization"]},"evidence":["out/_next/static/chunks/620b5119fa2b0078.js: 626KB","37 files import framer-motion","firebase imported in 37+ files across codebase","Total static output: 3.4MB JS across 42 chunks"],"sources":[{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"Bundle Size::out/_next/static/chunks::largest_chunk_626k"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0040","status":"SUSPECTED"}
{"category":"Data Fetching","title":"onSnapshot real-time listener on journal fetches up to 100 docs on every change","fingerprint":"Data Fetching::hooks/use-journal.ts::onSnapshot_full_refetch","severity":"S2","effort":"E2","confidence":70,"files":["hooks/use-journal.ts"],"line":284,"symbols":["useJournal","onSnapshot"],"performance_details":{"current_metric":"onSnapshot listener on journal collection (limit 100) processes ALL 100 documents on every change, even if only 1 document changed. Firestore sends full query result on each update.","expected_improvement":"Incremental updates using docChanges() instead of full snapshot processing could reduce processing by 90%+ for single-doc changes","affected_metric":"render"},"optimization":{"description":"The onSnapshot callback at line 284 iterates over snapshot.forEach(doc => processJournalDoc(doc.id, doc.data())). When a single entry is added/modified, Firestore still sends all 100 docs. Use snapshot.docChanges() to only process added/modified/removed docs incrementally.","code_example":"const unsubscribe = onSnapshot(q, (snapshot) => {\n  snapshot.docChanges().forEach((change) => {\n    if (change.type === 'added') { /* add to state */ }\n    if (change.type === 'modified') { /* update in state */ }\n    if (change.type === 'removed') { /* remove from state */ }\n  });\n});","verification":["Log docChanges().length vs snapshot.size to measure savings","Profile React re-renders before and after"]},"evidence":["hooks/use-journal.ts:284-308: onSnapshot processes full snapshot on every change","hooks/use-journal.ts:280: limit(QUERY_LIMITS.JOURNAL_MAX) - JOURNAL_MAX likely 100","hooks/use-journal.ts:294: setEntries(fetchedEntries) - replaces entire array on each update"],"notes":"Firestore SDK does local caching, so bandwidth is minimal, but JS processing of 100 docs + React reconciliation on every change is wasteful.","sources":[{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"Data Fetching::hooks/use-journal.ts::onSnapshot_full_refetch"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0041","status":"SUSPECTED"}
{"category":"Data Fetching","title":"today-page.tsx has 10 useEffect hooks - potential waterfall fetching","fingerprint":"Data Fetching::components/notebook/pages/today-page.tsx::many_effects","severity":"S2","effort":"E2","confidence":65,"files":["components/notebook/pages/today-page.tsx"],"line":1,"symbols":["TodayPage"],"performance_details":{"current_metric":"today-page.tsx contains 10 useEffect hooks. If these contain sequential data fetches, they create a waterfall. The file also imports 11 useMemo/useCallback/memo instances suggesting complex derived state.","expected_improvement":"Consolidating effects and parallelizing fetches could reduce page load time by 200-500ms","affected_metric":"LCP"},"optimization":{"description":"Audit the 10 useEffect hooks in today-page.tsx. Consolidate related effects. Ensure data fetches happen in parallel (Promise.all) rather than sequentially. The component already imports TodayPageSkeleton for loading states, which is good.","verification":["Profile today-page render in React DevTools to identify waterfall patterns","Check if reducing effects reduces re-render count"]},"evidence":["today-page.tsx: 10 useEffect occurrences (highest of any component)","today-page.tsx: 11 useMemo/useCallback/memo usages","Imports from 14 different modules suggesting high complexity"],"sources":[{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"Data Fetching::components/notebook/pages/today-page.tsx::many_effects"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0042","status":"SUSPECTED"}
{"category":"Bundle Size","title":"Leaflet + markercluster dependencies may dominate map chunk size","fingerprint":"Bundle Size::package.json::leaflet-heavy-chunk","severity":"S2","effort":"E1","confidence":35,"files":["package.json","components/maps/meeting-map.tsx"],"symbols":["MeetingMap"],"performance_details":{"current_metric":"Leaflet/markercluster dependencies can add a large chunk to the map route bundle.","expected_improvement":"Smaller map chunk by tree-shaking or splitting CSS/assets.","affected_metric":"bundle"},"optimization":{"description":"Audit map chunk size and consider code-splitting CSS/assets or using a lighter map implementation.","verification":["Analyze map route chunk via bundle analyzer"]},"evidence":["Leaflet and markercluster are dependencies and MeetingMap imports leaflet CSS and clustering."],"notes":"Needs bundle analyzer to confirm chunk contribution.","line":93,"sources":[{"source":"codex-suspected","file":"performance-codex-suspected.jsonl","original_fingerprint":"Bundle Size::package.json::leaflet-heavy-chunk"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0043","status":"SUSPECTED"}
{"category":"Bundle Size","title":"Entire /meetings/all route is client-only, inflating JS payload","fingerprint":"Bundle Size::app/meetings/all/page.tsx::client-only-route","severity":"S2","effort":"E2","confidence":70,"files":["app/meetings/all/page.tsx"],"symbols":["AllMeetingsPage"],"performance_details":{"current_metric":"Route hydrates full client bundle for filtering, map toggle, and list UI.","expected_improvement":"Reduce initial JS and hydration cost for /meetings/all by splitting static shell into a Server Component and deferring client-only subtrees.","affected_metric":"bundle"},"optimization":{"description":"Split static header/layout into a Server Component and move only interactive filters/list/map into a client subcomponent. Keep the dynamic map import but avoid pulling non-interactive markup into client scope.","code_example":"// app/meetings/all/page.tsx (server)\n// import MeetingsClient from './meetings-client'\n// return <MeetingsClient />","verification":["next build --profile and compare route JS size before/after","Check hydration timing with React DevTools Profiler"]},"evidence":["app/meetings/all/page.tsx is marked \"use client\" at the top of the route file, forcing full client rendering."],"notes":"Dynamic map import is already used, but the route still hydrates all layout/filter UI.","line":1,"sources":[{"source":"codex","file":"performance-codex.jsonl","original_fingerprint":"Bundle Size::app/meetings/all/page.tsx::client-only-route"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0044","status":"SUSPECTED"}
{"category":"Rendering","title":"Journal entry feed renders full grouped list without virtualization","fingerprint":"Rendering::components/journal/entry-feed.tsx::no-virtualization","severity":"S2","effort":"E2","confidence":75,"files":["components/journal/entry-feed.tsx"],"symbols":["EntryFeed","EntryCard"],"performance_details":{"current_metric":"All grouped entries are mapped into the DOM with per-entry click handlers; no windowing or pagination.","expected_improvement":"Reduce render cost and improve INP on large journals by virtualizing or paginating entry cards.","affected_metric":"render"},"optimization":{"description":"Implement list virtualization (e.g., react-virtual) or add pagination/infinite scroll to cap rendered EntryCard count.","verification":["Profile render time in React DevTools with >100 entries","Measure INP before/after virtualization"]},"evidence":["EntryFeed maps all grouped entries into a grid without virtualization and renders EntryCard for each item."],"line":314,"sources":[{"source":"codex","file":"performance-codex.jsonl","original_fingerprint":"Rendering::components/journal/entry-feed.tsx::no-virtualization"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0045","status":"SUSPECTED"}
{"category":"Data Fetching","title":"Sober living list loads entire collection without limit/pagination","fingerprint":"Data Fetching::lib/db/sober-living.ts::unbounded-query","severity":"S2","effort":"E1","confidence":75,"files":["lib/db/sober-living.ts"],"symbols":["SoberLivingService.getAllHomes"],"performance_details":{"current_metric":"getAllHomes queries the full sober_living collection with no limit() or pagination.","expected_improvement":"Lower read volume and faster list rendering by paginating or filtering server-side.","affected_metric":"memory"},"optimization":{"description":"Add limit() with cursor pagination and apply search/filter parameters at query time instead of client-side.","verification":["Firestore read counts for sober_living","Measure render time with large dataset"]},"evidence":["getAllHomes uses getDocs(query(collection(...))) without limit() or pagination."],"line":30,"sources":[{"source":"codex","file":"performance-codex.jsonl","original_fingerprint":"Data Fetching::lib/db/sober-living.ts::unbounded-query"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0046","status":"SUSPECTED"}
{"category":"AI Performance Patterns","title":"Resources page fetches all meetings via deprecated API then filters client-side","fingerprint":"AI Performance Patterns::components/notebook/pages/resources-page.tsx::fetch-all-then-filter","severity":"S2","effort":"E1","confidence":75,"files":["components/notebook/pages/resources-page.tsx"],"symbols":["triggerRefresh"],"performance_details":{"current_metric":"When viewMode === 'all', the page calls getAllMeetings() and filters/sorts on the client.","expected_improvement":"Avoid fetch-all patterns by using paginated API and server-side filtering; reduces payload size and CPU.","affected_metric":"render"},"optimization":{"description":"Replace getAllMeetings() usage with getAllMeetingsPaginated() and apply filters server-side. Add load-more for large datasets.","verification":["Confirm no calls to getAllMeetings() in resources page","Measure render time and payload size"]},"evidence":["triggerRefresh() calls MeetingsService.getAllMeetings() when viewMode is 'all'."],"line":668,"sources":[{"source":"codex","file":"performance-codex.jsonl","original_fingerprint":"AI Performance Patterns::components/notebook/pages/resources-page.tsx::fetch-all-then-filter"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0047","status":"SUSPECTED"}
{"category":"Core Web Vitals","title":"Landing page background image bypasses next/image optimization","fingerprint":"Core Web Vitals::app/page.tsx::css-background-lcp","severity":"S2","effort":"E1","confidence":70,"files":["app/page.tsx"],"symbols":["Home"],"performance_details":{"current_metric":"Hero background uses CSS backgroundImage without responsive sizing or priority hints.","expected_improvement":"Improve LCP by converting to next/image (or preloading the background asset with appropriate sizes).","affected_metric":"LCP"},"optimization":{"description":"Replace CSS background with a next/image component or add a preload hint for the hero asset and serve appropriately sized variants.","verification":["Lighthouse LCP delta before/after","Check network waterfall for hero asset"]},"evidence":["Landing page sets backgroundImage to /images/wood-table.jpg via inline style."],"line":23,"sources":[{"source":"codex","file":"performance-codex.jsonl","original_fingerprint":"Core Web Vitals::app/page.tsx::css-background-lcp"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0048","status":"SUSPECTED"}
{"category":"Bundle Size & Loading","title":"Framer Motion tree-shaking efficacy","fingerprint":"Bundle Size::package.json::framer_motion","severity":"S2","effort":"E1","confidence":40,"files":["package.json"],"symbols":["framer-motion"],"performance_details":{"current_metric":"Unknown","expected_improvement":"Reduced bundle size","affected_metric":"bundle"},"optimization":{"description":"Verify if framer-motion features are being tree-shaken. Use LazyMotion to reduce initial bundle size.","verification":["Bundle analyzer report"]},"evidence":["package.json:dependencies"],"line":1,"sources":[{"source":"jules-suspected","file":"performance-jules-suspected.jsonl","original_fingerprint":"Bundle Size::package.json::framer_motion"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0049","status":"SUSPECTED"}
{"category":"Bundle Size","title":"No dynamic imports for heavy components","fingerprint":"BundleSize::components/analytics/*::no_dynamic_imports","severity":"P2","effort":"E1","confidence":75,"files":["components/analytics/*","components/maps/*"],"symbols":["Recharts","LeafletMap"],"line":1,"performance_details":{"current_metric":"All JS loaded on initial page load","expected_improvement":"100-150kb reduction in initial bundle","affected_metric":"TTI"},"optimization":{"description":"Use dynamic imports for Recharts and Leaflet components","code_example":"const Chart = dynamic(() => import('./Chart'), { ssr: false })","verification":["Analyze bundle with @next/bundle-analyzer","Verify chunks loaded on demand"]},"evidence":["recharts: 2.15.4 (~70kb)","leaflet: ^1.9.4 (~40kb)","framer-motion: 12.23.0 (~40kb)"],"notes":"Heavy libraries loaded even when not immediately needed","sources":[{"source":"kimi","file":"performance-kimi.jsonl","original_fingerprint":"BundleSize::components/analytics/*::no_dynamic_imports"}],"verified":false,"consensus_score":1,"canonical_id":"CANON-0050","status":"SUSPECTED"}
{"category":"Rendering","title":"Journal entry forms eagerly rendered in JournalHub","fingerprint":"Rendering::components/journal/journal-hub.tsx::eager_forms","severity":"S3","effort":"E1","confidence":85,"files":["components/journal/journal-hub.tsx"],"line":101,"symbols":["MoodForm","GratitudeForm","InventoryForm","DailyLogForm","FreeWriteForm"],"performance_details":{"current_metric":"5 entry form components (MoodForm, GratitudeForm, InventoryForm, DailyLogForm, FreeWriteForm) are statically imported at the top of journal-hub.tsx and conditionally rendered. Their JS is parsed even when forms aren't open.","expected_improvement":"Reduced initial JS parse for journal page by deferring form components until user clicks 'new entry'","affected_metric":"INP"},"optimization":{"description":"Use dynamic imports for the 5 entry form components since they're only shown when the user explicitly creates a new entry. This defers their JS parsing until needed.","code_example":"const MoodForm = dynamic(() => import('./entry-forms/mood-form').then(m => ({ default: m.MoodForm })), { ssr: false });\nconst GratitudeForm = dynamic(() => import('./entry-forms/gratitude-form').then(m => ({ default: m.GratitudeForm })), { ssr: false });","verification":["Verify form components are in separate chunks in bundle analyzer","Confirm forms still load quickly when user clicks 'new entry'"]},"evidence":["components/journal/journal-hub.tsx:15-19: Static imports of MoodForm, GratitudeForm, InventoryForm, FreeWriteForm, DailyLogForm","components/journal/journal-hub.tsx:101-134: Conditionally rendered based on activeEntryType state"],"sources":[{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"Rendering::components/journal/journal-hub.tsx::eager_forms"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0051","status":"CONFIRMED"}
{"category":"Core Web Vitals","title":"No Suspense boundaries in app routes","fingerprint":"Core Web Vitals::app::no_suspense","severity":"S3","effort":"E1","confidence":90,"files":["app/page.tsx","app/journal/page.tsx","app/admin/page.tsx"],"line":1,"symbols":["Home","JournalPage"],"performance_details":{"current_metric":"Zero Suspense boundaries found in any app/ route file. Loading states are handled per-component (e.g., JournalHub shows a spinner) rather than via React Suspense.","expected_improvement":"Suspense boundaries would enable streaming and progressive rendering, improving perceived load time","affected_metric":"LCP"},"optimization":{"description":"Add Suspense boundaries around heavy client components in app routes. This enables React to show fallback UI immediately while heavy components load. Since this is a static export, streaming SSR isn't available, but Suspense still helps with code-split component loading.","code_example":"import { Suspense } from 'react';\n\nexport default function JournalPage() {\n  return (\n    <Suspense fallback={<JournalSkeleton />}>\n      <JournalHub />\n    </Suspense>\n  );\n}","verification":["Add Suspense to journal page, measure time-to-interactive improvement"]},"evidence":["grep for 'Suspense|lazy(' in app/ routes: 0 matches","app/journal/page.tsx: directly renders <JournalHub /> with no Suspense","Loading states are component-internal (journal-hub.tsx:39-45 shows spinner)"],"sources":[{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"Core Web Vitals::app::no_suspense"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0052","status":"CONFIRMED"}
{"category":"Memory","title":"4 real-time onSnapshot listeners active simultaneously","fingerprint":"Memory::hooks::multiple_onSnapshot","severity":"S3","effort":"E1","confidence":80,"files":["hooks/use-journal.ts","components/providers/profile-context.tsx","components/notebook/pages/today-page.tsx","lib/database/firestore-adapter.ts"],"line":284,"symbols":["onSnapshot"],"performance_details":{"current_metric":"4 separate onSnapshot real-time listeners found: (1) use-journal.ts:284 for journal entries, (2) profile-context.tsx:109 for user profile, (3) today-page.tsx:554 for daily log, (4) firestore-adapter.ts:76 for database adapter. All active simultaneously when notebook is open.","expected_improvement":"Consolidating listeners or converting some to one-time fetches could reduce Firestore read costs and memory usage","affected_metric":"memory"},"optimization":{"description":"Evaluate which listeners truly need real-time updates. The user profile (profile-context.tsx) changes rarely and could use getDoc() with manual refresh. The daily log (today-page.tsx) updates only when the user saves, so could refresh after save instead of maintaining a listener.","verification":["Monitor Firestore reads in Firebase Console before and after","Check memory usage in Chrome DevTools with/without listeners"]},"evidence":["hooks/use-journal.ts:284: onSnapshot on journal collection","components/providers/profile-context.tsx:109: onSnapshot on user profile","components/notebook/pages/today-page.tsx:554: onSnapshot on daily log doc","lib/database/firestore-adapter.ts:76: onSnapshot in adapter","All have proper cleanup (return () => unsubscribe())"],"sources":[{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"Memory::hooks::multiple_onSnapshot"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0053","status":"CONFIRMED"}
{"category":"AI Performance Patterns","title":"Client-side filtering of daily logs","fingerprint":"AI Performance Patterns::components/notebook/pages/today-page.tsx::client_filter","severity":"S3","effort":"E1","confidence":85,"files":["components/notebook/pages/today-page.tsx"],"symbols":["calculateWeeklyStats"],"performance_details":{"current_metric":"JS-based filtering","expected_improvement":"Database-level filtering","affected_metric":"memory"},"optimization":{"description":"Refine the Firestore query to return exactly the needed data range, avoiding potential over-fetching if the query is not precise enough.","verification":["Check Firestore query constraints"]},"evidence":["components/notebook/pages/today-page.tsx:600"],"line":600,"sources":[{"source":"jules","file":"performance-jules.jsonl","original_fingerprint":"AI Performance Patterns::components/notebook/pages/today-page.tsx::client_filter"}],"verified":true,"consensus_score":2,"canonical_id":"CANON-0054","status":"CONFIRMED"}
{"category":"Rendering","title":"EntryCard in timeline.tsx creates new arrow functions on each render","fingerprint":"Rendering::components/journal/timeline.tsx::inline_callbacks","severity":"S3","effort":"E1","confidence":35,"files":["components/journal/timeline.tsx"],"line":99,"symbols":["Timeline","EntryCard"],"performance_details":{"current_metric":"timeline.tsx:99 passes onClick={() => setSelectedEntry(entry)} as inline arrow function to EntryCard on every render. If EntryCard uses React.memo, this defeats memoization.","expected_improvement":"Minimal unless EntryCard is memoized - would prevent unnecessary re-renders of entry cards","affected_metric":"render"},"optimization":{"description":"Check if EntryCard is wrapped in React.memo. If so, extract the onClick handler using useCallback or pass entry.id and handle selection in parent.","verification":["Check if EntryCard uses React.memo","Profile re-renders in React DevTools"]},"evidence":["components/journal/timeline.tsx:99: onClick={() => setSelectedEntry(entry)} - inline arrow in map"],"sources":[{"source":"claude-code-suspected","file":"performance-claude-code-suspected.jsonl","original_fingerprint":"Rendering::components/journal/timeline.tsx::inline_callbacks"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0055","status":"SUSPECTED"}
{"category":"Data Fetching","title":"Firestore client-side filtering of soft-deleted entries","fingerprint":"Data Fetching::hooks/use-journal.ts::client_side_filter","severity":"S3","effort":"E1","confidence":30,"files":["hooks/use-journal.ts"],"line":174,"symbols":["processJournalDoc"],"performance_details":{"current_metric":"processJournalDoc (line 174) filters out soft-deleted entries client-side. A Firestore where clause could exclude these server-side, but the code comments explain this avoids a composite index requirement.","expected_improvement":"Marginal - depends on ratio of soft-deleted to total entries","affected_metric":"render"},"optimization":{"description":"Add a composite index for isSoftDeleted + createdAt to enable server-side filtering. This would reduce data transferred for users with many soft-deleted entries.","verification":["Check how many entries are soft-deleted vs total per user"]},"evidence":["hooks/use-journal.ts:174: if (data.isSoftDeleted === true) return null;","hooks/use-journal.ts:275-276: Comment explains composite index avoidance"],"sources":[{"source":"claude-code-suspected","file":"performance-claude-code-suspected.jsonl","original_fingerprint":"Data Fetching::hooks/use-journal.ts::client_side_filter"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0056","status":"SUSPECTED"}
{"category":"Bundle Size","title":"date-fns may not be tree-shaken effectively","fingerprint":"Bundle Size::package.json::date_fns_treeshake","severity":"S3","effort":"E1","confidence":25,"files":["package.json","components/journal/entry-feed.tsx","components/notebook/pages/today-page.tsx"],"line":90,"symbols":["date-fns"],"performance_details":{"current_metric":"date-fns ^4.1.0 is imported in multiple files. date-fns v4 supports tree-shaking natively, but barrel imports like 'import { format, subDays } from \"date-fns\"' may include more than needed depending on bundler config.","expected_improvement":"Potentially 10-20KB savings if using direct path imports","affected_metric":"bundle"},"optimization":{"description":"Verify tree-shaking is effective for date-fns by checking the bundle analyzer. If not, switch to direct path imports: import format from 'date-fns/format'.","verification":["Check date-fns size in bundle analyzer"]},"evidence":["today-page.tsx:7: import { intervalToDuration, subDays, startOfDay, format, differenceInDays } from 'date-fns'","entry-feed.tsx:19: import { format } from 'date-fns'"],"sources":[{"source":"claude-code-suspected","file":"performance-claude-code-suspected.jsonl","original_fingerprint":"Bundle Size::package.json::date_fns_treeshake"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0057","status":"SUSPECTED"}
{"category":"AI Performance Patterns","title":"No recharts dependency despite being listed in scope - charts may be unused","fingerprint":"AI Performance Patterns::package.json::recharts_unused","severity":"S3","effort":"E0","confidence":60,"files":["package.json"],"line":105,"symbols":["recharts"],"performance_details":{"current_metric":"recharts 2.15.4 is in package.json dependencies (~200KB) but grep found 0 files importing from 'recharts' in the codebase. The dependency may be unused or only used in a file not matching the search pattern.","expected_improvement":"Removing unused recharts would save ~200KB from bundle","affected_metric":"bundle"},"optimization":{"description":"Verify whether recharts is actually used anywhere. If not, remove it from package.json to save ~200KB.","code_example":"npm uninstall recharts","verification":["Run npx knip to confirm recharts is unused","After removal, verify build succeeds and no pages break"]},"evidence":["package.json:105: \"recharts\": \"2.15.4\"","grep for 'from [\"']recharts' across *.ts and *.tsx: 0 matches","MoodSparkline component (today-page.tsx:9) might use it but grep found no import"],"sources":[{"source":"claude-code","file":"performance-claude-code.jsonl","original_fingerprint":"AI Performance Patterns::package.json::recharts_unused"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0058","status":"SUSPECTED"}
{"category":"Rendering","title":"High Framer Motion usage across journal/notebook components may increase main-thread work","fingerprint":"Rendering::components/journal::framer-motion-density","severity":"S3","effort":"E1","confidence":30,"files":["components/journal/entry-forms/mood-form.tsx","components/notebook/notebook-shell.tsx"],"symbols":["motion","AnimatePresence"],"performance_details":{"current_metric":"Multiple motion components may add animation and layout cost on lower-end devices.","expected_improvement":"Reduce paint/layout work by trimming animation count or prefers-reduced-motion handling.","affected_metric":"render"},"optimization":{"description":"Profile animation-heavy routes and disable non-critical animations for reduced-motion or low-power mode.","verification":["CPU profiling during animations"]},"evidence":["Several journal/notebook components import framer-motion for animations."],"notes":"Needs profiling to confirm impact.","line":1,"sources":[{"source":"codex-suspected","file":"performance-codex-suspected.jsonl","original_fingerprint":"Rendering::components/journal::framer-motion-density"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0059","status":"SUSPECTED"}
{"category":"Offline Support","title":"Firestore client has no offline persistence or sync queue configured","fingerprint":"Offline Support::lib/firebase.ts::no-offline-persistence","severity":"S3","effort":"E2","confidence":65,"files":["lib/firebase.ts"],"symbols":["initializeFirebase"],"performance_details":{"current_metric":"Firestore initialized without enableIndexedDbPersistence or local cache; offline writes lack durable queue.","expected_improvement":"Enable offline persistence for better offline UX and reduced refetch after reconnect.","affected_metric":"memory"},"optimization":{"description":"Enable Firestore persistence (enableIndexedDbPersistence) and add UI states for pending/synced writes if needed.","verification":["Test offline recipe (create entries offline, reconnect)","Monitor read counts on reconnect"]},"evidence":["Firebase initialization calls getFirestore without persistence configuration."],"line":54,"sources":[{"source":"codex","file":"performance-codex.jsonl","original_fingerprint":"Offline Support::lib/firebase.ts::no-offline-persistence"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0060","status":"SUSPECTED"}
{"category":"Memory","title":"OfflineIndicator timeout is not cleared on unmount","fingerprint":"Memory::components/status/offline-indicator.tsx::timeout-cleanup","severity":"S3","effort":"E0","confidence":70,"files":["components/status/offline-indicator.tsx"],"symbols":["OfflineIndicator"],"performance_details":{"current_metric":"setTimeout is created inside online handler but never cleared, which can trigger state updates after unmount.","expected_improvement":"Avoid potential memory leaks and state updates on unmounted component.","affected_metric":"memory"},"optimization":{"description":"Store timeout id in a ref and clear it in the cleanup function or before setting a new timeout.","verification":["React strict-mode unmount checks","No setState-on-unmounted warnings"]},"evidence":["handleOnline sets a timeout without cleanup on unmount."],"line":11,"sources":[{"source":"codex","file":"performance-codex.jsonl","original_fingerprint":"Memory::components/status/offline-indicator.tsx::timeout-cleanup"}],"verified":true,"consensus_score":1.5,"canonical_id":"CANON-0061","status":"SUSPECTED"}