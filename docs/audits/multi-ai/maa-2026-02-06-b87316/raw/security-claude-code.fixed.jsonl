{"category":"Firebase","title":"App Check disabled on all Cloud Functions","fingerprint":"Firebase::lib/firebase.ts::app_check_disabled","severity":"S1","effort":"E1","confidence":100,"files":["lib/firebase.ts","functions/src/index.ts","functions/src/security-wrapper.ts"],"line":57,"vulnerability_details":{"description":"Firebase App Check initialization is completely commented out in lib/firebase.ts lines 57-91. Every Cloud Function sets requireAppCheck: false in its withSecurityChecks options. This removes the bot-protection layer, allowing automated abuse of all Cloud Function endpoints.","exploitation":"An attacker scripts direct calls to Cloud Functions using the Firebase JS SDK without presenting a valid App Check attestation token. While authentication and rate limiting still apply, there is no bot-detection gate, enabling account-cycling attacks at scale.","impact":"Automated abuse of all 38+ Cloud Function endpoints; potential resource exhaustion via distributed bot attacks that exceed per-user rate limits by cycling anonymous accounts.","affected_data":"All Cloud Function endpoints: saveDailyLog, saveJournalEntry, softDeleteJournalEntry, saveInventoryEntry, migrateAnonymousUserData, and all admin functions"},"suggested_fix":{"steps":["1. Uncomment App Check initialization block in lib/firebase.ts lines 57-91","2. Set requireAppCheck: true in withSecurityChecks options for saveDailyLog (index.ts:84), saveJournalEntry (index.ts:170), softDeleteJournalEntry (index.ts:~270), saveInventoryEntry (index.ts:~365)","3. Re-enable App Check verification in migrateAnonymousUserData (index.ts:506-511)","4. Configure App Check enforcement mode in Firebase Console","5. Test all Cloud Function calls succeed with valid App Check tokens and fail without"],"code_example":"// lib/firebase.ts - uncomment lines 57-91\n// functions/src/index.ts - change to:\nrequireAppCheck: true,","verification":["Verify request.app is non-null for all Cloud Function calls in production","Send a Cloud Function call without App Check token and confirm it returns failed-precondition error","Run full integration test suite after re-enabling"]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":["lib/firebase.ts:57: // TEMPORARILY DISABLED: App Check is disabled due to 24-hour throttle","lib/firebase.ts:58: // Will re-enable after throttle clears (Dec 31, ~01:02 UTC)","functions/src/index.ts:84: requireAppCheck: false, // TEMPORARILY DISABLED - waiting for throttle to clear","functions/src/index.ts:170: requireAppCheck: false, // TEMPORARILY DISABLED - waiting for throttle to clear","functions/src/index.ts:506-511: App Check verification block commented out"],"notes":"Disabled since Dec 31 2025 due to reCAPTCHA throttle. The throttle window is 24 hours; this has been disabled for over 5 weeks.","why_it_matters":"App Check disabled on all Cloud Functions","acceptance_tests":["Verify fix applied correctly"]}
{"category":"Headers","title":"Missing Content-Security-Policy header","fingerprint":"Headers::firebase.json::missing_csp","severity":"S2","effort":"E1","confidence":100,"files":["firebase.json"],"line":6,"vulnerability_details":{"description":"No Content-Security-Policy (CSP) header is configured in firebase.json hosting headers. The headers section (lines 6-58) includes X-Frame-Options, HSTS, X-Content-Type-Options, COOP, Referrer-Policy, and Permissions-Policy but omits CSP entirely.","exploitation":"If an XSS vulnerability is introduced (e.g., via a dependency or future code change), there is no CSP to restrict script execution. An attacker could inject and execute arbitrary JavaScript, exfiltrate user data, or perform actions as the user.","impact":"No defense-in-depth against XSS. React auto-escaping mitigates most vectors, but CSP would block any that slip through.","affected_data":"All user data accessible via the browser session: journal entries, daily logs, authentication tokens"},"suggested_fix":{"steps":["1. Add a Content-Security-Policy header to the ** source pattern in firebase.json","2. Start with Content-Security-Policy-Report-Only to identify violations without breaking functionality","3. Required directives: default-src 'self'; script-src 'self' https://www.google.com https://www.gstatic.com https://*.sentry.io; connect-src 'self' https://*.googleapis.com https://*.firebaseio.com https://*.sentry.io; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'","4. Monitor violation reports, then switch from Report-Only to enforcing"],"code_example":"{\"key\": \"Content-Security-Policy\", \"value\": \"default-src 'self'; script-src 'self' https://www.google.com https://www.gstatic.com https://*.sentry.io; connect-src 'self' https://*.googleapis.com https://*.firebaseio.com https://*.sentry.io; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'\"}","verification":["Deploy and verify CSP header present via curl -I or browser DevTools","Confirm no console CSP violation errors on all pages","Test reCAPTCHA, Firebase Auth, and Sentry still function"]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":["firebase.json:6-58: Headers section defines X-Frame-Options, HSTS, nosniff, COOP, Referrer-Policy, Permissions-Policy but NO Content-Security-Policy"],"notes":"HSTS, X-Frame-Options DENY, nosniff, Referrer-Policy, and Permissions-Policy are all correctly configured.","why_it_matters":"Missing Content-Security-Policy header","acceptance_tests":["Verify fix applied correctly"]}
{"category":"OWASP","title":"3 high-severity npm audit dependency vulnerabilities","fingerprint":"OWASP::package.json::npm_audit_high","severity":"S2","effort":"E1","confidence":100,"files":["package.json","functions/package.json"],"line":1,"vulnerability_details":{"description":"npm audit reports 3 high-severity vulnerabilities across root and functions packages: (1) Root: @isaacs/brace-expansion ReDoS (GHSA-7h2j-956f-4vf2); (2) Functions: fast-xml-parser DoS via numeric entities (GHSA-37qj-frw5-hhjh, CVSS 7.5, range >=4.3.6 <=5.3.3); (3) Functions: @google-cloud/storage 7.12.1-7.18.0 (transitive dependency on vulnerable fast-xml-parser).","exploitation":"fast-xml-parser: A crafted XML payload with numeric entities can cause RangeError DoS. If @google-cloud/storage internally parses XML responses from GCP APIs (which it does for multi-part operations), a malicious or malformed GCP response could trigger this. brace-expansion: ReDoS via crafted glob patterns, primarily affects dev tooling.","impact":"Potential denial of service in Cloud Functions via fast-xml-parser. The brace-expansion issue affects build tooling only.","affected_data":"Cloud Function availability and responsiveness"},"suggested_fix":{"steps":["1. cd functions && npm audit fix","2. If fix unavailable, check for @google-cloud/storage version > 7.18.0","3. cd / && npm audit fix for root brace-expansion","4. If no automatic fix available, document accepted risk with justification"],"verification":["npm audit --json shows 0 high/critical in both root and functions/"]},"owasp_category":"A06","cvss_estimate":"MEDIUM","evidence":["functions npm audit: fast-xml-parser severity:high CVSS:7.5 range:>=4.3.6 <=5.3.3 url:GHSA-37qj-frw5-hhjh","functions npm audit: @google-cloud/storage severity:high range:7.12.1-7.18.0 via fast-xml-parser","root npm audit: @isaacs/brace-expansion severity:high url:GHSA-7h2j-956f-4vf2"],"why_it_matters":"3 high-severity npm audit dependency vulnerabilities","acceptance_tests":["Verify fix applied correctly"]}
{"category":"Headers","title":"Missing Cross-Origin-Embedder-Policy header","fingerprint":"Headers::firebase.json::missing_coep","severity":"S3","effort":"E0","confidence":100,"files":["firebase.json"],"line":29,"vulnerability_details":{"description":"Cross-Origin-Embedder-Policy (COEP) header is not configured in firebase.json. COOP is set to same-origin-allow-popups but COEP is absent.","exploitation":"Without COEP, the site cannot enable cross-origin isolation (required for SharedArrayBuffer). The primary risk is Spectre-class side-channel attacks reading cross-origin data, but this requires the attacker to already have script execution.","impact":"Minimal for this application. COEP is primarily needed for applications using SharedArrayBuffer or high-resolution timers.","affected_data":"N/A for current application scope"},"suggested_fix":{"steps":["1. Add COEP header: Cross-Origin-Embedder-Policy: require-corp","2. Verify all cross-origin resources (reCAPTCHA script, Sentry, Google fonts if any) still load correctly","3. If resources break, use crossorigin attributes or CORS headers on those resources"],"code_example":"{\"key\": \"Cross-Origin-Embedder-Policy\", \"value\": \"require-corp\"}","verification":["Verify header present via curl -I","Test reCAPTCHA and Sentry still load correctly"]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":["firebase.json:29-57: Global headers section includes COOP but not COEP"],"why_it_matters":"Missing Cross-Origin-Embedder-Policy header","acceptance_tests":["Verify fix applied correctly"]}
{"category":"InputValidation","title":"Zod schemas missing .strict() mode","fingerprint":"InputValidation::functions/src/schemas.ts::no_strict_mode","severity":"S3","effort":"E1","confidence":90,"files":["functions/src/schemas.ts"],"line":5,"vulnerability_details":{"description":"All Zod validation schemas (dailyLogSchema line 5, journalEntrySchema line 19, inventoryEntrySchema line 49, meetingSchema line 60, soberLivingSchema line 83, quoteSchema line 101, softDeleteJournalEntrySchema line 111, migrationDataSchema line 120) use z.object({}) without .strict(). Unknown fields pass through validation silently.","exploitation":"An attacker sends extra fields (e.g., {isAdmin: true, role: 'superuser'}) alongside valid data. If any Cloud Function handler uses spread operators to persist data, these fields could be written to Firestore. Current handlers destructure explicitly (mitigating this), but future code changes could introduce the vulnerability.","impact":"Low immediate risk due to explicit destructuring. Maintenance risk if future handlers use spread patterns on validated data.","affected_data":"All Cloud Function input data"},"suggested_fix":{"steps":["1. Add .strict() to all schemas in functions/src/schemas.ts","2. Alternatively, use .strip() to silently remove unknown fields","3. Update any code that relies on passthrough behavior"],"code_example":"export const dailyLogSchema = z.object({\n  date: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/),\n  content: z.string().max(50000),\n  // ... other fields\n}).strict();","verification":["Send request with unknown field {extraField: 'test'} to saveDailyLog","Verify response is invalid-argument error (if .strict()) or field is stripped (if .strip())"]},"owasp_category":"A03","cvss_estimate":"LOW","evidence":["functions/src/schemas.ts:5: export const dailyLogSchema = z.object({  (no .strict())","functions/src/schemas.ts:19: export const journalEntrySchema = z.object({  (no .strict())","functions/src/schemas.ts:49: export const inventoryEntrySchema = z.object({  (no .strict())","functions/src/schemas.ts:60: export const meetingSchema = z.object({  (no .strict())"],"why_it_matters":"Zod schemas missing .strict() mode","acceptance_tests":["Verify fix applied correctly"]}
{"category":"SecretsManagement","title":".env.production committed to git with Firebase config values","fingerprint":"SecretsManagement::.env.production::committed_config","severity":"S3","effort":"E1","confidence":95,"files":[".env.production"],"line":5,"vulnerability_details":{"description":".env.production is tracked in git (confirmed via git ls-files) and contains: NEXT_PUBLIC_FIREBASE_API_KEY, NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN, NEXT_PUBLIC_FIREBASE_PROJECT_ID, NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET, NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID, NEXT_PUBLIC_FIREBASE_APP_ID, NEXT_PUBLIC_FIREBASE_APPCHECK_RECAPTCHA_SITE_KEY, NEXT_PUBLIC_SENTRY_DSN. While these are all NEXT_PUBLIC_ (client-safe) values, the pattern of committing .env files to git normalizes a practice that can lead to accidental secret exposure.","exploitation":"Not directly exploitable. All committed values are designed for client-side exposure (Firebase API keys are restricted by Security Rules, not key secrecy). Risk is organizational: future developers might add actual secrets to this file.","impact":"Low. No actual secret exposure. Process/pattern risk only.","affected_data":"Firebase project configuration (public), reCAPTCHA site key (public), Sentry DSN (public)"},"suggested_fix":{"steps":["1. Consider moving production config to CI/CD environment variables injected at build time","2. If keeping committed, add a prominent comment: '# WARNING: This file is committed to git. NEVER add actual secrets here.'","3. Add a pre-commit hook check that .env.production only contains NEXT_PUBLIC_ variables"],"verification":["Verify no non-NEXT_PUBLIC_ secrets exist in .env.production","Verify functions/.env contains no secrets"]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":[".env.production:5: NEXT_PUBLIC_FIREBASE_API_KEY=AIzaSyDGvM5kFwkgSTUS1Tbwt0piuhk9bcCeY7Q",".env.production:13: NEXT_PUBLIC_FIREBASE_APPCHECK_RECAPTCHA_SITE_KEY=6LdeazosAAAAAMDNCh1hTUDKh_UeS6xWY1-85B2O",".env.production:20: NEXT_PUBLIC_SENTRY_DSN=https://f585a8353ec50d104e5484fedca6c2f2@o4510530873589760.ingest.us.sentry.io/4510711416094720","git ls-files output includes: .env.production"],"notes":"Firebase API keys are public by design. Security is enforced by Firestore Security Rules and App Check, not by key secrecy.","why_it_matters":".env.production committed to git with Firebase config values","acceptance_tests":["Verify fix applied correctly"]}
{"category":"Firebase","title":"migrateAnonymousUserData bypasses withSecurityChecks wrapper","fingerprint":"Firebase::functions/src/index.ts::migrate_manual_security","severity":"S3","effort":"E1","confidence":85,"files":["functions/src/index.ts"],"line":486,"vulnerability_details":{"description":"The migrateAnonymousUserData function (index.ts:486) implements manual auth, rate limiting, App Check, reCAPTCHA, and Zod validation instead of using the standardized withSecurityChecks wrapper used by all other user-facing functions. Critically, it makes reCAPTCHA optional (logs warning but continues without token at line 516-527) and has App Check verification commented out (lines 506-511).","exploitation":"An attacker can call migrateAnonymousUserData without a reCAPTCHA token and without App Check attestation. Combined with anonymous account creation, this could be used to repeatedly attempt data migration operations. Rate limiting (5 req/5min) still applies per-user.","impact":"Weaker bot protection on the migration endpoint compared to other endpoints. Migration is a sensitive operation that copies data between user accounts.","affected_data":"User migration data: journal entries, daily logs, inventory entries, profile data"},"suggested_fix":{"steps":["1. Refactor migrateAnonymousUserData to use withSecurityChecks wrapper","2. Create a custom SecurityOptions configuration that handles the unique targetUid authorization logic","3. Ensure reCAPTCHA is required (not optional) for this sensitive operation","4. Re-enable App Check requirement"],"verification":["Send migration request without reCAPTCHA token, verify it is rejected","Verify function uses withSecurityChecks wrapper","Run existing migration tests to confirm no regressions"]},"owasp_category":"A04","cvss_estimate":"LOW","evidence":["functions/src/index.ts:486: export const migrateAnonymousUserData = onCall<MigrationData>(async (request) => {  // Manual checks, not withSecurityChecks","functions/src/index.ts:506-511: App Check verification block commented out","functions/src/index.ts:516-527: if (!token || token.trim() === '') { logSecurityEvent(...) // Continue without reCAPTCHA protection"],"why_it_matters":"migrateAnonymousUserData bypasses withSecurityChecks wrapper","acceptance_tests":["Verify fix applied correctly"]}