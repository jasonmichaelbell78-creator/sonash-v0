{"category":"Firebase","title":"App Check enforcement disabled on callable write endpoints","fingerprint":"Firebase::functions/src/index.ts::appcheck_disabled","severity":"S1","effort":"E1","confidence":95,"files":["functions/src/index.ts"],"vulnerability_details":{"description":"Multiple security-critical callable functions explicitly set requireAppCheck: false, disabling App Check verification.","exploitation":"An attacker can call callable functions from non-genuine clients (e.g., scripted requests using a stolen/abused Firebase Auth session) without needing App Check, increasing abuse/fraud risk against write endpoints (journal/daily logs/inventory).","impact":"Higher likelihood of automated abuse, quota exhaustion, write spam, and cost amplification; reduces defense-in-depth for auth-bound operations.","affected_data":"User journal/daily logs/inventory collections written via Admin SDK"},"remediation":{"steps":["Re-enable App Check for production by setting requireAppCheck: true (or omitting the override) for all non-admin callable functions.","If a temporary operational bypass is needed, gate it behind an explicit non-production environment check (e.g., FUNCTIONS_EMULATOR) and ensure CI prevents deployment with App Check disabled.","Add a release-blocking check/hook that fails builds when requireAppCheck: false is present outside emulator-only code paths."],"code_example":"// functions/src/index.ts\nwithSecurityChecks(request, {\n  functionName: \"saveDailyLog\",\n  rateLimiter: saveDailyLogLimiter,\n  ipRateLimiter: saveDailyLogIpLimiter,\n  validationSchema: dailyLogSchema.strict(),\n  requireAppCheck: true,\n  recaptchaAction: \"save_daily_log\",\n}, handler)","verification":["Attempt callable invocation without App Check token in prod: must fail with failed-precondition.","Run grep in CI to ensure no requireAppCheck: false exists in production paths."]},"owasp_category":"A05","cvss_estimate":"HIGH","evidence":["functions/src/index.ts:84 requireAppCheck: false // TEMPORARILY DISABLED","functions/src/index.ts:170 requireAppCheck: false","functions/src/index.ts:269 requireAppCheck: false","functions/src/index.ts:363 requireAppCheck: false"],"notes":"Evidence excerpt: functions/src/index.ts lines 81-86 show requireAppCheck: false.","line":84}
{"category":"RateLimiting","title":"IP-based rate limiting is supported but not applied to public callable endpoints","fingerprint":"RateLimiting::functions/src/security-wrapper.ts::missing_ip_limiters","severity":"S2","effort":"E2","confidence":85,"files":["functions/src/security-wrapper.ts","functions/src/index.ts"],"vulnerability_details":{"description":"Security wrapper supports ipRateLimiter, but core public callable functions only provide rateLimiter (user-based) and omit ipRateLimiter, violating the required IP+user limiting standard.","exploitation":"An attacker can cycle accounts (or use multiple compromised accounts) from a single IP to amplify request volume; user-only limiting is less effective against account cycling and bot swarms.","impact":"Increased abuse potential and cost risk; reduced throttling effectiveness for write endpoints.","affected_data":"Callable endpoints (saveDailyLog/saveJournalEntry/saveInventoryEntry/softDeleteJournalEntry/migrateAnonymousUserData)"},"remediation":{"steps":["Instantiate dedicated FirestoreRateLimiter instances for IP keys (separate points/duration per operation class).","Pass ipRateLimiter into withSecurityChecks for each public callable function.","Add logging/metrics to distinguish IP-based vs user-based throttling events."],"code_example":"// functions/src/index.ts\nconst saveDailyLogIpLimiter = new FirestoreRateLimiter({ points: 30, duration: 60 });\n...\nwithSecurityChecks(request, {\n  functionName: \"saveDailyLog\",\n  rateLimiter: saveDailyLogLimiter,\n  ipRateLimiter: saveDailyLogIpLimiter,\n  ...\n}, handler)","verification":["From a single IP, make requests across multiple accounts: IP limiter must eventually block even if per-user limits are not hit.","Confirm RATE_LIMIT_EXCEEDED logs include indicator for IP vs user limiting."]},"owasp_category":"A04","cvss_estimate":"MEDIUM","evidence":["functions/src/security-wrapper.ts:37 ipRateLimiter?: FirestoreRateLimiter;","functions/src/security-wrapper.ts:362 await checkIpRateLimit(ipRateLimiter, request, userId, functionName);","functions/src/index.ts:82 rateLimiter: saveDailyLogLimiter (no ipRateLimiter provided)"],"notes":"No ipRateLimiter passed in functions/src/index.ts option objects for public callables.","line":37}
{"category":"RateLimiting","title":"Rate limit exceed is treated as generic failure in FirestoreRateLimiter, undermining graceful 429 behavior","fingerprint":"RateLimiting::functions/src/firestore-rate-limiter.ts::misclassified_exceed","severity":"S2","effort":"E1","confidence":90,"files":["functions/src/firestore-rate-limiter.ts","functions/src/security-wrapper.ts"],"vulnerability_details":{"description":"When the limiter exceeds, it throws Error(\"Too many requests...\") but the catch block only re-throws if message includes \"Rate limit exceeded\". This condition never matches the thrown message, so the limiter converts an exceed into a generic \"Service temporarily unavailable...\" error.","exploitation":"Abuse traffic causes the limiter to respond as if the service is unstable; clients may implement incorrect retries/backoff. This also weakens operational visibility and violates the requirement for predictable graceful 429/Retry-After semantics.","impact":"Unreliable throttling semantics; client retry storms; reduced abuse handling; observability confusion.","affected_data":"All endpoints using FirestoreRateLimiter"},"remediation":{"steps":["Use a distinct error type or a stable sentinel (e.g., throw new RateLimitExceededError) and detect it explicitly.","If you must keep messages generic, set an internal flag/property to identify rate limit exceeded.","In callable functions, map limiter errors to consistent resource-exhausted responses and optionally include a safe retry-after hint (even if coarse-grained)."],"code_example":"// functions/src/firestore-rate-limiter.ts\nclass RateLimitExceededError extends Error { constructor(){ super(\"RATE_LIMIT_EXCEEDED\"); } }\n...\nthrow new RateLimitExceededError();\n...\nif (error instanceof RateLimitExceededError) throw error;","verification":["Exceed limit: confirm the thrown error is classified as rate limit (not generic service unavailable).","Confirm wrapper logs RATE_LIMIT_EXCEEDED for true throttles and uses a consistent client-facing error."]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":["functions/src/firestore-rate-limiter.ts:116 throw new Error(\"Too many requests. Please try again later.\")","functions/src/firestore-rate-limiter.ts:133-142 catch only re-throws when message includes \"Rate limit exceeded\""],"notes":"This is a logic mismatch between the thrown message and the detection predicate.","line":116}
{"category":"InputValidation","title":"Cloud Function Zod schemas are not strict; unknown fields accepted","fingerprint":"InputValidation::functions/src/schemas.ts::missing_strict","severity":"S2","effort":"E1","confidence":95,"files":["functions/src/schemas.ts","functions/src/security-wrapper.ts"],"vulnerability_details":{"description":"Schemas use z.object({...}) without .strict(). This allows unknown fields through validation, contrary to mandatory standards.","exploitation":"Attackers can supply unexpected fields to probe behavior, attempt schema smuggling, or prepare future exploitation if handlers begin trusting extra fields. It also complicates auditability and can enable log/telemetry pollution.","impact":"Reduced input robustness and future-proofing; increased risk of insecure handling of unexpected fields.","affected_data":"All callable function inputs validated by these schemas"},"remediation":{"steps":["Add .strict() to all z.object schemas used for external inputs (dailyLogSchema, journalEntrySchema, inventoryEntrySchema, softDeleteJournalEntrySchema, migrationDataSchema, and admin request wrappers where applicable).","Add explicit max length limits for optional string fields (e.g., mood, tags items) and array bounds where appropriate.","Prefer z.record with bounded keys/values or per-type schemas for journalEntry 'data' where feasible."],"code_example":"export const dailyLogSchema = z.object({\n  date: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/),\n  content: z.string().max(50000),\n  mood: z.string().max(64).nullable().optional(),\n  ...\n}).strict();","verification":["Send request with extra field (e.g., {date, content, extra: \"x\"}): must fail with invalid-argument.","Fuzz unknown fields at root and nested levels; confirm rejection."]},"owasp_category":"A03","cvss_estimate":"MEDIUM","evidence":["functions/src/schemas.ts:5-13 dailyLogSchema = z.object({ ... }) (no .strict())","functions/src/security-wrapper.ts:211-216 validationSchema.parse(request.data)"],"notes":"This is a standards-compliance gap even if current handlers ignore unknown fields.","line":5}
{"category":"SecretsManagement","title":"Committed .env.production and insufficient .gitignore env patterns (risk of secret leakage)","fingerprint":"SecretsManagement::.env.production::env_committed","severity":"S1","effort":"E1","confidence":90,"files":[".env.production",".gitignore"],"vulnerability_details":{"description":".env.production is present in the repository, and .gitignore only ignores .env*.local, not .env.production. This creates a high risk of accidental secret commits now or in the future.","exploitation":"If any true secrets (API tokens, admin keys, service credentials) are ever added to .env.production, they would be committed to git history and potentially exposed to anyone with repo access. Even if current values are intended to be public, the pattern is unsafe.","impact":"Potential credential exposure, account takeover, data breach depending on what gets committed.","affected_data":"Any environment secrets that may be introduced (Sentry tokens, Firebase service creds, API keys, etc.)"},"remediation":{"steps":["Remove .env.production from version control; rotate any secrets that were ever placed in it.","Update .gitignore to ignore .env* (with explicit allowlist for .env.example) and enforce via pre-commit/CI.","Keep a sanitized .env.example (present) with no real values."],"code_example":"# .gitignore\n.env*\n!.env.example\n!.env.local.example","verification":["Verify git status shows .env.production untracked and CI fails if env files are added.","Run secret scanners (gitleaks/trufflehog) over git history after removal; rotate any flagged credentials."]},"owasp_category":"A05","cvss_estimate":"HIGH","evidence":[".gitignore:31 .env*.local (does not ignore .env.production)","./.env.production contains NEXT_PUBLIC_* configuration and is committed"],"notes":"Even if Firebase web API keys are not secret, committed env files violate the mandatory secrets management standard.","line":1}
{"category":"Headers","title":"Missing Content-Security-Policy and COEP hardening in Firebase Hosting headers","fingerprint":"Headers::firebase.json::missing_csp","severity":"S2","effort":"E2","confidence":90,"files":["firebase.json"],"vulnerability_details":{"description":"firebase.json config sets several security headers (HSTS, XFO, nosniff, Referrer-Policy, Permissions-Policy) but omits Content-Security-Policy (CSP) and Cross-Origin-Embedder-Policy (COEP).","exploitation":"Without CSP, an XSS flaw elsewhere is easier to weaponize (no script-src constraints). Without COEP (paired with COOP), the app can't enforce cross-origin isolation and is more exposed to certain browser cross-origin risks.","impact":"Reduced browser-side mitigation for XSS and other injection classes; weaker defense-in-depth.","affected_data":"All users of the hosted web app"},"remediation":{"steps":["Add a restrictive CSP tailored to Next.js static export + Firebase Hosting (script-src 'self' with required allowances; avoid unsafe-inline if possible).","If cross-origin isolation is desired, add COEP and ensure resources comply (or explicitly decide not to use it and document rationale).","Add CI check to ensure security headers include CSP at minimum."],"code_example":"{\n  \"key\": \"Content-Security-Policy\",\n  \"value\": \"default-src 'self'; img-src 'self' data: https:; style-src 'self' 'unsafe-inline'; script-src 'self'; connect-src 'self' https://*.googleapis.com https://*.firebaseio.com https://identitytoolkit.googleapis.com; frame-ancestors 'none'\"\n}","verification":["Deploy and confirm response headers include CSP on '**' routes.","Run a CSP evaluator and ensure no blocking of required Firebase endpoints.","Attempt inline script injection: should be blocked when CSP is tightened (where feasible)."]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":["firebase.json:30-56 headers list does not include Content-Security-Policy or Cross-Origin-Embedder-Policy"],"notes":"COOP is set to same-origin-allow-popups; ensure this is intended and compatible with any auth popups.","line":30}
