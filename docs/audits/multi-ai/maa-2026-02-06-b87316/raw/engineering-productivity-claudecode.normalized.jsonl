{"category":"GoldenPath","title":"Missing .env.example file - critical onboarding blocker","fingerprint":"engineering-productivity::.env.example::missing-file","severity":"S1","effort":"E0","confidence":100,"files":[".env.example"],"line":1,"why_it_matters":"New developers cannot start the project without Firebase credentials. DEVELOPMENT.md documents required environment variables but no .env.example template exists. This forces developers to manually copy/paste from documentation, increasing setup friction and error probability. Critical for golden path onboarding.","suggested_fix":"Create .env.example file with all required Firebase environment variables as placeholders. Include comments explaining where to get each value (Firebase Console → Project Settings → Your Apps). Add validation in lib/firebase.ts already handles missing vars with clear error messages.","acceptance_tests":["File .env.example exists in repository root","Contains all 6 Firebase variables (NEXT_PUBLIC_FIREBASE_API_KEY, AUTH_DOMAIN, PROJECT_ID, STORAGE_BUCKET, MESSAGING_SENDER_ID, APP_ID)","Contains App Check variable (NEXT_PUBLIC_FIREBASE_APPCHECK_RECAPTCHA_SITE_KEY)","Contains Sentry variables (NEXT_PUBLIC_SENTRY_DSN, NEXT_PUBLIC_SENTRY_ENABLED)","Has comments explaining where to get values","New developer can cp .env.example .env.local and fill in values"],"evidence":["cat .env.example → No such file","DEVELOPMENT.md lines 50-72 documents required env vars but no template","lib/firebase.ts:8-13 has validateEnv() that throws clear errors for missing vars"]}
{"category":"Offline","title":"Firebase IndexedDB persistence not enabled - no offline data support","fingerprint":"engineering-productivity::lib/firebase.ts::missing-offline-persistence","severity":"S1","effort":"E1","confidence":100,"files":["lib/firebase.ts"],"line":55,"why_it_matters":"Users lose all unsaved work when offline or with poor connectivity. Firebase SDK supports IndexedDB persistence for offline read/write caching, but it's not enabled. This is critical for a recovery journal where users may write in various connectivity conditions (subway, airplane, rural areas). Without persistence, data loss creates severe trust issues.","suggested_fix":"Add enableIndexedDbPersistence() or enableMultiTabIndexedDbPersistence() after Firestore initialization in lib/firebase.ts. Wrap in try-catch to handle scenarios where persistence is already enabled or unavailable (private browsing). Add UI indicator when offline mode is active. Consider implementing write queue for mutations made while offline.","acceptance_tests":["import { enableIndexedDbPersistence } from 'firebase/firestore' added","enableIndexedDbPersistence(_db).catch() added after line 55","Error handling for already-enabled and quota-exceeded cases","Test: Disconnect network, write journal entry, reconnect, verify sync","Test: Open two tabs, verify multi-tab persistence works","Documentation updated in DEVELOPMENT.md about offline capabilities"],"evidence":["grep -r 'enableIndexedDbPersistence' lib/ → 0 matches","grep -r 'enableMultiTabIndexedDbPersistence' lib/ → 0 matches","lib/firebase.ts:55 initializes Firestore but no persistence call","Firebase docs: https://firebase.google.com/docs/firestore/manage-data/enable-offline"]}
{"category":"Offline","title":"No service worker - missing offline shell and asset caching","fingerprint":"engineering-productivity::public/sw.js::missing-service-worker","severity":"S1","effort":"E2","confidence":100,"files":["public/sw.js","next.config.js"],"line":1,"why_it_matters":"Application cannot function offline even for basic UI shell. Service workers cache static assets (HTML, CSS, JS) enabling the app to load even without network. For a recovery tool, offline access is critical - users may need to journal during flights, in basements, or in areas with poor connectivity. Without SW, users see 'No Internet Connection' browser error instead of the app.","suggested_fix":"Implement service worker using next-pwa plugin or Workbox. Configure for: (1) Precache app shell (HTML, CSS, JS bundles), (2) Runtime cache for Firebase API calls, (3) Offline fallback page, (4) Background sync for pending writes. Next.js 13+ App Router has built-in support via next-pwa@5.6.0+. Add sw.js to public/ and configure in next.config.js.","acceptance_tests":["npm install next-pwa --save-dev","next.config.js wrapped with withPWA()","public/manifest.json created with app metadata","Service worker registered in app/layout.tsx","Test: Load app, go offline, refresh page - app loads","Test: DevTools → Application → Service Workers shows 'activated'","Test: Lighthouse PWA audit passes offline test"],"evidence":["ls public/sw.js → No such file","ls public/service-worker.js → No such file","grep -r 'serviceWorker' app/ → 0 matches","No next-pwa in package.json dependencies","PWA best practices: https://web.dev/offline-cookbook/"]}
{"category":"GoldenPath","title":"No automated setup script - manual 5-step installation process","fingerprint":"engineering-productivity::scripts/setup.js::missing-setup-script","severity":"S2","effort":"E1","confidence":100,"files":["scripts/setup.js","package.json"],"line":1,"why_it_matters":"New developers must manually run 5 commands to set up the project (clone, npm install, cd functions && npm install, create .env.local, copy values). This increases onboarding time from <2 minutes to 10-15 minutes and introduces error probability. Standard practice is 'npm run setup' that automates all steps. Missing setup script violates golden path principle.","suggested_fix":"Create scripts/setup.js that: (1) Checks Node.js version (>=18), (2) Runs npm install in root, (3) Runs npm install in functions/, (4) Checks for .env.local, creates from .env.example if missing, (5) Validates required environment variables or provides interactive prompts, (6) Runs npm run test:build to verify setup, (7) Prints success message with next steps. Add 'setup' script to package.json.","acceptance_tests":["scripts/setup.js exists and is executable","package.json has 'setup': 'node scripts/setup.js'","Script checks Node.js version and exits with clear error if wrong version","Script installs dependencies in root and functions/","Script creates .env.local from .env.example if missing","Script validates or prompts for Firebase credentials","Script runs test build to verify setup","New developer can run: npm run setup and be ready to code","Documentation updated: README.md shows 'npm run setup' as step 1"],"evidence":["ls scripts/ | grep -E 'setup|install|init' → 0 matches","DEVELOPMENT.md lines 40-47 shows 5 manual steps","No 'setup' script in package.json","Similar projects use setup scripts: create-react-app, Next.js, etc."]}
{"category":"Debugging","title":"Correlation IDs not implemented comprehensively - no request tracing","fingerprint":"engineering-productivity::lib/logger.ts::missing-correlation-ids","severity":"S2","effort":"E1","confidence":90,"files":["lib/logger.ts","lib/firestore-service.ts"],"line":1,"why_it_matters":"When debugging production issues, cannot trace a single user's request flow across multiple Cloud Function calls and API interactions. Correlation IDs (or request IDs) tie related logs together enabling: (1) End-to-end request tracing, (2) Faster debugging of user-reported issues, (3) Performance analysis across service boundaries. Currently have 10 scattered mentions of correlationId but no centralized implementation.","suggested_fix":"Implement correlation ID strategy: (1) Generate UUID on client for each user action (journal save, login, etc.), (2) Pass in all Cloud Function calls via context parameter, (3) Include in all logger calls (logger.info('message', { correlationId })), (4) Add to Sentry context for error tracking, (5) Return in API responses for support debugging. Add to lib/logger.ts as default context field.","acceptance_tests":["lib/logger.ts accepts correlationId in context parameter","lib/utils/correlation.ts exports generateCorrelationId() function","All Cloud Function calls include correlationId","Sentry events tagged with correlationId","Test: Make API call, check logs for consistent correlationId across all entries","Test: Error in chain, verify Sentry event has correlationId for filtering","Documentation: docs/DEBUGGING.md explains correlation ID usage"],"evidence":["grep -r 'correlationId' lib/ app/ components/ → 10 matches (scattered)","lib/logger.ts doesn't enforce correlationId parameter","lib/firestore-service.ts Cloud Function calls don't include request context","Sentry initialization doesn't configure correlationId as tag"]}
{"category":"Testing","title":"No E2E tests - only unit tests exist","fingerprint":"engineering-productivity::tests/e2e/::missing-e2e-tests","severity":"S2","effort":"E2","confidence":100,"files":["tests/e2e/"],"line":1,"why_it_matters":"Critical user workflows (signup, journal entry creation, data persistence) are not validated end-to-end. Unit tests verify individual functions but don't catch integration issues, UI regressions, or broken user flows. E2E tests are essential for a data-sensitive app like a recovery journal where data loss or auth failures have severe consequences. Currently have 477 unit tests but 0 E2E tests.","suggested_fix":"Implement Playwright E2E tests for critical paths: (1) User signup and onboarding flow, (2) Create journal entry and verify persistence, (3) Offline write and sync on reconnect, (4) Dashboard data display, (5) Settings and profile management. Create tests/e2e/ directory with Playwright config. Add 'test:e2e' npm script. Run in CI workflow. Target: 10-15 E2E tests covering golden paths.","acceptance_tests":["npm install --save-dev @playwright/test","playwright.config.ts created with base URL and browser configs","tests/e2e/ directory created","test:e2e script added to package.json","At least 3 E2E tests written: signup, journal-entry, offline-sync","CI workflow runs E2E tests after build","Test artifacts (screenshots, videos) uploaded on failure","Documentation: docs/TESTING_PLAN.md includes E2E testing section"],"evidence":["ls tests/e2e/ → No such directory","grep -r 'playwright' tests/ → 0 matches","grep -r '@playwright/test' package.json → 0 matches","tests/ directory has only unit tests (20 files, 477 test cases)","CI workflow has no E2E test step"]}
{"category":"Offline","title":"No offline write queue - mutations lost when offline","fingerprint":"engineering-productivity::lib/offline-queue.ts::missing-write-queue","severity":"S2","effort":"E2","confidence":95,"files":["lib/offline-queue.ts"],"line":1,"why_it_matters":"When users write journal entries offline, mutations fail silently or show errors instead of queueing for later sync. Even with IndexedDB persistence enabled, Firebase SDK doesn't automatically retry failed writes. Users expect 'write and forget' behavior - app should queue writes locally and sync when connectivity returns. Current implementation likely shows error toasts that users must manually retry.","suggested_fix":"Implement offline write queue: (1) Create lib/offline-queue.ts with IndexedDB-backed queue, (2) Wrap all mutations (saveDailyLog, saveJournalEntry) to detect offline state, (3) Queue mutations with timestamp and retry metadata, (4) Listen for online event and process queue, (5) Add UI indicator showing pending syncs count, (6) Handle conflict resolution for edited items. Use Firebase enableIndexedDbPersistence + custom queue for better UX.","acceptance_tests":["lib/offline-queue.ts exists with OfflineQueue class","Queue stores mutations in IndexedDB (not memory)","saveDailyLog and similar functions check offline state and queue if needed","window.addEventListener('online') triggers queue processing","UI shows 'X items pending sync' when offline","Test: Go offline, create 3 entries, go online, verify all 3 sync","Test: Conflict resolution - edit same entry offline twice, verify merge logic","Documentation: ARCHITECTURE.md explains offline queue design"],"evidence":["grep -r 'offline.*queue|write.*queue' lib/ → 0 matches","No IndexedDB queue implementation found","lib/firestore-service.ts mutations don't check navigator.onLine","No UI indicator for pending syncs","Standard pattern: https://web.dev/offline-cookbook/#on-background-sync"]}
{"category":"Testing","title":"Tests not organized by domain - flat structure in tests/ directory","fingerprint":"engineering-productivity::tests/::flat-test-structure","severity":"S3","effort":"E1","confidence":90,"files":["tests/"],"line":1,"why_it_matters":"Test files are all in flat tests/ directory rather than organized by feature domain (auth, journal, meetings, etc.). This makes it harder to: (1) Find tests for specific features, (2) Run tests for a specific domain, (3) Understand test coverage by module. As test count grows (currently 477 tests), organization becomes critical for maintainability. Minor issue now but will cause friction as project scales.","suggested_fix":"Reorganize tests by domain: tests/auth/, tests/journal/, tests/meetings/, tests/admin/, tests/lib/. Mirror the app/ and components/ directory structure. Update test:build script to compile from new structure. Consider using test naming convention: <feature>.test.ts. Add 'test:unit' and 'test:integration' scripts for filtering. Document test organization in docs/TESTING_PLAN.md.","acceptance_tests":["tests/ has subdirectories: auth/, journal/, meetings/, admin/, lib/","Each test file follows pattern: tests/<domain>/<feature>.test.ts","npm run test still runs all tests","New npm scripts: test:auth, test:journal for domain-specific runs","Documentation: TESTING_PLAN.md explains test organization","Developers can easily find tests for feature they're modifying"],"evidence":["ls tests/ shows flat structure (20 .test.ts files at root)","No subdirectories for domains: ls tests/*/ → No such directory","Current structure makes it hard to filter: npm run test tests/journal/*","Standard practice: Mirror app/ structure in tests/"]}
{"category":"CI_CD","title":"No auto-retry on flaky test failures in CI","fingerprint":"engineering-productivity::.github/workflows/ci.yml::no-retry-logic","severity":"S3","effort":"E0","confidence":85,"files":[".github/workflows/ci.yml"],"line":114,"why_it_matters":"Flaky tests (intermittent failures due to timing, network, etc.) block PRs unnecessarily, requiring manual re-runs. While current test suite may not be flaky yet, as E2E tests are added, flaky failures will occur. Auto-retry (2-3 attempts) is industry best practice to distinguish genuine failures from intermittent issues. Low priority currently but will become critical with E2E tests.","suggested_fix":"Add retry logic to test step in CI workflow using actions/retry or continue-on-error with manual retry. For E2E tests specifically, configure Playwright retries in playwright.config.ts. Limit to 2-3 retries to avoid masking real issues. Log retry attempts for visibility. Consider using actions/reusable-workflows for common retry patterns.","acceptance_tests":["CI workflow test step has retry logic (uses: nick-fields/retry-action@v2)","Maximum 3 retry attempts configured","Retry delay: 10 seconds between attempts","Test: Introduce flaky test, verify CI retries before failing","Logs show 'Retry attempt 1/3' messages","Documentation: DEVELOPMENT.md mentions CI retry behavior"],"evidence":[".github/workflows/ci.yml:114 runs tests with no retry","No 'retry' or 'continue-on-error' on test steps","actions/retry not used in workflow","Best practice: https://github.com/marketplace/actions/retry-action"]}
{"category":"GoldenPath","title":"No npm run doctor diagnostic script","fingerprint":"engineering-productivity::scripts/doctor.js::missing-doctor-script","severity":"S3","effort":"E1","confidence":80,"files":["scripts/doctor.js","package.json"],"line":1,"why_it_matters":"Developers have no single command to validate their environment setup. When things break, they must manually check: Node version, dependencies installed, env vars set, Firebase connection working, tests passing. A 'doctor' script automates all health checks and provides actionable error messages. Industry standard for mature projects (like create-react-app, Next.js). Low priority but high value for developer experience.","suggested_fix":"Create scripts/doctor.js that runs: (1) Check Node.js version (>=18), (2) Verify npm and dependencies installed, (3) Check .env.local exists and has required vars, (4) Test Firebase connection (try to initialize, don't write), (5) Run linter and type check, (6) Run test suite, (7) Check for circular dependencies. Output: checks passed, checks failed with fix instructions. Add 'doctor' script to package.json.","acceptance_tests":["scripts/doctor.js exists","package.json has 'doctor': 'node scripts/doctor.js'","Script checks all 7 health categories","Script exits with code 0 if all checks pass, code 1 if any fail","Output is color-coded and actionable (tells user what to fix)","Test: Break setup (remove .env.local), run doctor, verify clear error","Documentation: README.md mentions 'npm run doctor' for troubleshooting"],"evidence":["ls scripts/ | grep doctor → 0 matches","No 'doctor' script in package.json","DEVELOPMENT.md has manual troubleshooting section but no automated check","Similar pattern from process audit (suspected finding #3)"]}
{"category":"Offline","title":"No UI indicator for online/offline state","fingerprint":"engineering-productivity::components/offline-indicator.tsx::missing-offline-ui","severity":"S3","effort":"E1","confidence":85,"files":["components/offline-indicator.tsx"],"line":1,"why_it_matters":"Users don't know when they're offline and may be confused why saves fail or data doesn't load. A simple online/offline indicator (banner, toast, status icon) provides critical feedback. Currently found 8 mentions of 'offline' in components but no dedicated UI indicator. Without visual feedback, users may think app is broken rather than their network. Low severity because app may work without obvious issues, but creates confusion when offline features are added.","suggested_fix":"Create components/offline-indicator.tsx that: (1) Listens to window online/offline events, (2) Shows banner at top when offline ('You are offline. Changes will sync when reconnected'), (3) Shows toast when transitioning online to offline and vice versa, (4) Optionally shows pending sync count if offline queue implemented. Use React Context to make online state available app-wide. Add to app/layout.tsx.","acceptance_tests":["components/offline-indicator.tsx created","Component listens to window.addEventListener('online/offline')","Banner appears at top when offline with appropriate message","Toast notification on network state change","Component uses React Context to share state app-wide","Test: Disconnect network, verify banner appears immediately","Test: Reconnect network, verify banner disappears and toast shows","Integration with offline queue to show pending sync count"],"evidence":["grep -r 'offline.*indicator|network.*status' components/ → 0 matches","grep -r 'navigator.onLine|window.addEventListener.*online' components/ → 8 mentions (scattered, no UI component)","No dedicated offline UI component found","Standard pattern: https://web.dev/offline-ux-design-guidelines/"]}