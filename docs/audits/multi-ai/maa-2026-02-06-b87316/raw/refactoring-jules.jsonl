{"category":"Architecture","title":"Direct Firestore collection access bypasses Repository pattern","fingerprint":"Architecture::hooks/use-journal.ts::direct_collection_access_bypass","severity":"S2","effort":"E1","confidence":85,"files":["hooks/use-journal.ts","lib/db/slogans.ts","lib/db/meetings.ts","lib/db/collections.ts","functions/src/jobs.ts"],"line":null,"description":"Direct collection(db, path) calls are scattered across hooks/ and lib/db/ files instead of using the centralized lib/db/collections.ts helpers or FirestoreService. This violates the Repository pattern and leads to scattered query logic, inconsistent error handling, and schema drift risk.","evidence":["hooks/use-journal.ts: direct collection(db, ...) calls","lib/db/slogans.ts: direct collection() calls instead of COLLECTIONS constants","lib/db/meetings.ts: direct collection() calls","functions/src/jobs.ts: direct collection access"],"remediation":{"steps":["1. Move all collection references to lib/db/collections.ts as the single source of truth","2. Access collections via FirestoreService or typed helpers from collections.ts","3. Remove direct collection(db, ...) calls from hooks/ and components/"],"verification":["grep for collection(db in hooks/ directory yields no results","All Firestore access goes through centralized service layer"]},"acceptance_tests":["Verify fix applied correctly"]}
{"category":"Security","title":"Inconsistent secure callable usage: httpsCallable bypasses secure-caller wrapper","fingerprint":"Security::hooks/use-journal.ts::httpsCallable_bypass_secure_caller","severity":"S1","effort":"E2","confidence":90,"files":["hooks/use-journal.ts","lib/auth/account-linking.ts","lib/firestore-service.ts","lib/utils/secure-caller.ts"],"line":null,"description":"Direct httpsCallable usage exists in hooks/use-journal.ts, lib/auth/account-linking.ts, and lib/firestore-service.ts, bypassing the centralized secure-caller wrapper (lib/utils/secure-caller.ts) which handles error normalization, retries, and security logging.","evidence":["hooks/use-journal.ts: uses httpsCallable directly instead of secureCall wrapper","lib/auth/account-linking.ts: direct httpsCallable usage","lib/firestore-service.ts: direct httpsCallable usage","lib/utils/secure-caller.ts: defines createSecureFunctionCaller but is not universally adopted"],"remediation":{"steps":["1. Refactor hooks/use-journal.ts to use secureCall() wrapper for all Cloud Function calls","2. Refactor lib/firestore-service.ts to use secureCall() wrapper","3. Refactor lib/auth/account-linking.ts to use secureCall() wrapper","4. Ensure all httpsCallable usage goes through secure-caller"],"verification":["Zero direct httpsCallable() calls outside of secure-caller.ts","All Cloud Function invocations use centralized wrapper"]},"acceptance_tests":["Verify fix applied correctly"]}
{"category":"Duplication","title":"Repeated dynamic imports of firebase/functions in multiple files","fingerprint":"Duplication::lib/firestore-service.ts::repeated_dynamic_function_imports","severity":"S2","effort":"E1","confidence":80,"files":["lib/firestore-service.ts","lib/auth/account-linking.ts"],"line":null,"description":"Repeated dynamic imports of firebase/functions appear in lib/firestore-service.ts and lib/auth/account-linking.ts. Each file independently imports and initializes Firebase Functions, creating duplication and inconsistency.","evidence":["lib/firestore-service.ts: dynamic import of firebase/functions","lib/auth/account-linking.ts: dynamic import of firebase/functions"],"remediation":{"steps":["1. Centralize Firebase Functions import in lib/firebase.ts or a dedicated helper","2. Export a shared getFunctions() singleton","3. Replace dynamic imports in individual files with centralized helper"],"verification":["Single source for Firebase Functions initialization","No repeated dynamic imports of firebase/functions"]},"acceptance_tests":["Verify fix applied correctly"]}
{"category":"Types","title":"JournalEntry type duplication between frontend and backend","fingerprint":"Types::types/journal.ts::journal_entry_type_duplication","severity":"S2","effort":"E1","confidence":85,"files":["types/journal.ts","functions/src/schemas.ts"],"line":null,"description":"JournalEntry types are redefined separately in the frontend (types/journal.ts) and backend functions (functions/src/), creating high risk of schema drift between client and server representations.","evidence":["types/journal.ts: frontend JournalEntry type definition","functions/src/schemas.ts: backend Zod schema defining equivalent server-side types","Separate definitions create drift risk"],"remediation":{"steps":["1. Create shared type definition module consumed by both frontend and functions","2. Use z.infer<> from Zod schemas as the single source of truth","3. Update all imports to reference canonical type source"],"verification":["Single JournalEntry type definition used by both client and server","No duplicate type definitions"]},"acceptance_tests":["Verify fix applied correctly"]}
{"category":"Architecture","title":"Inconsistent service patterns: class-based vs object-based services","fingerprint":"Architecture::lib/db::inconsistent_service_patterns","severity":"S2","effort":"E2","confidence":80,"files":["lib/firestore-service.ts","lib/db/slogans.ts","lib/db/meetings.ts","lib/db/glossary.ts","lib/db/quotes.ts","lib/db/sober-living.ts"],"line":null,"description":"Competing service patterns exist: FirestoreService uses a class-based pattern while lib/db/ services (SlogansService, MeetingsService, etc.) use object-based patterns. This fragmentation makes applying global policies like caching, logging, or error handling difficult.","evidence":["lib/firestore-service.ts: class-based FirestoreService pattern","lib/db/slogans.ts: object-based SlogansService","lib/db/meetings.ts: object-based MeetingsService","lib/db/glossary.ts, lib/db/quotes.ts, lib/db/sober-living.ts: object-based patterns"],"remediation":{"steps":["1. Choose a canonical service pattern (recommend object-based modules in lib/db/)","2. Migrate FirestoreService methods into appropriate lib/db/ modules","3. Ensure consistent error handling, caching, and logging across all services"],"verification":["Single consistent service pattern across all data access modules","No competing class-based vs object-based patterns"]},"acceptance_tests":["Verify fix applied correctly"]}
{"category":"Duplication","title":"Repeated HTMLMotionProps<'button'> extension across Growth components","fingerprint":"Duplication::components/growth::repeated_html_motion_props","severity":"S3","effort":"E0","confidence":75,"files":["components/growth/GratitudeCard.tsx","components/growth/NightReviewCard.tsx","components/growth/SpotCheckCard.tsx","components/growth/Step1WorksheetCard.tsx"],"line":null,"description":"HTMLMotionProps<'button'> is repeatedly extended across multiple Growth components instead of using a shared type definition. Minor duplication but easy to consolidate.","evidence":["components/growth/GratitudeCard.tsx: extends HTMLMotionProps<'button'>","components/growth/NightReviewCard.tsx: extends HTMLMotionProps<'button'>","components/growth/SpotCheckCard.tsx: extends HTMLMotionProps<'button'>","components/growth/Step1WorksheetCard.tsx: extends HTMLMotionProps<'button'>"],"remediation":{"steps":["1. Extract shared AnimatedButtonProps type to a shared types file","2. Replace individual HTMLMotionProps extensions with shared type"],"verification":["Single AnimatedButtonProps type definition","All Growth components use shared type"]},"acceptance_tests":["Verify fix applied correctly"]}
{"category":"Security","title":"Potential path traversal risk in test scripts using non-literal fs arguments","fingerprint":"Security::tests::potential_path_traversal_test_scripts","severity":"S3","effort":"E1","confidence":35,"files":["tests/scripts/validate-audit-s0s1.test.ts"],"line":null,"description":"SUSPECTED: Lint warnings indicate non-literal arguments to filesystem methods (existsSync, writeFileSync) in test scripts. While low risk in a test environment, validating inputs or using path.join with sanitization is recommended as a defensive measure.","evidence":["Test scripts use non-literal arguments to existsSync and writeFileSync","Lint warnings for filesystem method usage"],"remediation":{"steps":["1. Validate file paths in test scripts using path.join()","2. Ensure no user-controlled input reaches filesystem methods"],"verification":["All filesystem calls in tests use validated, literal or path.join-constructed paths"]},"acceptance_tests":["Verify fix applied correctly"]}
