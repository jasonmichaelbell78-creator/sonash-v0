{"category":"Offline","title":"Firebase IndexedDB persistence not enabled — Firestore data lost on refresh","fingerprint":"engineering-productivity::lib/firebase.ts::no-persistence","severity":"S1","effort":"E0","confidence":100,"files":["lib/firebase.ts"],"why_it_matters":"Without enableIndexedDbPersistence(), all Firestore data is memory-only. Users in basements/meetings with poor signal cannot view previously loaded journal entries. Page refresh wipes all cached data.","suggested_fix":"Add enableIndexedDbPersistence(_db).catch(...) after line 55 in lib/firebase.ts. Handle failed-precondition and unimplemented errors.","acceptance_tests":["App loads previously fetched data when offline","IndexedDB shows Firestore cache","Multi-tab scenario handled without crash"],"evidence":["lib/firebase.ts:55 — _db = getFirestore(_app) with no persistence call","No import of enableIndexedDbPersistence anywhere in lib/"],"line":55}
{"category":"Offline","title":"No service worker — app cannot load at all when offline","fingerprint":"engineering-productivity::public/sw.js::no-service-worker","severity":"S1","effort":"E2","confidence":95,"files":["public/","next.config.mjs"],"why_it_matters":"Without a service worker, the app shows a blank page/browser error when offline. Users in poor-connectivity scenarios cannot access any functionality. PWA manifest exists but is incomplete without SW.","suggested_fix":"Implement service worker using next-pwa or workbox. Cache app shell, static assets, and runtime API responses.","acceptance_tests":["App loads cached shell when offline","Service worker registered and active","Network-first with cache fallback for APIs"],"evidence":["No public/sw.js file exists","manifest.json exists but no SW to activate it","components/pwa/install-prompt.tsx exists but is non-functional without SW"],"line":1}
{"category":"Offline","title":"No offline write queue — journal writes fail silently when offline","fingerprint":"engineering-productivity::hooks/use-journal.ts::no-offline-queue","severity":"S1","effort":"E3","confidence":90,"files":["hooks/use-journal.ts"],"why_it_matters":"Journal writes via httpsCallable fail immediately when offline with no queue or retry. For a recovery app where users may journal during meetings, this means DATA LOSS with no warning or recovery mechanism.","suggested_fix":"Implement IndexedDB-based write queue: queue writes locally when offline, sync on reconnection, handle conflicts.","acceptance_tests":["Writes queued when offline","Writes synced automatically on reconnection","User sees pending write indicator"],"evidence":["hooks/use-journal.ts calls httpsCallable directly with no offline handling","No offlineQueue/writeQueue/pendingWrites code exists in app"],"line":319}
{"category":"Offline","title":"OfflineIndicator displays misleading changes will sync message","fingerprint":"engineering-productivity::components/status/offline-indicator.tsx::misleading-sync-message","severity":"S2","effort":"E0","confidence":95,"files":["components/status/offline-indicator.tsx"],"why_it_matters":"The OfflineIndicator tells users changes will sync when reconnected but no sync mechanism exists. This creates false trust and masks data loss.","suggested_fix":"Change message to 'Some features may be unavailable while offline' until a sync queue is implemented.","acceptance_tests":["Offline message accurately reflects capabilities","No mention of sync without sync mechanism"],"evidence":["offline-indicator.tsx misleading message confirmed","No sync queue exists to fulfill the promise"],"line":11}
{"category":"GoldenPath","title":"No single npm run setup bootstrap command","fingerprint":"engineering-productivity::package.json::no-setup-script","severity":"S2","effort":"E0","confidence":100,"files":["package.json"],"why_it_matters":"New developers must run 3+ manual steps: npm install, cd functions && npm install, create .env.local, firebase login. A single setup command would reduce onboarding time from ~10 min to ~2 min.","suggested_fix":"Add setup script to package.json that installs all dependencies and prints next steps for env vars.","acceptance_tests":["npm run setup installs all dependencies","Setup script prints next steps for env vars","New clone to running app in <5 min"],"evidence":["package.json:5-71 has 66 scripts but no setup","DEVELOPMENT.md:40-47 shows multi-step manual process"],"line":5}
{"category":"GoldenPath","title":"No .env.example or .env.local.example file","fingerprint":"engineering-productivity::root::no-env-example","severity":"S2","effort":"E0","confidence":100,"files":["DEVELOPMENT.md"],"why_it_matters":"Environment variables are documented inline in DEVELOPMENT.md but there's no .env.example file to copy. Developers must manually find and copy env var names.","suggested_fix":"Create .env.local.example in project root with all required vars, documented comments, and optional vars clearly marked.","acceptance_tests":[".env.local.example exists with all required vars","cp .env.local.example .env.local works","All NEXT_PUBLIC_FIREBASE_* vars present"],"evidence":["No .env.example or .env.local.example file in root","DEVELOPMENT.md:52-72 documents vars inline"],"line":52}
{"category":"GoldenPath","title":"No environment validation/doctor script","fingerprint":"engineering-productivity::scripts/::no-doctor-script","severity":"S2","effort":"E1","confidence":100,"files":["scripts/","package.json"],"why_it_matters":"No automated way to verify development environment is correctly configured. Developers discover issues only when things fail.","suggested_fix":"Create scripts/doctor.js that checks: Node 22+, Firebase CLI installed, .env.local exists with required vars, functions/node_modules exists, functions/lib/ built.","acceptance_tests":["npm run doctor reports all prerequisites","Clear error messages for missing items","Exit code 1 if any check fails"],"evidence":["No scripts/doctor.js in scripts/ directory","package.json has no doctor script"],"line":1}
{"category":"Debugging","title":"No correlation IDs for frontend-to-backend request tracing","fingerprint":"engineering-productivity::lib/logger.ts::no-correlation-ids","severity":"S1","effort":"E2","confidence":100,"files":["lib/logger.ts","lib/firestore-service.ts"],"why_it_matters":"Cannot trace a user's journey from frontend click through Cloud Function execution to Sentry error. Engineers must manually correlate timestamps — extremely time-consuming.","suggested_fix":"Generate UUID per request on client, pass as metadata to Cloud Functions, include in all logger.error/warn calls. Add correlationId to LogContext type.","acceptance_tests":["Each client request generates unique correlation ID","Cloud Function logs include correlation ID","Sentry events contain correlation ID in extra context"],"evidence":["lib/logger.ts has no correlationId field or generation","grep correlationId|requestId|traceId returns no app code matches"],"line":3}
{"category":"Debugging","title":"8:1 console.log to logger ratio — production observability gap","fingerprint":"engineering-productivity::app/::console-log-ratio","severity":"S2","effort":"E2","confidence":90,"files":["app/","lib/","components/"],"why_it_matters":"~3111 console.log calls vs ~394 logger calls means most production errors are invisible to Sentry. Console.log output is not redacted for PII, not structured, and not captured by monitoring.","suggested_fix":"Add ESLint rule no-console (warn level) to flag new console.log additions. Prioritize converting console.log in error paths to logger.error.","acceptance_tests":["ESLint warns on new console.log","Critical error paths use logger.error","Ratio improves to <4:1"],"evidence":["Prior audit: 3111 console.log vs 394 logger calls","lib/logger.ts exists but is underutilized"],"line":1}
{"category":"CI_CD","title":"CI npm install runs twice — no dependency caching between jobs","fingerprint":"engineering-productivity::.github/workflows/ci.yml::duplicate-npm-ci","severity":"S2","effort":"E1","confidence":95,"files":[".github/workflows/ci.yml"],"why_it_matters":"The build job runs npm ci again after lint-typecheck-test already installed. npm cache helps but full install still takes time. Using artifacts or shared cache would save 1-2 minutes per run.","suggested_fix":"Use actions/cache or upload-artifact to share node_modules between jobs, or merge jobs since they are already sequential.","acceptance_tests":["Build job reuses dependencies from test job OR jobs are merged","CI total time reduced by 1-2 minutes"],"evidence":["ci.yml:24 npm ci in test job","ci.yml:149 npm ci in build job","Both use cache: npm but still run full install"],"line":133}
{"category":"CI_CD","title":"No CI step parallelization — all checks run sequentially","fingerprint":"engineering-productivity::.github/workflows/ci.yml::sequential-steps","severity":"S3","effort":"E2","confidence":80,"files":[".github/workflows/ci.yml"],"why_it_matters":"Lint, format, deps, patterns, doc check, type check, and tests all run sequentially in one job. Some are independent and could run in parallel.","suggested_fix":"Split into parallel jobs: lint+format+patterns, typecheck, tests+coverage. Use needs: for the build job to depend on all three.","acceptance_tests":["Independent checks run in parallel","Total CI time reduced","All checks still gate the build"],"evidence":["ci.yml:10-131 — all steps in single job","15+ sequential steps before tests run"],"line":10}
{"category":"Testing","title":"Playwright E2E tests configured but no test files exist","fingerprint":"engineering-productivity::package.json::phantom-e2e","severity":"S2","effort":"E2","confidence":85,"files":["package.json"],"why_it_matters":"@playwright/test is in devDependencies but no E2E test files are visible. This is dead dependency weight and a gap in test coverage for critical user flows.","suggested_fix":"Add basic E2E tests for critical flows (login, create journal entry, search meetings), or remove @playwright/test from devDependencies if E2E is not planned.","acceptance_tests":["E2E tests exist for at least 3 critical flows OR Playwright removed","E2E tests run in CI (if added)"],"evidence":["package.json:115 — @playwright/test: ^1.58.1","No .spec.ts or .e2e.ts files found"],"line":115}
{"category":"Testing","title":"Test compilation required before running — slow feedback loop","fingerprint":"engineering-productivity::package.json::test-build-step","severity":"S2","effort":"E1","confidence":90,"files":["package.json","tsconfig.test.json"],"why_it_matters":"Tests require tsc compilation step before running, adding 10-30 seconds to every test run. This slows the red-green-refactor cycle and discourages frequent testing.","suggested_fix":"Consider using tsx or ts-node/esm for direct TypeScript test execution, or use Node --experimental-strip-types flag (Node 22+). Alternatively cache compiled tests.","acceptance_tests":["npm test starts running tests within 5 seconds","No manual compilation step needed","Tests still type-check correctly"],"evidence":["package.json:10 — test script requires test:build first","package.json:11 — test:build runs tsc + tsc-alias"],"line":10}
{"category":"Engineering","title":"66 npm scripts with no discoverability or documentation","fingerprint":"engineering-productivity::package.json::script-sprawl","severity":"S3","effort":"E1","confidence":90,"files":["package.json"],"why_it_matters":"66 npm scripts is overwhelming for new developers. Without categorization or documentation, developers don't know which scripts to use for common tasks.","suggested_fix":"Create SCRIPTS.md documenting all scripts grouped by category. Add a help script that prints common commands.","acceptance_tests":["SCRIPTS.md exists with categorized script listing","npm run help prints common commands","New developers can find relevant scripts in <1 minute"],"evidence":["package.json:5-71 contains 66 scripts","No SCRIPTS.md or script documentation exists"],"line":5}
{"category":"Engineering","title":"App Check has been disabled since December 2025 — security gap","fingerprint":"engineering-productivity::lib/firebase.ts::app-check-disabled","severity":"S1","effort":"E1","confidence":100,"files":["lib/firebase.ts"],"why_it_matters":"App Check (reCAPTCHA Enterprise bot protection) has been commented out since December 2025. Without App Check, Cloud Functions are unprotected from unauthorized API calls and bot abuse.","suggested_fix":"Re-enable App Check in lib/firebase.ts. If throttle issues persist, implement App Check in debug mode for development with proper production configuration.","acceptance_tests":["App Check initialized in production","Debug mode works in development","Cloud Functions protected from unauthorized calls"],"evidence":["lib/firebase.ts:57-90 — entire App Check block commented out","Comment says will re-enable after throttle clears (Dec 31) — 38 days overdue"],"line":57}