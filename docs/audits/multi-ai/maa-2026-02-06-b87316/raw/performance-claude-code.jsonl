{"category":"Bundle Size","title":"images.unoptimized: true disables all Next.js image optimization","fingerprint":"Bundle Size::next.config.mjs::images_unoptimized","severity":"S1","effort":"E2","confidence":100,"files":["next.config.mjs"],"line":15,"symbols":["nextConfig"],"performance_details":{"current_metric":"images.unoptimized: true - all images served as raw originals with no resizing, format conversion, or lazy loading optimization","expected_improvement":"30-60% reduction in image transfer size via WebP/AVIF conversion, responsive srcsets, and automatic lazy loading","affected_metric":"LCP"},"optimization":{"description":"The static export (output: 'export') forces unoptimized images because Next.js Image Optimization requires a server. Use a build-time image optimization pipeline (e.g., sharp via a script, or next-optimized-images plugin) to pre-generate WebP/AVIF variants and responsive sizes at build time.","code_example":"// Alternative: Use a custom loader with a CDN like Firebase Hosting's built-in image serving\n// Or pre-optimize images at build time with sharp","verification":["Check that images are served in modern formats (WebP/AVIF) after optimization","Verify LCP improvement with Lighthouse"]},"evidence":["next.config.mjs:14-16: images: { unoptimized: true }","output: 'export' forces this setting","5 files use next/image but optimization is disabled globally","Background image at app/page.tsx:26 uses raw url('/images/wood-table.jpg')"],"notes":"This is the single highest-impact optimization. The wood-table.jpg background is the likely LCP element on the landing page and is served unoptimized."}
{"category":"Bundle Size","title":"626KB largest chunk likely contains Firebase + Framer Motion","fingerprint":"Bundle Size::out/_next/static/chunks::largest_chunk_626k","severity":"S2","effort":"E2","confidence":75,"files":["package.json"],"line":91,"symbols":["firebase","framer-motion"],"performance_details":{"current_metric":"Largest JS chunk: 626KB. Top 5 chunks: 626KB, 357KB, 277KB, 253KB, 218KB. Total static JS: 3.4MB across 42 chunks.","expected_improvement":"20-40% reduction in initial JS by lazy-loading firebase/firestore and framer-motion modules","affected_metric":"LCP"},"optimization":{"description":"Firebase SDK (firebase: ^12.6.0) and Framer Motion (framer-motion: ^12.23.0) are heavy libraries. Firebase is imported in 37+ files. Framer Motion is imported in 37 component files. Consider: (1) dynamic imports for Framer Motion components not visible on initial load, (2) ensure Firebase modular tree-shaking is effective by avoiding re-exports through barrel files.","code_example":"// Lazy-load framer-motion for components below the fold:\nconst MotionDiv = dynamic(() => import('framer-motion').then(m => m.motion.div), { ssr: false });","verification":["Run npx @next/bundle-analyzer to identify which libraries are in which chunks","Compare largest chunk size before and after optimization"]},"evidence":["out/_next/static/chunks/620b5119fa2b0078.js: 626KB","37 files import framer-motion","firebase imported in 37+ files across codebase","Total static output: 3.4MB JS across 42 chunks"]}
{"category":"Bundle Size","title":"Leaflet + react-leaflet loaded eagerly despite being used in one component","fingerprint":"Bundle Size::components/maps/meeting-map.tsx::leaflet_not_lazy","severity":"S2","effort":"E0","confidence":95,"files":["components/maps/meeting-map.tsx","components/notebook/pages/resources-page.tsx"],"line":1,"symbols":["MeetingMap","leaflet","react-leaflet"],"performance_details":{"current_metric":"Leaflet (~40KB) + react-leaflet + leaflet.markercluster loaded in meeting-map.tsx. MeetingMap IS dynamically imported in resources-page.tsx:103 - but leaflet CSS/JS may still be bundled.","expected_improvement":"Leaflet libraries excluded from initial bundle for non-map pages","affected_metric":"bundle"},"optimization":{"description":"MeetingMap is already dynamically imported in resources-page.tsx (line 103), which is good. Verify that leaflet CSS is also lazily loaded (not in globals.css). Confirm tree-shaking works for leaflet.markercluster.","verification":["Check that leaflet JS is not in the initial page chunks using bundle analyzer","Verify leaflet CSS is loaded dynamically, not in globals.css"]},"evidence":["components/notebook/pages/resources-page.tsx:103: const MeetingMap = dynamic(() => import('@/components/maps/meeting-map'), { loading: () => null, ssr: false })","Only 1 component file imports leaflet directly"]}
{"category":"Rendering","title":"37 components import framer-motion without code splitting","fingerprint":"Rendering::components::framer_motion_widespread","severity":"S2","effort":"E2","confidence":80,"files":["components/journal/entry-card.tsx","components/journal/entry-forms/mood-form.tsx","components/notebook/book-cover.tsx","components/notebook/notebook-shell.tsx"],"line":1,"symbols":["motion","AnimatePresence"],"performance_details":{"current_metric":"37 component files import from framer-motion. This ensures the entire framer-motion library is in the critical path regardless of which page loads.","expected_improvement":"Reduced initial JS parse time by deferring animation library for below-fold components","affected_metric":"INP"},"optimization":{"description":"Framer Motion is imported in 37 files spanning journal forms, entry cards, notebook shell, celebrations, growth cards, widgets, and onboarding. While the landing page legitimately needs it for the book cover animation, journal entry forms and growth cards could use CSS animations instead or lazy-load the framer-motion dependency.","verification":["Check bundle analyzer to see framer-motion's contribution to initial load","Test that replacing framer-motion with CSS transitions on entry-card.tsx doesn't regress UX"]},"evidence":["37 files import from 'framer-motion' including: entry-card.tsx, all 5 entry forms, growth cards, widgets, celebrations, notebook shell","entry-card.tsx uses motion.div for simple fade-in that could be CSS"]}
{"category":"Rendering","title":"Journal entry forms eagerly rendered in JournalHub","fingerprint":"Rendering::components/journal/journal-hub.tsx::eager_forms","severity":"S3","effort":"E1","confidence":85,"files":["components/journal/journal-hub.tsx"],"line":101,"symbols":["MoodForm","GratitudeForm","InventoryForm","DailyLogForm","FreeWriteForm"],"performance_details":{"current_metric":"5 entry form components (MoodForm, GratitudeForm, InventoryForm, DailyLogForm, FreeWriteForm) are statically imported at the top of journal-hub.tsx and conditionally rendered. Their JS is parsed even when forms aren't open.","expected_improvement":"Reduced initial JS parse for journal page by deferring form components until user clicks 'new entry'","affected_metric":"INP"},"optimization":{"description":"Use dynamic imports for the 5 entry form components since they're only shown when the user explicitly creates a new entry. This defers their JS parsing until needed.","code_example":"const MoodForm = dynamic(() => import('./entry-forms/mood-form').then(m => ({ default: m.MoodForm })), { ssr: false });\nconst GratitudeForm = dynamic(() => import('./entry-forms/gratitude-form').then(m => ({ default: m.GratitudeForm })), { ssr: false });","verification":["Verify form components are in separate chunks in bundle analyzer","Confirm forms still load quickly when user clicks 'new entry'"]},"evidence":["components/journal/journal-hub.tsx:15-19: Static imports of MoodForm, GratitudeForm, InventoryForm, FreeWriteForm, DailyLogForm","components/journal/journal-hub.tsx:101-134: Conditionally rendered based on activeEntryType state"]}
{"category":"Data Fetching","title":"onSnapshot real-time listener on journal fetches up to 100 docs on every change","fingerprint":"Data Fetching::hooks/use-journal.ts::onSnapshot_full_refetch","severity":"S2","effort":"E2","confidence":70,"files":["hooks/use-journal.ts"],"line":284,"symbols":["useJournal","onSnapshot"],"performance_details":{"current_metric":"onSnapshot listener on journal collection (limit 100) processes ALL 100 documents on every change, even if only 1 document changed. Firestore sends full query result on each update.","expected_improvement":"Incremental updates using docChanges() instead of full snapshot processing could reduce processing by 90%+ for single-doc changes","affected_metric":"render"},"optimization":{"description":"The onSnapshot callback at line 284 iterates over snapshot.forEach(doc => processJournalDoc(doc.id, doc.data())). When a single entry is added/modified, Firestore still sends all 100 docs. Use snapshot.docChanges() to only process added/modified/removed docs incrementally.","code_example":"const unsubscribe = onSnapshot(q, (snapshot) => {\n  snapshot.docChanges().forEach((change) => {\n    if (change.type === 'added') { /* add to state */ }\n    if (change.type === 'modified') { /* update in state */ }\n    if (change.type === 'removed') { /* remove from state */ }\n  });\n});","verification":["Log docChanges().length vs snapshot.size to measure savings","Profile React re-renders before and after"]},"evidence":["hooks/use-journal.ts:284-308: onSnapshot processes full snapshot on every change","hooks/use-journal.ts:280: limit(QUERY_LIMITS.JOURNAL_MAX) - JOURNAL_MAX likely 100","hooks/use-journal.ts:294: setEntries(fetchedEntries) - replaces entire array on each update"],"notes":"Firestore SDK does local caching, so bandwidth is minimal, but JS processing of 100 docs + React reconciliation on every change is wasteful."}
{"category":"Data Fetching","title":"today-page.tsx has 10 useEffect hooks - potential waterfall fetching","fingerprint":"Data Fetching::components/notebook/pages/today-page.tsx::many_effects","severity":"S2","effort":"E2","confidence":65,"files":["components/notebook/pages/today-page.tsx"],"line":1,"symbols":["TodayPage"],"performance_details":{"current_metric":"today-page.tsx contains 10 useEffect hooks. If these contain sequential data fetches, they create a waterfall. The file also imports 11 useMemo/useCallback/memo instances suggesting complex derived state.","expected_improvement":"Consolidating effects and parallelizing fetches could reduce page load time by 200-500ms","affected_metric":"LCP"},"optimization":{"description":"Audit the 10 useEffect hooks in today-page.tsx. Consolidate related effects. Ensure data fetches happen in parallel (Promise.all) rather than sequentially. The component already imports TodayPageSkeleton for loading states, which is good.","verification":["Profile today-page render in React DevTools to identify waterfall patterns","Check if reducing effects reduces re-render count"]},"evidence":["today-page.tsx: 10 useEffect occurrences (highest of any component)","today-page.tsx: 11 useMemo/useCallback/memo usages","Imports from 14 different modules suggesting high complexity"]}
{"category":"Offline Support","title":"No offline write queue - writes fail silently when offline","fingerprint":"Offline Support::components/status/offline-indicator.tsx::no_write_queue","severity":"S2","effort":"E3","confidence":90,"files":["components/status/offline-indicator.tsx","hooks/use-journal.ts"],"line":6,"symbols":["OfflineIndicator","useJournal"],"performance_details":{"current_metric":"OfflineIndicator shows 'changes will sync when reconnected' but there is no actual sync queue. No IndexedDB or localStorage queue for offline writes. Cloud Function calls (useJournal.addEntry) will fail with network error when offline, and the error is surfaced to user but data is lost.","expected_improvement":"Implementing an offline queue would prevent data loss during network interruptions","affected_metric":"render"},"optimization":{"description":"The OfflineIndicator at line 47 claims 'changes will sync when reconnected' but useJournal.addEntry calls Cloud Functions which require network. No IndexedDB/localStorage queue exists. Options: (1) Queue writes in localStorage/IndexedDB when offline, (2) Use Firestore's built-in offline persistence for direct writes (but writes go through Cloud Functions, not direct), (3) At minimum, update the offline message to accurately reflect behavior.","verification":["Go offline in DevTools, create a journal entry, verify behavior","Check if data is lost or queued"]},"evidence":["components/status/offline-indicator.tsx:47: 'Offline - changes will sync when reconnected'","hooks/use-journal.ts:354: retryCloudFunction(saveJournalEntry, ...) - requires network","grep for indexedDB/localStorage: no write queue found in hooks/ or lib/","5 files reference navigator.onLine but none implement write queuing"]}
{"category":"Core Web Vitals","title":"No Suspense boundaries in app routes","fingerprint":"Core Web Vitals::app::no_suspense","severity":"S3","effort":"E1","confidence":90,"files":["app/page.tsx","app/journal/page.tsx","app/admin/page.tsx"],"line":1,"symbols":["Home","JournalPage"],"performance_details":{"current_metric":"Zero Suspense boundaries found in any app/ route file. Loading states are handled per-component (e.g., JournalHub shows a spinner) rather than via React Suspense.","expected_improvement":"Suspense boundaries would enable streaming and progressive rendering, improving perceived load time","affected_metric":"LCP"},"optimization":{"description":"Add Suspense boundaries around heavy client components in app routes. This enables React to show fallback UI immediately while heavy components load. Since this is a static export, streaming SSR isn't available, but Suspense still helps with code-split component loading.","code_example":"import { Suspense } from 'react';\n\nexport default function JournalPage() {\n  return (\n    <Suspense fallback={<JournalSkeleton />}>\n      <JournalHub />\n    </Suspense>\n  );\n}","verification":["Add Suspense to journal page, measure time-to-interactive improvement"]},"evidence":["grep for 'Suspense|lazy(' in app/ routes: 0 matches","app/journal/page.tsx: directly renders <JournalHub /> with no Suspense","Loading states are component-internal (journal-hub.tsx:39-45 shows spinner)"]}
{"category":"Core Web Vitals","title":"Landing page background image loaded via CSS url() not preloaded","fingerprint":"Core Web Vitals::app/page.tsx::background_not_preloaded","severity":"S2","effort":"E0","confidence":95,"files":["app/page.tsx"],"line":26,"symbols":["Home"],"performance_details":{"current_metric":"The LCP element (wood-table.jpg background) is loaded via inline style backgroundImage: url('/images/wood-table.jpg'). CSS backgrounds are discovered late by the browser (only after CSSOM is built), making this a late-discovered LCP resource.","expected_improvement":"Preloading could improve LCP by 200-500ms by letting the browser start downloading the image earlier","affected_metric":"LCP"},"optimization":{"description":"Add a <link rel='preload'> for the wood-table.jpg image in the layout or page head. Since this is a static export, add it to app/layout.tsx <head> or use Next.js metadata API.","code_example":"// In app/page.tsx or app/layout.tsx:\n<head>\n  <link rel=\"preload\" href=\"/images/wood-table.jpg\" as=\"image\" />\n</head>","verification":["Run Lighthouse and check if wood-table.jpg appears in 'preloaded' resources","Measure LCP before and after"]},"evidence":["app/page.tsx:26: style={{ backgroundImage: `url('/images/wood-table.jpg')` }}","No <link rel='preload'> for this image found in layout.tsx","This is likely the LCP element as it's the largest visible content on landing"]}
{"category":"Memory","title":"4 real-time onSnapshot listeners active simultaneously","fingerprint":"Memory::hooks::multiple_onSnapshot","severity":"S3","effort":"E1","confidence":80,"files":["hooks/use-journal.ts","components/providers/profile-context.tsx","components/notebook/pages/today-page.tsx","lib/database/firestore-adapter.ts"],"line":284,"symbols":["onSnapshot"],"performance_details":{"current_metric":"4 separate onSnapshot real-time listeners found: (1) use-journal.ts:284 for journal entries, (2) profile-context.tsx:109 for user profile, (3) today-page.tsx:554 for daily log, (4) firestore-adapter.ts:76 for database adapter. All active simultaneously when notebook is open.","expected_improvement":"Consolidating listeners or converting some to one-time fetches could reduce Firestore read costs and memory usage","affected_metric":"memory"},"optimization":{"description":"Evaluate which listeners truly need real-time updates. The user profile (profile-context.tsx) changes rarely and could use getDoc() with manual refresh. The daily log (today-page.tsx) updates only when the user saves, so could refresh after save instead of maintaining a listener.","verification":["Monitor Firestore reads in Firebase Console before and after","Check memory usage in Chrome DevTools with/without listeners"]},"evidence":["hooks/use-journal.ts:284: onSnapshot on journal collection","components/providers/profile-context.tsx:109: onSnapshot on user profile","components/notebook/pages/today-page.tsx:554: onSnapshot on daily log doc","lib/database/firestore-adapter.ts:76: onSnapshot in adapter","All have proper cleanup (return () => unsubscribe())"]}
{"category":"AI Performance Patterns","title":"No recharts dependency despite being listed in scope - charts may be unused","fingerprint":"AI Performance Patterns::package.json::recharts_unused","severity":"S3","effort":"E0","confidence":60,"files":["package.json"],"line":105,"symbols":["recharts"],"performance_details":{"current_metric":"recharts 2.15.4 is in package.json dependencies (~200KB) but grep found 0 files importing from 'recharts' in the codebase. The dependency may be unused or only used in a file not matching the search pattern.","expected_improvement":"Removing unused recharts would save ~200KB from bundle","affected_metric":"bundle"},"optimization":{"description":"Verify whether recharts is actually used anywhere. If not, remove it from package.json to save ~200KB.","code_example":"npm uninstall recharts","verification":["Run npx knip to confirm recharts is unused","After removal, verify build succeeds and no pages break"]},"evidence":["package.json:105: \"recharts\": \"2.15.4\"","grep for 'from [\"']recharts' across *.ts and *.tsx: 0 matches","MoodSparkline component (today-page.tsx:9) might use it but grep found no import"]}
