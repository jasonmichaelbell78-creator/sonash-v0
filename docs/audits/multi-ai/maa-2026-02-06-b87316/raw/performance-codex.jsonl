{"category":"Bundle Size","title":"Entire /meetings/all route is client-only, inflating JS payload","fingerprint":"Bundle Size::app/meetings/all/page.tsx::client-only-route","severity":"S2","effort":"E2","confidence":70,"files":["app/meetings/all/page.tsx"],"symbols":["AllMeetingsPage"],"performance_details":{"current_metric":"Route hydrates full client bundle for filtering, map toggle, and list UI.","expected_improvement":"Reduce initial JS and hydration cost for /meetings/all by splitting static shell into a Server Component and deferring client-only subtrees.","affected_metric":"bundle"},"optimization":{"description":"Split static header/layout into a Server Component and move only interactive filters/list/map into a client subcomponent. Keep the dynamic map import but avoid pulling non-interactive markup into client scope.","code_example":"// app/meetings/all/page.tsx (server)\n// import MeetingsClient from './meetings-client'\n// return <MeetingsClient />","verification":["next build --profile and compare route JS size before/after","Check hydration timing with React DevTools Profiler"]},"evidence":["app/meetings/all/page.tsx is marked \"use client\" at the top of the route file, forcing full client rendering."],"notes":"Dynamic map import is already used, but the route still hydrates all layout/filter UI.","line":1}
{"category":"Rendering","title":"Journal entry feed renders full grouped list without virtualization","fingerprint":"Rendering::components/journal/entry-feed.tsx::no-virtualization","severity":"S2","effort":"E2","confidence":75,"files":["components/journal/entry-feed.tsx"],"symbols":["EntryFeed","EntryCard"],"performance_details":{"current_metric":"All grouped entries are mapped into the DOM with per-entry click handlers; no windowing or pagination.","expected_improvement":"Reduce render cost and improve INP on large journals by virtualizing or paginating entry cards.","affected_metric":"render"},"optimization":{"description":"Implement list virtualization (e.g., react-virtual) or add pagination/infinite scroll to cap rendered EntryCard count.","verification":["Profile render time in React DevTools with >100 entries","Measure INP before/after virtualization"]},"evidence":["EntryFeed maps all grouped entries into a grid without virtualization and renders EntryCard for each item."],"line":314}
{"category":"Data Fetching","title":"Meetings-by-day query fetches entire day without limit or pagination","fingerprint":"Data Fetching::lib/db/meetings.ts::unbounded-query","severity":"S2","effort":"E1","confidence":80,"files":["lib/db/meetings.ts"],"symbols":["MeetingsService.getMeetingsByDay"],"performance_details":{"current_metric":"getMeetingsByDay uses a where() query without limit(), then sorts client-side.","expected_improvement":"Reduce Firestore read volume and client processing time for meeting-heavy days by adding limit/pagination or server-side time windowing.","affected_metric":"memory"},"optimization":{"description":"Add limit() and paginate by time or use a time window query (e.g., upcoming meetings). Prefer indexed orderBy('time') once index is available.","verification":["Check Firestore read counts before/after","Profile client CPU during meeting fetch"]},"evidence":["getMeetingsByDay builds a query with where('day','==',day) but no limit() and fetches all docs before sorting."],"line":106}
{"category":"Data Fetching","title":"Sober living list loads entire collection without limit/pagination","fingerprint":"Data Fetching::lib/db/sober-living.ts::unbounded-query","severity":"S2","effort":"E1","confidence":75,"files":["lib/db/sober-living.ts"],"symbols":["SoberLivingService.getAllHomes"],"performance_details":{"current_metric":"getAllHomes queries the full sober_living collection with no limit() or pagination.","expected_improvement":"Lower read volume and faster list rendering by paginating or filtering server-side.","affected_metric":"memory"},"optimization":{"description":"Add limit() with cursor pagination and apply search/filter parameters at query time instead of client-side.","verification":["Firestore read counts for sober_living","Measure render time with large dataset"]},"evidence":["getAllHomes uses getDocs(query(collection(...))) without limit() or pagination."],"line":30}
{"category":"AI Performance Patterns","title":"Resources page fetches all meetings via deprecated API then filters client-side","fingerprint":"AI Performance Patterns::components/notebook/pages/resources-page.tsx::fetch-all-then-filter","severity":"S2","effort":"E1","confidence":75,"files":["components/notebook/pages/resources-page.tsx"],"symbols":["triggerRefresh"],"performance_details":{"current_metric":"When viewMode === 'all', the page calls getAllMeetings() and filters/sorts on the client.","expected_improvement":"Avoid fetch-all patterns by using paginated API and server-side filtering; reduces payload size and CPU.","affected_metric":"render"},"optimization":{"description":"Replace getAllMeetings() usage with getAllMeetingsPaginated() and apply filters server-side. Add load-more for large datasets.","verification":["Confirm no calls to getAllMeetings() in resources page","Measure render time and payload size"]},"evidence":["triggerRefresh() calls MeetingsService.getAllMeetings() when viewMode is 'all'."],"line":668}
{"category":"Core Web Vitals","title":"Landing page background image bypasses next/image optimization","fingerprint":"Core Web Vitals::app/page.tsx::css-background-lcp","severity":"S2","effort":"E1","confidence":70,"files":["app/page.tsx"],"symbols":["Home"],"performance_details":{"current_metric":"Hero background uses CSS backgroundImage without responsive sizing or priority hints.","expected_improvement":"Improve LCP by converting to next/image (or preloading the background asset with appropriate sizes).","affected_metric":"LCP"},"optimization":{"description":"Replace CSS background with a next/image component or add a preload hint for the hero asset and serve appropriately sized variants.","verification":["Lighthouse LCP delta before/after","Check network waterfall for hero asset"]},"evidence":["Landing page sets backgroundImage to /images/wood-table.jpg via inline style."],"line":23}
{"category":"Core Web Vitals","title":"Global next/image optimization disabled","fingerprint":"Core Web Vitals::next.config.mjs::images-unoptimized","severity":"S2","effort":"E1","confidence":80,"files":["next.config.mjs"],"symbols":["nextConfig"],"performance_details":{"current_metric":"next/image optimization is disabled via images.unoptimized=true.","expected_improvement":"Enable image optimization (or a custom loader) to reduce LCP and bandwidth on image-heavy routes.","affected_metric":"LCP"},"optimization":{"description":"If static export constraints require unoptimized, consider a custom image loader or pre-optimized images. Otherwise, remove unoptimized: true.","verification":["Compare image payload sizes before/after","Lighthouse LCP improvements"]},"evidence":["next.config.mjs sets images.unoptimized to true."],"line":12}
{"category":"Offline Support","title":"Firestore client has no offline persistence or sync queue configured","fingerprint":"Offline Support::lib/firebase.ts::no-offline-persistence","severity":"S3","effort":"E2","confidence":65,"files":["lib/firebase.ts"],"symbols":["initializeFirebase"],"performance_details":{"current_metric":"Firestore initialized without enableIndexedDbPersistence or local cache; offline writes lack durable queue.","expected_improvement":"Enable offline persistence for better offline UX and reduced refetch after reconnect.","affected_metric":"memory"},"optimization":{"description":"Enable Firestore persistence (enableIndexedDbPersistence) and add UI states for pending/synced writes if needed.","verification":["Test offline recipe (create entries offline, reconnect)","Monitor read counts on reconnect"]},"evidence":["Firebase initialization calls getFirestore without persistence configuration."],"line":54}
{"category":"Memory","title":"OfflineIndicator timeout is not cleared on unmount","fingerprint":"Memory::components/status/offline-indicator.tsx::timeout-cleanup","severity":"S3","effort":"E0","confidence":70,"files":["components/status/offline-indicator.tsx"],"symbols":["OfflineIndicator"],"performance_details":{"current_metric":"setTimeout is created inside online handler but never cleared, which can trigger state updates after unmount.","expected_improvement":"Avoid potential memory leaks and state updates on unmounted component.","affected_metric":"memory"},"optimization":{"description":"Store timeout id in a ref and clear it in the cleanup function or before setting a new timeout.","verification":["React strict-mode unmount checks","No setState-on-unmounted warnings"]},"evidence":["handleOnline sets a timeout without cleanup on unmount."],"line":11}
