{"category":"GoldenPath","title":"Install/build can fail due to missing local file dependency (@dataconnect/generated)","fingerprint":"engineering-productivity::package.json::missing-local-file-dependency","severity":"S0","effort":"E1","confidence":95,"files":["package.json","DOCUMENTATION_INDEX.md"],"why_it_matters":"A fresh clone may fail npm ci because a dependency points at a missing local folder. This blocks onboarding and makes CI brittle.","suggested_fix":"Decide the source of truth for src/dataconnect-generated: (A) commit it, (B) generate it deterministically in a preinstall/prepare step + CI, or (C) remove/replace the dependency with a published package.","acceptance_tests":["rm -rf node_modules && npm ci","npm run build","npm run test:coverage"],"evidence":["package.json:76 \"@dataconnect/generated\": \"file:src/dataconnect-generated\"","repo filesystem check: MISSING","DOCUMENTATION_INDEX.md:464+ links to src/dataconnect-generated/* that do not exist"],"line":76}
{"category":"GoldenPath","title":"DEVELOPMENT.md references npm script type-check that does not exist","fingerprint":"engineering-productivity::DEVELOPMENT.md::missing-npm-script-type-check","severity":"S1","effort":"E0","confidence":100,"files":["DEVELOPMENT.md","package.json"],"why_it_matters":"Onboarding instructions point to a command that fails immediately, creating trust erosion and wasted time during setup and troubleshooting.","suggested_fix":"Either add \"type-check\": \"tsc --noEmit\" to package.json or update DEVELOPMENT.md to reference the existing command (npx tsc --noEmit) consistently.","acceptance_tests":["npm run --list | grep type-check","npm run type-check (if added)"],"evidence":["DEVELOPMENT.md:848 - Check TypeScript errors: npm run type-check","package.json scripts: no type-check entry"],"line":848}
{"category":"GoldenPath","title":"README lacks runnable Quick Start commands (no npm ci/dev/test instructions)","fingerprint":"engineering-productivity::README.md::missing-quick-start-commands","severity":"S2","effort":"E0","confidence":90,"files":["README.md","DEVELOPMENT.md"],"why_it_matters":"New contributors expect the README to get them to a running app fast. When Quick Start is not actionable, setup time increases and people bounce to other docs or guess.","suggested_fix":"Add a minimal Quick Start block to README: npm ci, copy .env.local.example → .env.local, npm run dev, and the fastest test command. Link to DEVELOPMENT.md for deeper setup.","acceptance_tests":["grep -n 'npm ci|npm run dev|npm test' README.md returns matches","Fresh clone: follow README only to start dev server"],"evidence":["README.md has a Quick Start bullet but no commands present"],"line":1}
{"category":"GoldenPath","title":"Environment example file naming is non-standard (.env.local.example; no .env.example)","fingerprint":"engineering-productivity::.env.local.example::nonstandard-env-example-naming","severity":"S3","effort":"E0","confidence":95,"files":[".env.local.example"],"why_it_matters":"Many tools and contributor expectations look for .env.example. Non-standard naming causes small but recurring friction and confusion in onboarding guides.","suggested_fix":"Either add a copy/symlinked .env.example or document explicitly in README Quick Start which file to copy and why.","acceptance_tests":["test -f .env.example (if added)","README Quick Start references the correct env example file"],"evidence":["Repo contains .env.local.example but not .env.example"],"line":1}
{"category":"Testing","title":"Tests require a compile step (tsc + tsc-alias) before running; slows local feedback and hooks","fingerprint":"engineering-productivity::package.json::tests-require-build-step","severity":"S1","effort":"E2","confidence":95,"files":["package.json","tsconfig.test.json"],"why_it_matters":"Requiring a build step before every test run increases iteration time and makes pre-commit slower, especially for small changes. Developers feel this daily.","suggested_fix":"Consider a faster test runner flow: (A) run Node tests directly on TS via tsx in dev, or (B) switch to a TS-native runner (Vitest) while keeping current build-based flow for CI if desired.","acceptance_tests":["Introduce npm run test:watch and confirm it runs in <5s startup","CI still runs a deterministic test command"],"evidence":["package.json:10-12 test requires test:build (tsc -p tsconfig.test.json && tsc-alias)"],"line":10}
{"category":"Testing","title":"Repo context expects Jest but project uses Node's built-in test runner; tooling expectation mismatch","fingerprint":"engineering-productivity::package.json::jest-mismatch","severity":"S2","effort":"E0","confidence":90,"files":["package.json",".github/workflows/ci.yml"],"why_it_matters":"When teams assume Jest, they look for jest.config.* and Jest CLI flags. Mismatch causes confusion and slows debugging test failures.","suggested_fix":"Update DEVELOPMENT.md/README to explicitly state the test runner (node --test) and how to run focused tests.","acceptance_tests":["Docs clearly state runner and show a run one test file command","New contributors can run a single test without reading scripts"],"evidence":["package.json uses node --test (no jest dependency)"],"line":10}
{"category":"Debugging","title":"Console.log used in production paths (firestore-service, TodayPage) instead of logger with levels","fingerprint":"engineering-productivity::lib/firestore-service.ts::console-log-in-prod-paths","severity":"S2","effort":"E1","confidence":95,"files":["lib/firestore-service.ts","components/notebook/pages/today-page.tsx"],"why_it_matters":"Ad-hoc console logging is noisy, inconsistent, and hard to filter. It also risks leaking data and makes debugging harder because logs aren't normalized.","suggested_fix":"Replace non-example console logs with logger.debug/info. Add a single debug flag mechanism (env var) to enable verbose logs locally.","acceptance_tests":["grep -R 'console.log' app lib components returns only examples/docs or zero","Run a key flow and confirm logs are structured and level-controlled"],"evidence":["lib/firestore-service.ts:229 console.log sending to Cloud Function","components/notebook/pages/today-page.tsx:728+ console.log Weekly Stats Debug"],"line":229}
{"category":"Debugging","title":"Logger is present but lacks correlation/request IDs; tracing across async flows is difficult","fingerprint":"engineering-productivity::lib/logger.ts::missing-correlation-ids","severity":"S2","effort":"E2","confidence":90,"files":["lib/logger.ts","components/providers/error-boundary.tsx"],"why_it_matters":"Without a correlation ID, it's hard to connect logs from UI actions, cloud function calls, and error boundaries into a single timeline.","suggested_fix":"Add optional requestId/correlationId to logger context and propagate it through: UI action → secure-caller → callable payload.","acceptance_tests":["grep -R 'correlationId|x-request-id' shows new implementation points","A single user action emits multiple logs sharing the same correlationId"],"evidence":["lib/logger.ts:99-106 payload has no request/correlation id field","repo-wide search for correlationId: no matches"],"line":99}
{"category":"Offline","title":"Offline UI promises changes will sync, but no service worker or Firestore persistence is enabled","fingerprint":"engineering-productivity::components/status/offline-indicator.tsx::offline-promise-no-infra","severity":"S1","effort":"E2","confidence":95,"files":["components/status/offline-indicator.tsx","public/manifest.json"],"why_it_matters":"Users/devs will assume offline writes are queued and safe. Without persistence/queue, offline edits can fail silently or be lost.","suggested_fix":"Either (A) implement real offline support (Firestore persistence + queued writes + conflict strategy), or (B) downgrade the messaging to a truthful indicator until infra exists.","acceptance_tests":["Confirm Firestore persistence call exists OR offline indicator text no longer claims sync","Add a basic offline write test plan in DEVELOPMENT.md"],"evidence":["components/status/offline-indicator.tsx:42-47 'Offline - changes will sync when reconnected'","No service worker found","No enableIndexedDbPersistence call found"],"line":46}
{"category":"Offline","title":"PWA install prompt exists but no service worker; offline shell likely incomplete","fingerprint":"engineering-productivity::components/pwa/install-prompt.tsx::pwa-without-sw","severity":"S2","effort":"E2","confidence":85,"files":["components/pwa/install-prompt.tsx","public/manifest.json"],"why_it_matters":"Developers will expect PWA install + offline shell to work together. Having install UX without the offline plumbing causes confusing QA and user-reported bugs.","suggested_fix":"Add a service worker strategy or clearly scope the feature as install-only until SW is implemented.","acceptance_tests":["public/sw.js exists and is registered OR docs/UX clearly state install-only","Manual: go offline and confirm app shell loads"],"evidence":["components/pwa/install-prompt.tsx includes offline install messaging","public contains manifest.json but no sw.js"],"line":104}
{"category":"CI_CD","title":"CI is a single large job (lint+format+deps+tests+validations); missed parallelization opportunities","fingerprint":"engineering-productivity::.github/workflows/ci.yml::single-job-bottleneck","severity":"S2","effort":"E2","confidence":90,"files":[".github/workflows/ci.yml"],"why_it_matters":"When everything runs serially, CI latency increases and developers wait longer for feedback. Splitting independent steps into parallel jobs can materially improve throughput.","suggested_fix":"Split CI into parallel jobs: (1) lint/format/patterns, (2) typecheck, (3) tests+coverage, (4) docs/schema validations. Use needs/outputs to keep gating behavior.","acceptance_tests":["CI completes faster on typical PRs","All required checks still gate merges appropriately"],"evidence":[".github/workflows/ci.yml:8-16 only one job defined: lint-typecheck-test"],"line":8}
{"category":"Engineering","title":"No single golden path command that mirrors CI gates (missing npm run check)","fingerprint":"engineering-productivity::package.json::missing-unified-check-command","severity":"S2","effort":"E0","confidence":95,"files":["package.json"],"why_it_matters":"Developers shouldn't have to remember many separate commands to match CI. A single local command reduces mistakes and speeds up pre-PR confidence checks.","suggested_fix":"Add npm run check that runs the same core gates as CI in a sensible order (lint → format:check → patterns:check → typecheck → test).","acceptance_tests":["npm run check exits 0 on clean tree","npm run check fails when lint/test/typecheck fails"],"evidence":["package.json includes many *:check scripts but none named check"],"line":1}
