{"category":"Security","title":"Firebase App Check is disabled in client initialization path","fingerprint":"Security::lib/firebase.ts::initializeFirebase::appcheck_disabled","severity":"S1","effort":"E1","confidence":96,"files":["lib/firebase.ts"],"symbols":["initializeFirebase","getFirebase"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Cloud Functions and Firestore rely on layered abuse controls; shipping with App Check disabled weakens bot/automation resistance.","suggested_fix":"Re-enable App Check initialization with environment-gated debug behavior and sanitized logging for failures.","acceptance_tests":["npm test","npm run lint","Verify Cloud Function requests include App Check token in production-like run"],"pr_bucket_suggestion":"security-hardening","dependencies":[],"evidence":["App Check initialization is commented out while appCheck remains part of firebase surface."]}
{"category":"Framework","title":"Client Sentry module imports Node crypto API","fingerprint":"Framework::lib/sentry.client.ts::hashUserId::node_crypto_in_client","severity":"S1","effort":"E1","confidence":94,"files":["lib/sentry.client.ts","components/providers/auth-context.tsx","components/providers/sentry-initializer.tsx"],"symbols":["hashUserId","setSentryUser","SentryInitializer"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"A browser-executed module importing node:crypto can break client bundling/runtime compatibility.","suggested_fix":"Replace createHash with Web Crypto (crypto.subtle.digest) or another browser-safe hashing utility.","acceptance_tests":["npm run build","npm test","Manual browser verification of Sentry user tagging"],"pr_bucket_suggestion":"boundaries","dependencies":[],"evidence":["lib/sentry.client.ts imports createHash from node:crypto; client providers import and call this module."]}
{"category":"AICode","title":"Anonymous-data migration flow duplicated across email and Google linking","fingerprint":"AICode::lib/auth/account-linking.ts::linkWithEmail::duplicated_migration_flow","severity":"S2","effort":"E2","confidence":91,"files":["lib/auth/account-linking.ts"],"symbols":["linkWithEmail","linkWithGoogle"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Both account-link flows repeat recaptcha + callable + retry + migration logging steps.","instances":[{"file":"lib/auth/account-linking.ts","symbol":"linkWithEmail"},{"file":"lib/auth/account-linking.ts","symbol":"linkWithGoogle"}]},"why_it_matters":"Security-sensitive duplicated logic tends to diverge, increasing migration regressions.","suggested_fix":"Extract a shared migration helper with typed input/output and centralized error mapping.","acceptance_tests":["npm test","Add unit tests for migration helper success/failure","Verify both linking paths route through helper"],"pr_bucket_suggestion":"hooks-standardization","dependencies":[],"evidence":["Near-identical migration blocks in both link flows."]}
{"category":"Hygiene","title":"Repeated stale-request guard pattern in admin async panels","fingerprint":"Hygiene::components/admin/errors-tab.tsx::UserActivityModal::stale_request_guard_duplication","severity":"S2","effort":"E1","confidence":89,"files":["components/admin/errors-tab.tsx","components/admin/jobs-tab.tsx"],"symbols":["UserActivityModal","JobRunHistoryPanel"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Both components implement requestIdRef + mounted checks + guarded finally loading updates.","instances":[{"file":"components/admin/errors-tab.tsx","symbol":"UserActivityModal"},{"file":"components/admin/jobs-tab.tsx","symbol":"JobRunHistoryPanel"}]},"why_it_matters":"Copy/paste async race logic is easy to drift and harder to prove correct in all panels.","suggested_fix":"Introduce a reusable hook for stale-response suppression and mounted-state safe updates.","acceptance_tests":["npm test","Manual rapid filter/switch testing in both panels"],"pr_bucket_suggestion":"hooks-standardization","dependencies":[],"evidence":["Matching async request guard structures across both admin components."]}
{"category":"Framework","title":"Today page bypasses service/repository boundary with direct Firestore querying","fingerprint":"Framework::components/notebook/pages/today-page.tsx::calculateWeeklyStats::service_boundary_bypass","severity":"S2","effort":"E1","confidence":93,"files":["components/notebook/pages/today-page.tsx","lib/firestore-service.ts"],"symbols":["calculateWeeklyStats","FirestoreService"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Mixing direct DB reads in UI with service-layer access elsewhere creates architecture drift and harder security/consistency updates.","suggested_fix":"Move weekly stats query into FirestoreService (or dedicated stats service) and consume typed results in component.","acceptance_tests":["npm test","Add tests for new stats service method","Verify component no longer imports Firestore query helpers"],"pr_bucket_suggestion":"boundaries","dependencies":[],"evidence":["calculateWeeklyStats dynamically imports and executes Firestore collection/query/getDocs logic directly."]}
{"category":"Debugging","title":"High-volume console logging in journal save/stats paths","fingerprint":"Debugging::components/notebook/pages/today-page.tsx::performSave::console_log_spam_sensitive_context","severity":"S2","effort":"E0","confidence":90,"files":["components/notebook/pages/today-page.tsx","lib/firestore-service.ts"],"symbols":["performSave","calculateWeeklyStats","saveDailyLog"],"duplication_cluster":{"is_cluster":true,"cluster_summary":"Multiple development-only console.log/debug blocks in critical journaling flows.","instances":[{"file":"components/notebook/pages/today-page.tsx","symbol":"performSave"},{"file":"components/notebook/pages/today-page.tsx","symbol":"calculateWeeklyStats"},{"file":"lib/firestore-service.ts","symbol":"saveDailyLog"}]},"why_it_matters":"Debug signal gets noisy and sensitive journaling metadata may leak in shared consoles/screenshots.","suggested_fix":"Route debug traces through structured logger with one feature flag and default redaction.","acceptance_tests":["npm run lint","Verify target symbols no longer use direct console.log","Manual save/stats debug validation through logger"],"pr_bucket_suggestion":"misc","dependencies":[],"evidence":["Scoped grep found 19 console.log occurrences; several are in these symbols."]}
{"category":"Debugging","title":"Sentry initializer swallows initialization errors","fingerprint":"Debugging::components/providers/sentry-initializer.tsx::SentryInitializer::swallowed_init_error","severity":"S2","effort":"E0","confidence":95,"files":["components/providers/sentry-initializer.tsx"],"symbols":["SentryInitializer"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"If monitoring boot fails silently, you lose observability and root-cause context.","suggested_fix":"Log sanitized error context or emit fallback breadcrumb before reset/retry behavior.","acceptance_tests":["npm test","Simulate init failure and confirm sanitized diagnostics are emitted"],"pr_bucket_suggestion":"misc","dependencies":[],"evidence":["catch block resets flag but provides no logging or rethrow."]}
{"category":"Types","title":"Firestore documents are cast to domain type without runtime validation","fingerprint":"Types::lib/firestore-service.ts::getTodayLog::unsafe_firestore_cast","severity":"S2","effort":"E1","confidence":88,"files":["lib/firestore-service.ts"],"symbols":["getTodayLog","getHistory"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Unsafe casts can pass malformed DB payloads downstream and fail in less obvious places.","suggested_fix":"Validate doc payloads with schema/type guards before returning typed domain objects.","acceptance_tests":["npm test","Add tests for malformed docs handling"],"pr_bucket_suggestion":"types-domain","dependencies":[],"evidence":["docSnap.data() and history doc.data() are cast to DailyLog without validation."]}
{"category":"Testing","title":"Coverage gaps remain in critical firebase/auth/firestore paths","fingerprint":"Testing::lib/firestore-service.ts::saveDailyLog::critical_path_coverage_gap","severity":"S2","effort":"E2","confidence":86,"files":["lib/firestore-service.ts","lib/firebase.ts","lib/auth/account-linking.ts"],"symbols":["saveDailyLog","initializeFirebase","linkWithEmail"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Low coverage in security-sensitive and data-write paths increases regression risk.","suggested_fix":"Add targeted tests for firebase init guard behavior, callable write flows, and migration edge cases.","acceptance_tests":["npm run test:coverage","Introduce per-file threshold ratcheting"],"pr_bucket_suggestion":"tests-hardening","dependencies":[],"evidence":["Coverage run reports low line coverage for firebase and firestore-service outputs."]}
{"category":"AICode","title":"Functions code imports type from undeclared direct dependency","fingerprint":"AICode::functions/src/jobs.ts::isFileOlderThan::transitive_dependency_reliance","severity":"S2","effort":"E0","confidence":84,"files":["functions/src/jobs.ts","functions/package.json"],"symbols":["isFileOlderThan","cleanupOrphanedStorageFiles"],"duplication_cluster":{"is_cluster":false,"cluster_summary":"","instances":[]},"why_it_matters":"Relying on transitive dependencies makes builds fragile during lockfile or upstream dependency changes.","suggested_fix":"Declare @google-cloud/storage explicitly in functions/package.json or switch to types exposed via existing declared dependencies.","acceptance_tests":["npm --prefix functions run build","npm --prefix functions ls @google-cloud/storage"],"pr_bucket_suggestion":"misc","dependencies":[],"evidence":["jobs.ts imports @google-cloud/storage type symbols; dependency is not directly declared in functions/package.json."]}