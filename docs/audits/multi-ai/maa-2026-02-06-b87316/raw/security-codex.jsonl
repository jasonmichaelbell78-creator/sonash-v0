{"category":"Firebase","title":"App Check enforcement disabled for callable functions","fingerprint":"Firebase::functions/src/index.ts::app-check-disabled","severity":"S1","effort":"E2","confidence":85,"files":["functions/src/index.ts","lib/firebase.ts"],"vulnerability_details":{"description":"Critical callable functions explicitly disable App Check enforcement and the client App Check initialization is commented out, preventing token validation.","exploitation":"An attacker with a valid Firebase Auth token (or a compromised account) can call Cloud Functions from untrusted environments without App Check enforcement.","impact":"Reduced bot protection and increased automated abuse risk against write endpoints.","affected_data":"User journal, daily logs, inventory entries, and migration targets."},"remediation":{"steps":["Re-enable App Check initialization in the client with a valid reCAPTCHA Enterprise provider.","Require App Check in callable functions (remove requireAppCheck:false).","Monitor App Check metrics and adjust throttles instead of disabling enforcement."],"code_example":"// functions/src/index.ts\nwithSecurityChecks(request, { functionName: 'saveDailyLog', rateLimiter: saveDailyLogLimiter, validationSchema: dailyLogSchema, requireAppCheck: true }, handler)\n\n// lib/firebase.ts\ninitializeAppCheck(app, { provider: new ReCaptchaEnterpriseProvider(recaptchaSiteKey), isTokenAutoRefreshEnabled: true });","verification":["Call saveDailyLog without App Check token -> should fail with failed-precondition.","Call saveDailyLog with valid App Check token -> should succeed."]},"owasp_category":"A05","cvss_estimate":"HIGH","evidence":["functions/src/index.ts:84 requireAppCheck: false","lib/firebase.ts:57-90 App Check initialization commented out"],"notes":"Policy requires App Check for all functions.","line":84}
{"category":"RateLimiting","title":"IP-based rate limiting not enforced and Retry-After headers missing","fingerprint":"RateLimiting::functions/src/security-wrapper.ts::ip-rate-limit-missing","severity":"S2","effort":"E2","confidence":78,"files":["functions/src/security-wrapper.ts","functions/src/index.ts"],"vulnerability_details":{"description":"The security wrapper supports IP-based rate limiting but it is optional and not configured on user-facing callable functions. Rate limit errors use HttpsError without Retry-After guidance.","exploitation":"Attackers can rotate accounts from a single IP to bypass user-based limits. Clients do not get Retry-After guidance for backoff.","impact":"Higher risk of automated abuse and noisy clients under load.","affected_data":"All callable function endpoints."},"remediation":{"steps":["Configure ipRateLimiter for all public callable functions (user + IP).","Include retryAfterSeconds in error details and/or migrate to onRequest with explicit 429/Retry-After headers.","Log rate-limit hits with structured metadata for monitoring."]},"owasp_category":"A04","cvss_estimate":"MEDIUM","evidence":["functions/src/security-wrapper.ts:33-38 ipRateLimiter is optional","functions/src/security-wrapper.ts:88-109 HttpsError resource-exhausted without Retry-After","functions/src/index.ts:80-86 withSecurityChecks options omit ipRateLimiter"],"notes":"Standards require IP + user limits and Retry-After.","line":88}
{"category":"InputValidation","title":"Zod schemas are not strict and allow unbounded fields","fingerprint":"InputValidation::functions/src/schemas.ts::non-strict-zod","severity":"S2","effort":"E2","confidence":76,"files":["functions/src/schemas.ts"],"vulnerability_details":{"description":"Schemas use z.object() without .strict(), and several inputs (tags arrays, data blobs) lack length limits. Unknown fields are accepted and large payloads can slip through.","exploitation":"Attackers can submit oversized or unexpected fields to increase processing/storage costs or smuggle data past intended validation.","impact":"Input validation gaps increase risk of injection-style payloads and resource exhaustion.","affected_data":"Callable function inputs for daily logs, journal entries, inventory entries, and admin data."},"remediation":{"steps":["Add .strict() to all top-level Zod schemas.","Add max length constraints for tags, searchableText, and free-form data fields.","Introduce per-type schemas for journal/inventory data payloads."]},"owasp_category":"A03","cvss_estimate":"MEDIUM","evidence":["functions/src/schemas.ts:5-55 z.object definitions without .strict() and unbounded tags/data"],"notes":"Requirement mandates strict schemas and length limits for all inputs.","line":5}
{"category":"Firebase","title":"Admin CRUD uses client Firestore writes, bypassing server validation and rate limiting","fingerprint":"Firebase::lib/db/quotes.ts::client-admin-writes","severity":"S2","effort":"E2","confidence":82,"files":["lib/db/quotes.ts","components/admin/quotes-tab.tsx","lib/db/slogans.ts","components/admin/slogans-tab.tsx","firestore.rules"],"vulnerability_details":{"description":"Admin tabs call client Firestore CRUD services directly for admin-managed collections, bypassing Cloud Functions' server-side validation, rate limiting, and audit logging.","exploitation":"Compromised admin sessions can write malformed or excessive data without server-side controls, increasing abuse and data integrity risks.","impact":"Administrative content collections can be tampered with outside server-side security controls.","affected_data":"daily_quotes, slogans, and other admin-managed collections."},"remediation":{"steps":["Route all admin CRUD through callable Cloud Functions with Zod validation and rate limiting.","Update Firestore rules to deny direct client writes to admin-managed collections (admin SDK only).","Add audit logging for admin writes in functions."]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":["components/admin/quotes-tab.tsx:102-121 admin uses QuotesService adapter","lib/db/quotes.ts:38-52 addDoc/updateDoc/deleteDoc client writes","components/admin/slogans-tab.tsx:105-120 admin uses SlogansService adapter","lib/db/slogans.ts:47-70 setDoc/updateDoc/deleteDoc client writes","firestore.rules:101-129 admin writes allowed for daily_quotes/slogans/quick_links/prayers"],"notes":"Policy expects server-side controls on admin operations.","line":102}
{"category":"SecretsManagement","title":"Production environment values committed with NEXT_PUBLIC* keys","fingerprint":"SecretsManagement::.env.production::public-env-committed","severity":"S2","effort":"E1","confidence":90,"files":[".env.production"],"vulnerability_details":{"description":"A committed .env.production file contains NEXT_PUBLIC_* values (API keys, App Check site key, Sentry DSN), violating the no-secrets-in-repo and no-client-secrets standard.","exploitation":"Attackers can scrape public repo history for identifiers and use them for abuse or reconnaissance.","impact":"Exposes production identifiers and violates mandatory secrets-management standard.","affected_data":"Firebase project identifiers and Sentry DSN."},"remediation":{"steps":["Remove .env.production from version control and rotate exposed keys where applicable.","Store secrets in environment/secret manager and provide a sanitized .env.example.","Ensure NEXT_PUBLIC values are limited to non-sensitive identifiers only."],"verification":["Verify .env.production is gitignored and removed from repo history.","Confirm deployment injects secrets via environment config, not committed files."]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":[".env.production:5-21 NEXT_PUBLIC_* values present in repo"],"notes":"Firebase API keys are public by design, but policy explicitly forbids secrets in NEXT_PUBLIC_* and committed env files.","line":5}
{"category":"Headers","title":"Missing CSP and COEP headers in hosting configuration","fingerprint":"Headers::firebase.json::missing-csp-coep","severity":"S2","effort":"E1","confidence":84,"files":["firebase.json"],"vulnerability_details":{"description":"Firebase Hosting headers omit Content-Security-Policy (CSP) and Cross-Origin-Embedder-Policy (COEP).","exploitation":"Absent CSP increases XSS impact. Missing COEP weakens cross-origin isolation for security-sensitive features.","impact":"Higher exposure to script injection and weaker browser isolation.","affected_data":"All hosted pages."},"remediation":{"steps":["Add a restrictive CSP tuned for Next.js static exports.","Add COEP/COOP pair where required and test with App Check and Google OAuth flows.","Validate headers with security scanners or curl."]},"owasp_category":"A05","cvss_estimate":"MEDIUM","evidence":["firebase.json:6-56 headers list does not include CSP or COEP"],"notes":"COOP is present but COEP is missing.","line":6}
{"category":"Framework","title":"Client components access process.env directly","fingerprint":"Framework::components/providers/error-boundary.tsx::client-process-env","severity":"S3","effort":"E1","confidence":70,"files":["components/providers/error-boundary.tsx"],"vulnerability_details":{"description":"Client components reference process.env (NODE_ENV) directly, violating the stated framework boundary rule for client components.","exploitation":"May leak environment details or encourage additional unsafe env access in client code.","impact":"Low direct security impact but violates framework-specific security standard.","affected_data":"Client-side bundles."},"remediation":{"steps":["Replace direct process.env usage in client components with a compile-time flag or a shared config module that exposes only safe values.","Audit other client components for process.env usage and remove where possible."]},"owasp_category":"A05","cvss_estimate":"LOW","evidence":["components/providers/error-boundary.tsx:1-3 use client component","components/providers/error-boundary.tsx:210-220 process.env.NODE_ENV usage"],"notes":"Standard explicitly disallows process.env in client components.","line":210}
