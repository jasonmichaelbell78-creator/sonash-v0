{"category":"Bundle Size","title":"Excessive client-component surface (\"use client\" appears 107 times) increases hydration + JS cost","fingerprint":"Bundle Size::app/components::use_client_overuse","severity":"S1","effort":"E3","confidence":90,"files":["app/admin/page.tsx","app/meetings/all/page.tsx","components/admin/admin-crud-table.tsx"],"symbols":["AdminPage","MeetingsAllPage","AdminCrudTable"],"performance_details":{"current_metric":"107 occurrences of \"use client\" across app/components/hooks/lib/types (high hydration surface)","expected_improvement":"20–40% reduction in initial JS/hydration work on non-interactive routes after moving logic to server components and narrowing client islands","affected_metric":"bundle"},"optimization":{"description":"Reduce client boundary: keep pages/layouts server by default; move only interactive subtrees to client components; prefer server-side data shaping for static/exported pages where possible.","code_example":"// app/some-route/page.tsx (Server)\nimport ClientWidget from './client-widget';\nexport default function Page(){\n  return (<>\n    <StaticSection />\n    <ClientWidget />\n  </>);\n}\n","verification":["Re-run grep count for \"use client\" and track down; ensure key routes remain interactive.","After changes, run bundle analyzer + Lighthouse to confirm reduced JS and improved INP."]},"evidence":["grep count: 107 lines match \"\\\"use client\\\"\" under app/components/hooks/lib/types","app/admin/page.tsx:1 \"use client\"","app/meetings/all/page.tsx:1 \"use client\""],"notes":"Scope note: routes like /dashboard, /daily-log, /analytics were not present in this repo snapshot; audit focuses on existing routes.","line":1}
{"category":"Bundle Size","title":"Framer Motion imported broadly (37 files) — consider LazyMotion and route-level code splitting","fingerprint":"Bundle Size::components::framer_motion_wide_import","severity":"S2","effort":"E2","confidence":85,"files":["components/notebook/notebook-shell.tsx","components/journal/entry-menu.tsx","components/celebrations/milestone-modal.tsx"],"symbols":["NotebookShell","EntryMenu","MilestoneModal"],"performance_details":{"current_metric":"37 framer-motion import hits in components/app/hooks/lib","expected_improvement":"5–15% reduction in client bundle (route-dependent) and faster hydration, especially on routes that don't need animations","affected_metric":"bundle"},"optimization":{"description":"Use Framer Motion's LazyMotion + domAnimation (or domMax if needed) and load heavier animated UI (modals/celebrations) via dynamic import when off-screen or route-scoped.","code_example":"import { LazyMotion, domAnimation, m } from 'framer-motion';\n\nexport function AnimatedCard(){\n  return (\n    <LazyMotion features={domAnimation}>\n      <m.div initial={{opacity:0}} animate={{opacity:1}} />\n    </LazyMotion>\n  );\n}\n","verification":["Confirm framer-motion code not included on routes without animations (bundle analyzer).","Check animation behavior parity (no regressions)."]},"evidence":["grep shows framer-motion imports (count=37) e.g., components/auth/sign-in-modal.tsx:11, components/home/home-client.tsx:6"],"notes":"Dynamic import already used for Leaflet map (good pattern to replicate for modal-heavy UI).","line":1}
{"category":"Data Fetching","title":"Unbounded Firestore reads in AdminCrudTable (getDocs(collection)) can load entire collections","fingerprint":"Data Fetching::components/admin/admin-crud-table.tsx::unbounded_getdocs","severity":"S1","effort":"E2","confidence":95,"files":["components/admin/admin-crud-table.tsx"],"symbols":["AdminCrudTable","fetchItems"],"performance_details":{"current_metric":"getDocs(ref) on a collection ref without query/limit; client then filters in-memory","expected_improvement":"20–50% faster admin load time + lower Firestore cost once server-side filtering/pagination and limit() are added","affected_metric":"render"},"optimization":{"description":"Paginate and limit Firestore reads (limit + startAfter). Push filtering to query constraints where possible (e.g., where/orderBy). Add debounced search and server-side search strategy for large collections.","code_example":"// Prefer queries with limit + cursor\nconst q = query(collection(db, name), orderBy('createdAt','desc'), limit(50));\nconst snap = await getDocs(q);\n","verification":["Verify network payload size drops when loading admin tabs.","Confirm scrolling/pagination fetches additional pages rather than loading all documents."]},"evidence":["components/admin/admin-crud-table.tsx:60-62 const ref = collection(...); const snapshot = await getDocs(ref);","components/admin/admin-crud-table.tsx:92 filteredItems = items.filter(...) (client-side filtering after fetch)"],"notes":"Even if only admins use this, it still impacts perceived responsiveness and Firestore billing.","line":61}
{"category":"Rendering","title":"AdminCrudTable filters items on every render without memoization or debounced input","fingerprint":"Rendering::components/admin/admin-crud-table.tsx::unmemoized_filter","severity":"S2","effort":"E1","confidence":90,"files":["components/admin/admin-crud-table.tsx"],"symbols":["AdminCrudTable","filteredItems"],"performance_details":{"current_metric":"filteredItems computed via items.filter(...) each render; searchTerm changes trigger full scan","expected_improvement":"5–20% better typing responsiveness and lower CPU on large admin datasets (depends on item count)","affected_metric":"INP"},"optimization":{"description":"Wrap filtering in useMemo keyed on [items, searchTerm, filters]; debounce searchTerm updates; precompute lowercased searchable fields if needed.","code_example":"const filteredItems = useMemo(() => {\n  const q = searchTerm.toLowerCase();\n  return items.filter(i => /* ... */);\n}, [items, searchTerm, filters, config.searchFields]);\n","verification":["Profile render commits while typing in search box; verify reduced re-render time.","Confirm UI results remain correct with memoized filtering."]},"evidence":["components/admin/admin-crud-table.tsx:91-116 filteredItems = items.filter(...) computed inline"],"notes":"This compounds with the unbounded getDocs issue; fixing both yields the best gain.","line":92}
{"category":"Data Fetching","title":"DailySloganWidget fetches entire slogans collection on mount (no limit/caching)","fingerprint":"Data Fetching::components/growth/DailySloganWidget.tsx::fetch_all_then_pick","severity":"S2","effort":"E1","confidence":95,"files":["components/growth/DailySloganWidget.tsx"],"symbols":["DailySloganWidget","fetchDailySlogan"],"performance_details":{"current_metric":"getDocs(collection('slogans')) then selects one slogan client-side","expected_improvement":"5–15% faster widget load + reduced reads; bigger gains as slogans collection grows","affected_metric":"render"},"optimization":{"description":"Fetch only what you need: store \"current slogan\" doc, or query scheduled slogans with constraints; cache result for session/day; optionally move selection to Cloud Function or a single doc updated periodically.","code_example":"// Option: single doc\nconst docRef = doc(db,'slogans','current');\nconst snap = await getDoc(docRef);\n","verification":["Confirm number of docs read is 1 (or small bounded set).","Widget still rotates correctly 3x/day."]},"evidence":["components/growth/DailySloganWidget.tsx:25-27 collection(db,'slogans'); await getDocs(slogansRef);"],"notes":"This matches a common AI anti-pattern: fetch-all then compute locally.","line":26}
{"category":"Rendering","title":"Today page re-subscribes Firestore onSnapshot when journalEntry changes (likely per-keystroke)","fingerprint":"Rendering::components/notebook/pages/today-page.tsx::effect_dep_resubscribe","severity":"S1","effort":"E2","confidence":90,"files":["components/notebook/pages/today-page.tsx"],"symbols":["TodayPage","useEffect","onSnapshot"],"performance_details":{"current_metric":"useEffect dependency array includes journalEntry; effect sets up Firestore listener and dynamic imports","expected_improvement":"20–50% improvement in typing responsiveness and reduced listener churn if dependency is stabilized (depends on how often journalEntry updates)","affected_metric":"INP"},"optimization":{"description":"Remove journalEntry from the subscription effect deps if not required for subscription correctness; split effect into (1) one-time restore, (2) listener subscription keyed only on user/referenceDate/handlers. Use refs to avoid stale closures instead of re-subscribing.","code_example":"useEffect(() => {\n  if (!user) return;\n  let unsub: (()=>void)|undefined;\n  let mounted = true;\n  (async()=>{\n    const { onSnapshot, doc } = await import('firebase/firestore');\n    const { db } = await import('@/lib/firebase');\n    const docRef = doc(db, buildPath.dailyLog(user.uid, getTodayDateId(referenceDate)));\n    if (mounted) unsub = onSnapshot(docRef, snap => handleSnapshotUpdate(snap, true));\n  })();\n  return () => { mounted = false; unsub?.(); };\n}, [user, referenceDate, handleSnapshotUpdate]);\n","verification":["Add temporary logging counter for listener setups; typing should not increase setup count.","React Profiler: reduced commits while editing journalEntry."]},"evidence":["components/notebook/pages/today-page.tsx:525-579 sets up onSnapshot + dynamic imports inside useEffect","components/notebook/pages/today-page.tsx:579 dependency array includes journalEntry"],"notes":"This is a high-leverage fix if journalEntry is tied to text input updates.","line":579}
{"category":"Offline Support","title":"UI claims offline writes will sync, but no persistence/queue implementation is evident","fingerprint":"Offline Support::components/status/offline-indicator.tsx::sync_claim_without_queue","severity":"S2","effort":"E2","confidence":85,"files":["components/status/offline-indicator.tsx"],"symbols":["OfflineIndicator"],"performance_details":{"current_metric":"Offline banner states changes will sync; codebase shows offline detection but no IndexedDB persistence enablement or write-queue state","expected_improvement":"Fewer failed writes/retries + better UX under flaky networks; avoids repeated network retries that degrade INP","affected_metric":"INP"},"optimization":{"description":"Either (A) implement offline persistence/queue: enable Firestore IndexedDB persistence (where supported), track pending writes + UI state, and reconcile on reconnect; or (B) change banner text to reflect actual behavior and surface failure states for writes.","code_example":"// If choosing Firestore persistence (browser only)\n// enableIndexedDbPersistence(db).catch(() => {/* fallback */});\n","verification":["Follow offline test recipe: create entry offline, see pending state; reconnect and verify single sync without duplicates.","Confirm no infinite retry loops when offline."]},"evidence":["components/status/offline-indicator.tsx:46 text: \"Offline - changes will sync when reconnected\"","grep for enableIndexedDbPersistence/persistentLocalCache returned no matches in app/components/hooks/lib"],"notes":"This is both a UX correctness issue and a potential performance issue if retries are naive elsewhere.","line":46}
{"category":"Core Web Vitals","title":"Landing page LCP risk: large background image via CSS url() without preload/priority","fingerprint":"Core Web Vitals::app/page.tsx::background_lcp_risk","severity":"S2","effort":"E1","confidence":80,"files":["app/page.tsx"],"symbols":["Home"],"performance_details":{"current_metric":"Hero background uses CSS background-image url('/images/wood-table.jpg')","expected_improvement":"5–15% LCP improvement (depends on image size and caching) by preloading and optimizing asset","affected_metric":"LCP"},"optimization":{"description":"Optimize wood-table.jpg (modern format, size), add preload via <link rel=\"preload\" as=\"image\"> in layout/head, ensure long-cache headers on Hosting, and consider using a smaller placeholder/gradient until image loads.","code_example":"// app/layout.tsx (or metadata)\nexport const metadata = { /* ... */ };\n// In <head> add:\n// <link rel=\"preload\" as=\"image\" href=\"/images/wood-table.jpg\" />\n","verification":["Lighthouse: confirm LCP resource is cached/preloaded; observe improved LCP.","Network waterfall: image starts earlier (preload hit)."]},"evidence":["app/page.tsx:25-27 backgroundImage: `url('/images/wood-table.jpg')`"],"notes":"Using next/image isn't applicable for CSS backgrounds, so preload + asset optimization is the main lever.","line":26}