{"category": "Core Web Vitals", "title": "Image optimization disabled in Next.js config", "fingerprint": "CoreWebVitals::next.config.mjs::image_unoptimized", "severity": "P2", "effort": "E1", "confidence": 100, "files": ["next.config.mjs"], "symbols": [], "line": 12, "performance_details": {"current_metric": "Images served unoptimized", "expected_improvement": "30-50% reduction in image payload", "affected_metric": "LCP"}, "optimization": {"description": "Enable Next.js image optimization by setting unoptimized: false", "code_example": "images: { unoptimized: false, formats: ['image/webp', 'image/avif'] }", "verification": ["Run Lighthouse audit", "Check image sizes in Network tab"]}, "evidence": ["images: { unoptimized: true }"], "notes": "Affects LCP significantly on image-heavy pages"}
{"category": "Bundle Size", "title": "No dynamic imports for heavy components", "fingerprint": "BundleSize::components/analytics/*::no_dynamic_imports", "severity": "P2", "effort": "E1", "confidence": 90, "files": ["components/analytics/*", "components/maps/*"], "symbols": ["Recharts", "LeafletMap"], "line": 1, "performance_details": {"current_metric": "All JS loaded on initial page load", "expected_improvement": "100-150kb reduction in initial bundle", "affected_metric": "TTI"}, "optimization": {"description": "Use dynamic imports for Recharts and Leaflet components", "code_example": "const Chart = dynamic(() => import('./Chart'), { ssr: false })", "verification": ["Analyze bundle with @next/bundle-analyzer", "Verify chunks loaded on demand"]}, "evidence": ["recharts: 2.15.4 (~70kb)", "leaflet: ^1.9.4 (~40kb)", "framer-motion: 12.23.0 (~40kb)"], "notes": "Heavy libraries loaded even when not immediately needed"}
{"category": "Bundle Size", "title": "No code splitting strategy implemented", "fingerprint": "BundleSize::app/::no_code_splitting", "severity": "P3", "effort": "E2", "confidence": 80, "files": ["app/"], "symbols": [], "line": 1, "performance_details": {"current_metric": "Single monolithic bundle", "expected_improvement": "20-30% faster initial load", "affected_metric": "FCP, TTI"}, "optimization": {"description": "Implement route-based code splitting with dynamic imports", "code_example": "Use dynamic imports for each page section", "verification": ["Analyze bundle chunks", "Verify lazy loading works"]}, "evidence": ["No dynamic imports observed in codebase"], "notes": "Next.js supports automatic code splitting with dynamic imports"}
{"category": "Rendering", "title": "No list virtualization for journal entries", "fingerprint": "Rendering::components/journal/entry-feed.tsx::no_virtualization", "severity": "P3", "effort": "E2", "confidence": 90, "files": ["components/journal/entry-feed.tsx"], "symbols": ["EntryFeed"], "line": 1, "performance_details": {"current_metric": "All 100 entries rendered in DOM", "expected_improvement": "60-80% fewer DOM nodes", "affected_metric": "INP"}, "optimization": {"description": "Use react-window or react-virtualized for long lists", "code_example": "import { FixedSizeList } from 'react-window'", "verification": ["Check DOM node count", "Measure INP with Chrome DevTools"]}, "evidence": ["QUERY_LIMITS.JOURNAL_MAX = 100 entries"], "notes": "Virtualization only renders visible items"}
{"category": "Data Fetching", "title": "No pagination - only limit() used", "fingerprint": "DataFetching::hooks/use-journal.ts::no_pagination", "severity": "P3", "effort": "E2", "confidence": 100, "files": ["hooks/use-journal.ts"], "symbols": ["useJournal"], "line": 180, "performance_details": {"current_metric": "100 entries loaded at once", "expected_improvement": "Faster initial load with progressive loading", "affected_metric": "LCP, data transfer"}, "optimization": {"description": "Implement cursor-based pagination with Load More button", "code_example": "Use startAfter() for cursor pagination", "verification": ["Measure initial load time", "Check data transfer"]}, "evidence": ["limit(QUERY_LIMITS.JOURNAL_MAX) - no pagination"], "notes": "Consider infinite scroll or Load More pattern"}
{"category": "Data Fetching", "title": "No stale-while-revalidate caching", "fingerprint": "DataFetching::hooks/use-journal.ts::no_swr_caching", "severity": "P3", "effort": "E2", "confidence": 90, "files": ["hooks/use-journal.ts"], "symbols": ["useJournal"], "line": 1, "performance_details": {"current_metric": "Fresh fetch on every mount", "expected_improvement": "Instant data from cache + background refresh", "affected_metric": "Perceived performance"}, "optimization": {"description": "Consider SWR or React Query for intelligent caching", "code_example": "import useSWR from 'swr'", "verification": ["Measure time-to-first-content", "Check cache hits"]}, "evidence": ["Direct onSnapshot usage without caching layer"], "notes": "SWR provides stale-while-revalidate out of the box"}
{"category": "Memory", "title": "All journal entries held in memory", "fingerprint": "Memory::hooks/use-journal.ts::entries_in_state", "severity": "P3", "effort": "E1", "confidence": 100, "files": ["hooks/use-journal.ts"], "symbols": ["entries"], "line": 65, "performance_details": {"current_metric": "100 entries in React state", "expected_improvement": "Reduced memory footprint", "affected_metric": "Memory usage"}, "optimization": {"description": "Consider virtualization or pagination to limit in-memory data", "code_example": "Use react-window for virtualization", "verification": ["Measure memory usage in DevTools", "Check for memory leaks"]}, "evidence": ["const [entries, setEntries] = useState<JournalEntry[]>([])"], "notes": "100 entries may be acceptable, but monitor for growth"}
{"category": "Core Web Vitals", "title": "No Suspense boundaries for loading states", "fingerprint": "CoreWebVitals::app/::no_suspense", "severity": "P3", "effort": "E1", "confidence": 80, "files": ["app/"], "symbols": [], "line": 1, "performance_details": {"current_metric": "No streaming SSR", "expected_improvement": "Better perceived loading", "affected_metric": "LCP, CLS"}, "optimization": {"description": "Add Suspense boundaries around data-dependent components", "code_example": "<Suspense fallback={<Skeleton />}><DataComponent /></Suspense>", "verification": ["Check loading UX", "Measure LCP improvement"]}, "evidence": ["No Suspense usage observed in app directory"], "notes": "Next.js App Router supports React Suspense"}
{"category": "AI Performance Patterns", "title": "Full documents fetched without field selection", "fingerprint": "AIPerformance::hooks/use-journal.ts::no_field_selection", "severity": "P3", "effort": "E1", "confidence": 90, "files": ["hooks/use-journal.ts"], "symbols": ["onSnapshot"], "line": 175, "performance_details": {"current_metric": "All document fields fetched", "expected_improvement": "20-40% less data transfer", "affected_metric": "Data usage, load time"}, "optimization": {"description": "Select only needed fields in Firestore queries", "code_example": "Use query constraints to limit fields if possible", "verification": ["Measure data transfer", "Check Firestore usage"]}, "evidence": ["onSnapshot fetches entire document"], "notes": "Firestore doesn't support field selection in queries directly"}
