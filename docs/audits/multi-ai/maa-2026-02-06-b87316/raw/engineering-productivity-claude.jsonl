{"category":"Debugging","title":"46 console.log statements remain in production code","fingerprint":"engineering-productivity::lib/firestore-service.ts::console-logging","severity":"S2","effort":"E1","confidence":100,"files":["lib/firestore-service.ts","components/notebook/pages/today-page.tsx","lib/hooks/use-tab-refresh.ts","lib/utils/secure-caller.ts"],"line":62,"why_it_matters":"Console.log statements clutter production logs, lack structured context for debugging, and can leak sensitive data. The project has a structured logger but 77.5% adoption means 46 instances remain.","suggested_fix":"Run a codebase-wide migration replacing console.* with logger.* calls. Update eslint config to error on console.* usage except in scripts/.","acceptance_tests":["grep -r 'console.' lib/ components/ app/ --include='*.ts' --include='*.tsx' returns 0 results","npm run lint passes with no console.* warnings","All logger.* calls include structured context objects"],"evidence":["lib/firestore-service.ts:62: console.error()","lib/firestore-service.ts:229: console.log() with sanitized payload","components/notebook/pages/today-page.tsx:613-807: 12 console.log statements"]}
{"category":"Debugging","title":"No correlation ID system for distributed tracing","fingerprint":"engineering-productivity::lib/logger.ts::correlation-ids","severity":"S1","effort":"E2","confidence":100,"files":["lib/logger.ts","lib/firestore-service.ts"],"line":99,"why_it_matters":"Without correlation IDs, tracking a single user request across Cloud Functions, Firestore queries, and client-side operations is nearly impossible. Significantly increases MTTR for production incidents.","suggested_fix":"Add correlationId field to LogContext type. Create lib/correlation.ts with generateCorrelationId(). Pass correlationId to all httpsCallable functions. Update Firebase Functions to log correlationId.","acceptance_tests":["Logger interface includes correlationId in LogContext type","All Cloud Function calls include correlationId in payload","Sentry events include correlation_id tag","Can trace a single user action end-to-end using correlation ID"],"evidence":["grep -r correlationId lib/ returned 0 results","No X-Request-ID or similar tracing headers in secure-caller.ts"]}
{"category":"Offline","title":"Firebase IndexedDB persistence not enabled","fingerprint":"engineering-productivity::lib/firebase.ts::persistence","severity":"S1","effort":"E1","confidence":100,"files":["lib/firebase.ts"],"line":1,"why_it_matters":"Without Firebase persistence, users lose all unsynced data when they close the app offline. The OfflineIndicator UI suggests offline support but no actual persistence layer exists. Critical for a recovery journal.","suggested_fix":"Import enableIndexedDbPersistence from firebase/firestore. Call after initializeFirestore(), wrapped in try/catch. Add NEXT_PUBLIC_ENABLE_PERSISTENCE env var for gradual rollout.","acceptance_tests":["grep enableIndexedDbPersistence lib/firebase.ts shows implementation","DevTools IndexedDB shows firestore cache","User can write offline, close browser, reopen - entry preserved"],"evidence":["grep -r enableIndexedDbPersistence lib/ returned no results","components/status/offline-indicator.tsx exists but no backing persistence layer"]}
{"category":"Offline","title":"No service worker for offline shell","fingerprint":"engineering-productivity::public/sw.js::service-worker","severity":"S2","effort":"E2","confidence":100,"files":["public/sw.js"],"line":1,"why_it_matters":"Without a service worker, the app shell doesn't load offline. Users see a browser error page instead of the notebook interface. For a recovery tool where accessibility during crisis moments matters, this is a significant gap.","suggested_fix":"Create public/sw.js with Workbox for shell caching. Register in app/layout.tsx. Cache critical routes and static assets. Add offline.html fallback page.","acceptance_tests":["ls public/sw.js exists","navigator.serviceWorker.register called in app/layout.tsx","App loads offline with cached shell","Lighthouse PWA score includes registers a service worker"],"evidence":["ls public/sw.js returned MISSING","No service worker registration in app/layout.tsx","components/pwa/install-prompt.tsx suggests PWA intentions but no SW backing"]}
{"category":"Offline","title":"No write queue for offline mutations","fingerprint":"engineering-productivity::lib/firestore-service.ts::offline-queue","severity":"S1","effort":"E3","confidence":90,"files":["lib/firestore-service.ts"],"line":223,"why_it_matters":"Firebase persistence only handles reads offline. Writes fail immediately when offline unless you implement a write queue. Users see changes will sync but writes are silently dropped. Could cause data loss in recovery journaling scenarios.","suggested_fix":"Create lib/offline-queue.ts with PendingWrite type and writeQueue using IndexedDB. Wrap all httpsCallable functions with queue-on-offline logic. On reconnection drain queue with exponential backoff.","acceptance_tests":["User can call saveDailyLog while offline","Write stored in IndexedDB offline-queue","On reconnection write is retried automatically","OfflineIndicator shows Syncing X changes during drain"],"evidence":["No queue references in lib/ related to offline writes","lib/firestore-service.ts:223 calls httpsCallable directly with no offline fallback"]}
{"category":"Offline","title":"No conflict resolution strategy","fingerprint":"engineering-productivity::lib/firestore-service.ts::conflicts","severity":"S2","effort":"E2","confidence":85,"files":["lib/firestore-service.ts"],"line":1,"why_it_matters":"If a user edits a journal entry on mobile offline then on desktop, the last write wins with no merge strategy. For recovery journals with timestamps, moods, and notes, losing data due to silent conflicts is unacceptable.","suggested_fix":"Add version field to all documents. In Cloud Functions check version on merge and return ConflictError if stale. Implement last-write-wins for mood but append-only for notes.","acceptance_tests":["Edit journal entry offline on device A","Edit same entry offline on device B","Both reconnect - user sees merge conflict UI","Merged result preserves all notes and latest mood"],"evidence":["No conflict resolution logic in lib/firestore-service.ts","No version fields in Firestore writes"]}
{"category":"CI_CD","title":"No incremental builds configured for CI","fingerprint":"engineering-productivity::.github/workflows/ci.yml::incremental-builds","severity":"S2","effort":"E1","confidence":95,"files":[".github/workflows/ci.yml"],"line":151,"why_it_matters":"Every CI build recompiles the entire Next.js app from scratch. Next.js Remote Caching or Turborepo could cut build times by 50-70%. With 10 CI workflows this compounds into 15-20 minutes of redundant compilation per PR.","suggested_fix":"Add actions/cache step for .next/cache in ci.yml. Consider Vercel Remote Caching or self-hosted Turborepo cache. Measure build time before/after.","acceptance_tests":["CI build job shows Cache restored from key in logs","Second build on same branch completes 50%+ faster","Cache hit rate tracked in CI logs"],"evidence":[".github/workflows/ci.yml:151 runs npm run build with no caching","No .next/cache in actions/cache configuration"]}
{"category":"CI_CD","title":"No auto-retry on flaky test failures","fingerprint":"engineering-productivity::.github/workflows/ci.yml::retry-logic","severity":"S3","effort":"E0","confidence":100,"files":[".github/workflows/ci.yml"],"line":114,"why_it_matters":"Flaky tests cause false-negative CI failures, forcing manual rerun failed jobs clicks. This wastes time and trains developers to ignore CI failures.","suggested_fix":"Add nick-fields/retry-action@v2 to CI test step with timeout_minutes: 10 and max_attempts: 2.","acceptance_tests":["CI retries failed test once automatically","Retry count visible in GitHub Actions UI"],"evidence":["No retry logic in .github/workflows/ci.yml:114 test step"]}
{"category":"Testing","title":"E2E tests missing despite Playwright installation","fingerprint":"engineering-productivity::tests/e2e::missing-tests","severity":"S1","effort":"E2","confidence":100,"files":["tests/e2e"],"line":1,"why_it_matters":"Playwright is installed but zero E2E tests exist. Unit tests alone miss critical integration bugs like OAuth redirect failures or App Check misconfigurations. 477 unit test cases but can't catch integration issues.","suggested_fix":"Create tests/e2e/ directory with playwright.config.ts. Write critical path tests for auth flow, journal entry CRUD, and offline sync. Add npm run test:e2e script. Run in CI with Firebase emulators.","acceptance_tests":["tests/e2e/ contains 3+ .spec.ts files","npm run test:e2e passes locally","CI runs E2E tests in separate job after build"],"evidence":["find . -name '*.spec.ts' returned 0 test files","package.json:115 includes @playwright/test:^1.58.1","No playwright.config.ts in root or tests/"]}
{"category":"Testing","title":"Test coverage reporting broken - TypeScript compilation errors","fingerprint":"engineering-productivity::package.json::test-coverage","severity":"S1","effort":"E1","confidence":100,"files":["package.json","tsconfig.test.json"],"line":12,"why_it_matters":"npm run test:coverage fails with Cannot find type definition file for node. The coverage gate is completely broken. CI uploads empty coverage artifacts. Without working coverage reports, refactoring is risky.","suggested_fix":"Fix tsconfig.test.json: add node to types array. Verify test:build completes without errors. Run test:coverage and confirm c8 HTML report generates. Update CI to fail if coverage drops below threshold.","acceptance_tests":["npm run test:coverage completes without TypeScript errors","coverage/index.html generated with coverage metrics","CI shows coverage percentage in logs"],"evidence":["npm run test:coverage output: error TS2688: Cannot find type definition file for node","tsconfig.test.json likely missing @types/node reference"]}
{"category":"Testing","title":"Test build overhead slows feedback loop","fingerprint":"engineering-productivity::package.json::test-build","severity":"S2","effort":"E2","confidence":90,"files":["package.json"],"line":11,"why_it_matters":"Every test run requires tsc + tsc-alias compilation step adding ~10-30s overhead. For TDD workflows this breaks the fast feedback loop. Node native test runner supports TS directly via tsx making compile step potentially unnecessary.","suggested_fix":"Replace node --test with tsx --test to run tests directly from TypeScript. Remove test:build script or make it optional. Install tsx (already present at line 145).","acceptance_tests":["npm test completes in <30s for all unit tests","No tsc compilation step before test execution","All 477 test cases pass with tsx"],"evidence":["package.json:11 requires npm run test:build before every test run","test:build runs tsc + tsc-alias which compiles entire test suite"]}
