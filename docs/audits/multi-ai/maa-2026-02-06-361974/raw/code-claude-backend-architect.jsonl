{"title":"God component: dashboard-tab.tsx with excessive state management","severity":"S2","category":"code-quality","files":["components\\admin\\dashboard-tab.tsx"],"line":952,"why_it_matters":"DashboardTab component manages 12+ pieces of state (health, stats, loading, error, storageStats, loadingStorage, storageError, rateLimits, loadingRateLimits, rateLimitsError, collectionStats, loadingCollections, collectionsError, clearingRateLimit). While the component has been refactored to extract subcomponents for rendering, the state management remains centralized in a single component. This creates tight coupling between different concerns (health checks, storage stats, rate limits, collection stats) and makes testing difficult.","suggested_fix":"Apply the reducer pattern or split into multiple context providers (HealthContext, StorageContext, RateLimitsContext, CollectionStatsContext). Each context should manage its own state and API calls. This follows the same pattern already used successfully in auth-provider.tsx where auth, profile, and daily log state are separated into focused contexts.","confidence":95,"effort":"E1","fingerprint":"code-quality::components\\admin\\dashboard-tab.tsx::757dd7f3","acceptance_tests":["Verify fix applied correctly"]}
{"title":"Inconsistent state management patterns across providers","severity":"S2","category":"code-quality","files":["components\\providers\\auth-provider.tsx"],"line":38,"why_it_matters":"The codebase uses two different state management patterns: (1) Unified provider pattern in auth-provider.tsx that composes multiple contexts with explicit child providers, and (2) Manual composition in profile-context.tsx and daily-log-context.tsx that accept user as a prop. While both work, this inconsistency makes the codebase harder to reason about. The manual composition pattern requires parent components to track and pass user state, creating implicit coupling.","suggested_fix":"Standardize on the composition pattern already used in AuthProvider. Update ProfileProvider and DailyLogProvider to consume user from AuthContext directly using useAuthCore() instead of accepting it as a prop. This eliminates prop drilling and makes the dependency chain explicit through context consumption rather than component nesting.","confidence":90,"effort":"E1","fingerprint":"code-quality::components\\providers\\auth-provider.tsx::0095ed65","acceptance_tests":["Verify fix applied correctly"]}
{"title":"Missing error boundary coverage for async operations","severity":"S1","category":"code-quality","files":["components\\providers\\error-boundary.tsx"],"line":37,"why_it_matters":"The ErrorBoundary component only catches synchronous render errors and componentDidCatch errors. It does not catch errors from async operations in useEffect hooks, Cloud Function calls, or Firestore queries. For example, in use-journal.ts, Cloud Function failures are caught locally but never bubble to a global error handler. This creates inconsistent error handling where some errors show toasts, some return error objects, and some are silently logged.","suggested_fix":"Implement an async error boundary pattern using React error boundaries for render errors plus a global error context for async errors. Create an ErrorProvider that wraps the app and provides a reportError(error, context) function. Update all async operations (Cloud Functions, Firestore queries) to call reportError on catch. This centralizes error handling and enables consistent user feedback, retry logic, and error reporting to Sentry.","confidence":85,"effort":"E1","fingerprint":"code-quality::components\\providers\\error-boundary.tsx::2fbdc4fa","acceptance_tests":["Verify fix applied correctly"]}
{"title":"Tight coupling between UI components and Firebase SDK","severity":"S2","category":"code-quality","files":["hooks\\use-journal.ts"],"line":350,"why_it_matters":"The useJournal hook directly imports and calls getFunctions() and httpsCallable() from firebase/functions. While the firestore-service.ts follows the repository pattern with dependency injection for testing, hooks like use-journal.ts tightly couple to Firebase SDK. This makes it impossible to test useJournal without mocking Firebase modules and prevents swapping implementations (e.g., testing with local emulator, using REST API fallback).","suggested_fix":"Extract Cloud Function calls into a CloudFunctionService similar to FirestoreService. Create lib/cloud-function-service.ts with methods like saveJournalEntry(data), softDeleteJournalEntry(id), etc. Use dependency injection pattern like FirestoreService to enable testing. Update useJournal and other hooks to call CloudFunctionService methods instead of direct Firebase SDK calls.","confidence":92,"effort":"E1","fingerprint":"code-quality::hooks\\use-journal.ts::75fad85b","acceptance_tests":["Verify fix applied correctly"]}
{"title":"Missing loading state coordination across contexts","severity":"S2","category":"code-quality","files":["hooks\\use-journal.ts"],"line":428,"why_it_matters":"The useJournal hook combines authLoading and journalLoading into a single loading state (line 428). However, this pattern is not consistent across the app. Some components check auth.loading and profile.loading separately, others combine them. The journal-hub.tsx component only checks loading from useAuth (line 39) which combines all three providers' loading states, potentially showing spinner while only auth is loading but profile/daily-log are ready.","suggested_fix":"Create a useLoadingState() hook that provides granular loading states (authLoading, profileLoading, dataLoading) and computed states (isInitializing, isReady). Update all data-fetching hooks to report their loading state to this central coordinator. This enables components to show progressive loading states (e.g., show partial UI when auth is ready but profile is loading) instead of all-or-nothing spinners.","confidence":87,"effort":"E1","fingerprint":"code-quality::hooks\\use-journal.ts::0fd30492","acceptance_tests":["Verify fix applied correctly"]}
{"title":"Anti-pattern: Firestore queries in components instead of service layer","severity":"S2","category":"code-quality","files":["hooks\\use-journal.ts"],"line":277,"why_it_matters":"The useJournal hook directly constructs Firestore queries using collection(), query(), orderBy(), limit() from firebase/firestore (lines 277-281). While writes go through Cloud Functions for validation, reads bypass the repository pattern entirely. This creates inconsistency: writes use firestore-service.ts but reads use direct SDK calls. It also makes query logic untestable without Firebase emulator.","suggested_fix":"Move all Firestore queries to firestore-service.ts. Add methods like getJournalEntries(userId, limit?), getInventoryEntries(userId, limit?), etc. These methods should return the query logic but still use onSnapshot for real-time updates. Update useJournal to call FirestoreService.getJournalEntries() and pass the result to onSnapshot. This maintains real-time updates while centralizing query construction for testing and maintenance.","confidence":88,"effort":"E1","fingerprint":"code-quality::hooks\\use-journal.ts::80279206","acceptance_tests":["Verify fix applied correctly"]}
{"title":"Performance anti-pattern: Excessive re-renders from context composition","severity":"S1","category":"code-quality","files":["components\\providers\\auth-provider.tsx"],"line":43,"why_it_matters":"The AuthProvider calls onUserChange(currentUser) on every auth state change (line 89), which triggers setCurrentUser in the parent (line 40), which re-renders all three provider layers. When user changes, ProfileProvider and DailyLogProvider both receive new user prop, triggering their useEffect hooks (profile-context.tsx line 91, similar in daily-log-context). This cascading effect causes 3+ re-renders per auth change. Additionally, the user object is passed as prop through three layers of nesting, creating unnecessary prop dependencies.","suggested_fix":"Eliminate the user prop passing. Have ProfileProvider and DailyLogProvider consume user directly from AuthContext using useAuthCore(). Remove onUserChange callback and currentUser state from AuthProvider. This breaks the cascading re-render chain: auth changes trigger one re-render in AuthProvider, then ProfileProvider and DailyLogProvider subscribe and update independently. Reduces auth state changes from 3+ renders to 1 render per context.","confidence":93,"effort":"E1","fingerprint":"code-quality::components\\providers\\auth-provider.tsx::80c7a95a","acceptance_tests":["Verify fix applied correctly"]}
{"title":"Missing input validation on server-generated data","severity":"S1","category":"code-quality","files":["hooks\\use-journal.ts"],"line":172,"why_it_matters":"The processJournalDoc function validates timestamps (lines 177-198) but does not validate other required fields like userId, type, or dateLabel format. It only validates dateLabel format later during grouping (line 219). If a malicious admin or database corruption creates documents with missing userId or invalid type, these entries would pass validation and could cause runtime errors when components assume these fields exist. The validation is also defensive only (skips invalid entries) rather than alerting on data integrity issues.","suggested_fix":"Implement comprehensive Zod schema validation for JournalEntry in processJournalDoc. Import the JournalEntry type schema and validate each document against it. On validation failure, log to Sentry with CRITICAL severity (data integrity issue) and skip the entry. Add a data integrity monitoring dashboard in admin panel to surface these failures. This catches database corruption, manual edits, or migration bugs early.","confidence":89,"effort":"E1","fingerprint":"code-quality::hooks\\use-journal.ts::93453fb4","acceptance_tests":["Verify fix applied correctly"]}
{"title":"API design inconsistency: Mixed return patterns","severity":"S2","category":"code-quality","files":["lib\\firestore-service.ts"],"line":262,"why_it_matters":"FirestoreService methods use inconsistent return patterns. getTodayLog() returns Promise<{log: DailyLog | null, error: unknown}> (line 262), getHistory() returns Promise<{entries: DailyLog[], error: unknown}> (line 301), but saveDailyLog() throws errors instead of returning {success: boolean, error?: Error}. This forces consumers to use try/catch for saves but object destructuring for reads. The use-journal.ts hook wraps Cloud Function calls to return {success, error} objects (line 369), creating yet another pattern.","suggested_fix":"Standardize on a Result<T> type pattern across all service methods. Create lib/types/result.ts with type Result<T> = {success: true, data: T} | {success: false, error: Error}. Update all FirestoreService methods to return Result<T>. This eliminates try/catch patterns, makes error handling explicit in type signatures, and enables consistent error handling across the app. Consider using a library like neverthrow for Result type utilities.","confidence":91,"effort":"E1","fingerprint":"code-quality::lib\\firestore-service.ts::6d2c7787","acceptance_tests":["Verify fix applied correctly"]}
{"title":"Data flow violation: Direct Firestore writes in admin components","severity":"S1","category":"code-quality","files":["components\\admin\\dashboard-tab.tsx"],"line":4,"why_it_matters":"Admin components directly call Cloud Functions using httpsCallable (line 732, 755, 782, 806). While this is acceptable for admin operations, it bypasses the service layer pattern used elsewhere. If Cloud Function interfaces change (parameter names, return types), every admin component must be updated manually. Additionally, there's no shared retry logic, error handling, or rate limiting like there is in firestore-service.ts. This creates maintenance burden and inconsistent error UX.","suggested_fix":"Create lib/admin-service.ts that wraps all admin Cloud Functions with consistent error handling, retry logic, and type safety. Export methods like getStorageStats(), getRateLimitStatus(), clearRateLimit(key), etc. Use the same dependency injection pattern as FirestoreService to enable testing. Update all admin components to use AdminService instead of direct httpsCallable calls. This centralizes admin API calls and enables adding features like caching, request deduplication, or optimistic updates.","confidence":86,"effort":"E1","fingerprint":"code-quality::components\\admin\\dashboard-tab.tsx::4d9ed0a3","acceptance_tests":["Verify fix applied correctly"]}
{"title":"Missing abstraction for real-time subscriptions","severity":"S2","category":"code-quality","files":["hooks\\use-journal.ts"],"line":284,"why_it_matters":"The useJournal hook manually manages Firestore real-time subscriptions with onSnapshot (line 284). It implements loading states, error handling, cleanup, and data processing inline. This pattern is duplicated in profile-context.tsx (line 109) and likely other places. Each implementation has subtle differences in error handling (some log, some set error state, some do both). There's no consistent way to handle reconnection, offline mode, or subscription lifecycle.","suggested_fix":"Create a useFirestoreQuery<T>(query, options) hook that abstracts real-time subscription management. It should handle: loading state, error state, snapshot processing, cleanup, offline detection, and reconnection. Return {data: T[], loading, error, retry}. Update useJournal and ProfileProvider to use this hook. Consider using a library like @tanstack/react-query with Firestore adapter or building a thin wrapper around onSnapshot that handles common patterns.","confidence":84,"effort":"E1","fingerprint":"code-quality::hooks\\use-journal.ts::efeb35af","acceptance_tests":["Verify fix applied correctly"]}
{"title":"Security risk: Client-side filtering of sensitive data","severity":"S0","category":"code-quality","files":["hooks\\use-journal.ts"],"line":174,"why_it_matters":"The processJournalDoc function filters out soft-deleted entries on the client (line 174: if (data.isSoftDeleted === true) return null). This means soft-deleted entries are sent over the network to the client, consuming bandwidth and potentially exposing deleted content in network traffic. While the entries are filtered from the UI, they're visible in browser DevTools Network tab and could be extracted by inspecting the Firebase SDK's local cache. This violates the privacy expectation that deleted content is truly removed.","suggested_fix":"Add a Firestore security rule or composite index to exclude isSoftDeleted entries from query results. Update the query in useJournal (line 277-281) to add .where('isSoftDeleted', '==', false). This ensures deleted entries never leave the server. For backward compatibility during deployment, keep the client-side filter as a safety net until the query filter is confirmed working. Then remove client-side filter in a follow-up PR. Same pattern should be applied to any other user-facing queries.","confidence":97,"effort":"E1","fingerprint":"code-quality::hooks\\use-journal.ts::60817d80","acceptance_tests":["Verify fix applied correctly"]}