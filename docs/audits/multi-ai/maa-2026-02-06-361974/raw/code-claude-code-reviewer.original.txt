{"title":"Any type usage in today-page.tsx snapshot handler","severity":"S2","category":"code-quality","file":"components\\notebook\\pages\\today-page.tsx","line":507,"description":"The docSnap parameter in a callback function uses the 'any' type, which bypasses TypeScript's type safety. This can lead to runtime errors if the snapshot structure changes or contains unexpected data.","recommendation":"Replace 'any' with a proper type annotation. Use 'QueryDocumentSnapshot<DocumentData>' or create a specific type for the snapshot data structure.","confidence":95}
{"title":"Missing error boundary in inventory form","severity":"S2","category":"code-quality","file":"components\\journal\\entry-forms\\inventory-form.tsx","line":38,"description":"The addEntry call only logs errors and shows a toast, but doesn't handle the case where the hook might throw an unhandled promise rejection. Error handling relies solely on try/catch without checking the return value structure.","recommendation":"Add validation to check if addEntry returns an error in its response object: 'const result = await addEntry(...); if (!result.success) { toast.error(result.error); return; }'","confidence":85}
{"title":"Hardcoded bucket name in Cloud Functions","severity":"S2","category":"code-quality","file":"functions\\src\\jobs.ts","line":602,"description":"The storage bucket name 'sonash-app.firebasestorage.app' is hardcoded directly in the cleanup function. This makes the code environment-dependent and harder to test or deploy across different environments.","recommendation":"Extract bucket name to an environment variable or Firebase Functions config parameter: 'const bucketName = defineString(\"STORAGE_BUCKET\"); const bucket = storage.bucket(bucketName.value());'","confidence":92}
{"title":"Inefficient type checking in safeToIso","severity":"S3","category":"code-quality","file":"functions\\src\\admin.ts","line":113,"description":"The safeToIso function uses duck-typing with 'toDate' in value check, but this could match any object with a toDate property, not just Firestore Timestamps. This may lead to unexpected behavior with user-provided objects.","recommendation":"Use instanceof check for FirebaseFirestore.Timestamp: 'if (value instanceof admin.firestore.Timestamp) { return value.toDate().toISOString(); }'","confidence":80}
{"title":"Circular dependency risk in firestore-service","severity":"S2","category":"code-quality","file":"lib\\firestore-service.ts","line":139,"description":"The createFirestoreService factory function accepts dependency overrides but doesn't validate them. If a consumer passes partial overrides that reference the original service, it could create circular dependencies.","recommendation":"Add runtime validation for dependency overrides or use a more explicit dependency injection pattern with clear interfaces. Document which dependencies can be safely overridden for testing.","confidence":75}
{"title":"Missing dependency in useEffect for logs refresh","severity":"S2","category":"code-quality","file":"components\\admin\\logs-tab.tsx","line":418,"description":"The useEffect sets up the initial refresh with a closure capturing the 'active' variable, but the 'refresh' function is in the dependency array. If refresh is recreated, the effect runs again, but the original closure's 'active' flag may already be stale.","recommendation":"Remove 'refresh' from the dependency array and add an ESLint disable comment with justification, or restructure to use useRef for the active flag: 'const activeRef = useRef(true);' and check 'activeRef.current' in callbacks.","confidence":88}
{"title":"Unvalidated URL construction in GCP links","severity":"S1","category":"code-quality","file":"components\\admin\\logs-tab.tsx","line":436,"description":"While there's URL validation with isSafeGcpUrl, the validation happens client-side after receiving data from the backend. If the backend is compromised or returns malicious URLs, they could pass the validation if they match the hostname check.","recommendation":"Add Content Security Policy headers to restrict navigation targets, and consider using a URL allowlist pattern instead of just hostname validation. Also validate URL paths to prevent navigation to unexpected GCP console sections.","confidence":82}
{"title":"Exposed sensitive data in development console logs","severity":"S2","category":"code-quality","file":"lib\\firestore-service.ts","line":224,"description":"In development mode, the code logs sanitized payloads to console, but still includes content length and structure information. This could leak sensitive information in shared development environments or if logs are persisted.","recommendation":"Remove development console.log statements or gate them behind a stricter flag (e.g., DEBUG=true env var). Use the logger utility consistently instead of console methods.","confidence":85}
{"title":"Race condition in parallel file processing","severity":"S2","category":"code-quality","file":"functions\\src\\jobs.ts","line":627,"description":"In cleanupOrphanedStorageFiles, files are processed in parallel batches with shared mutable state (checked, deleted, errors counters). Multiple concurrent calls to the onError callback could create race conditions in counter increments.","recommendation":"Use atomic operations or convert counters to a single state object updated via reduce after Promise.all: 'const results = await Promise.all(...); const totals = results.reduce((acc, r) => ({ deleted: acc.deleted + (r.deleted ? 1 : 0), ... }));'","confidence":78}
{"title":"Missing input sanitization in export logs feature","severity":"S2","category":"code-quality","file":"components\\admin\\logs-tab.tsx","line":309,"description":"The exportLogs function uses deepRedact to sanitize data, but the redaction patterns are regex-based and may not catch all sensitive data formats. Additionally, the function exports up to 2000 rows without rate limiting, which could be abused.","recommendation":"Add server-side export functionality with proper rate limiting and audit logging. Consider using a more robust redaction library or ML-based PII detection. Add user confirmation dialog for large exports.","confidence":88}
{"title":"Unbounded retry loop risk in jobs.ts","severity":"S3","category":"code-quality","file":"functions\\src\\jobs.ts","line":529,"description":"The cleanupOldDailyLogs function uses 'hasMore' flag to continue pagination, but if the query returns exactly 500 items repeatedly without progressing (e.g., orderBy field not properly indexed), it could loop indefinitely.","recommendation":"Add a maximum iteration counter: 'let iterations = 0; const MAX_ITERATIONS = 100; while (hasMore && iterations++ < MAX_ITERATIONS) { ... }' and log a warning if the limit is reached.","confidence":80}
{"title":"Type coercion in generateSearchableText","severity":"S3","category":"code-quality","file":"hooks\\use-journal.ts","line":102,"description":"The function uses String() coercion for all data fields, which could produce misleading search text for non-string types (e.g., '[object Object]' for nested objects, 'undefined' for missing values). This reduces search quality.","recommendation":"Add type guards to handle different data types explicitly: check if value is string/number/boolean before coercion, and recursively flatten nested objects or skip them with a warning.","confidence":75}
{"title":"Firestore timestamp validation inconsistency","severity":"S2","category":"code-quality","file":"hooks\\use-journal.ts","line":178,"description":"The processJournalDoc function validates timestamps using duck-typing (checking for toMillis function), but doesn't validate that toMillis() returns a valid number. Invalid timestamps could still pass validation and cause runtime errors.","recommendation":"Add validation after calling toMillis(): 'const ms = createdAtToMillis(); if (typeof ms !== \"number\" || isNaN(ms) || ms < 0) { return null; }'","confidence":82}
{"title":"Missing cleanup for onSnapshot listener","severity":"S1","category":"code-quality","file":"hooks\\use-journal.ts","line":284,"description":"The useEffect returns unsubscribeSnapshot for cleanup, but if the component unmounts during the async onSnapshot setup (before the listener is established), the cleanup function may not exist yet, causing a potential memory leak.","recommendation":"Track the subscription state: 'let unsubscribe: (() => void) | null = null; const listener = onSnapshot(...); unsubscribe = listener; return () => { unsubscribe?.(); };' to ensure cleanup even if component unmounts early.","confidence":85}
