{"title":"App Check disabled across all Cloud Functions","severity":"S1","category":"security","file":"functions/src/index.ts","line":84,"description":"All Cloud Functions have requireAppCheck set to false with a comment stating 'TEMPORARILY DISABLED - waiting for throttle to clear'. This disables Firebase App Check verification, which is meant to prevent unauthorized callers and bot abuse. Without App Check, any client that can construct valid Firebase requests can invoke these functions, bypassing a critical defense-in-depth layer. The same pattern is repeated for saveDailyLog (line 84), saveJournalEntry (line 170), softDeleteJournalEntry (line 269), saveInventoryEntry (line 363), and migrateAnonymousUserData (line 506-511). While reCAPTCHA provides some compensating control, App Check was designed to be the primary attestation mechanism.","recommendation":"Re-enable App Check verification by setting requireAppCheck to true on all Cloud Functions. If the reCAPTCHA Enterprise throttle issue has been resolved, remove the 'TEMPORARILY DISABLED' comment and restore the App Check enforcement. Consider adding a monitoring alert so this does not remain disabled indefinitely.","confidence":95}
{"title":"Hardcoded reCAPTCHA site key in server-side code","severity":"S2","category":"security","file":"functions/src/recaptcha-verify.ts","line":66,"description":"The reCAPTCHA Enterprise site key is hardcoded as a fallback value on line 66: '6LdeazosAAAAAMDNCh1hTUDKh_UeS6xWY1-85B2O'. While site keys are considered public (they are embedded in frontend HTML), hardcoding them in server-side source code is an anti-pattern. If the key needs to be rotated or environment-specific keys are needed (staging vs production), this fallback could cause the wrong key to be used. Additionally, the code uses process.env for configuration in Cloud Functions, which the project's own security-check.js (SEC-006) flags as a concern -- defineString() from firebase-functions/params is preferred.","recommendation":"Remove the hardcoded fallback site key. Use defineString() from firebase-functions/params to configure RECAPTCHA_SITE_KEY as a deployment parameter. Ensure the key is properly configured in each deployment environment (production, staging, emulator).","confidence":80}
{"title":"CI workflow script injection via unsanitized file names","severity":"S2","category":"security","file":".github/workflows/ci.yml","line":64,"description":"Line 64 uses direct interpolation of the changed-files output into a shell command: 'node scripts/check-pattern-compliance.js -- ${{ steps.changed-files.outputs.all_changed_files }}'. While the double-dash prevents flag injection, filenames from pull requests are attacker-controlled (external contributors can create branches/files with arbitrary names). A file named with shell metacharacters (e.g., containing backticks, $(), or semicolons) could lead to command injection in the shell context. The tj-actions/changed-files action is also pinned to a SHA in the CI workflow (good), but the docs-lint.yml and auto-label-review-tier.yml workflows use unpinned 'v46' tags (less secure).","recommendation":"Quote the variable expansion: wrap it in double quotes as '\"${{ steps.changed-files.outputs.all_changed_files }}\"'. Better yet, pass files via an environment variable and use proper quoting, or pipe from stdin. Pin all tj-actions/changed-files references to a specific SHA commit hash rather than a version tag to prevent supply chain attacks.","confidence":75}
{"title":"Missing Content-Security-Policy header","severity":"S2","category":"security","file":"firebase.json","line":29,"description":"The firebase.json hosting configuration sets several security headers (X-Frame-Options, X-Content-Type-Options, HSTS, Referrer-Policy, Permissions-Policy) but is missing a Content-Security-Policy (CSP) header. Without CSP, the application is more vulnerable to XSS attacks because the browser has no policy restricting which scripts, styles, and other resources can be loaded. This is especially important for a health/recovery application that handles sensitive personal data.","recommendation":"Add a Content-Security-Policy header to the '**' source block in firebase.json. Start with a restrictive policy that allows only same-origin resources and explicitly whitelists Google/Firebase/reCAPTCHA domains. Example: \"default-src 'self'; script-src 'self' https://www.google.com https://www.gstatic.com; connect-src 'self' https://*.googleapis.com https://*.firebaseio.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'\". Test thoroughly before deploying to production.","confidence":90}
{"title":"User profile document allows direct client writes without rate limiting","severity":"S2","category":"security","file":"firestore.rules","line":26,"description":"The Firestore security rule at line 26 allows any authenticated user to read AND write their own profile document at /users/{userId} with 'allow read, write: if isOwner(userId)'. Unlike journal entries, daily logs, and inventory entries (which are routed through Cloud Functions with rate limiting, Zod validation, and App Check), user profile writes bypass all server-side security controls. A malicious client could: (1) rapidly spam profile updates without rate limiting, (2) write arbitrary fields to their profile document (no schema validation), (3) set fields like 'isAdmin', 'privilegeType', or other sensitive fields directly. The client-side lib/db/users.ts uses Zod validation, but this can be trivially bypassed with browser dev tools or a custom Firestore client.","recommendation":"Route user profile updates through a Cloud Function with the same security wrapper (withSecurityChecks) used for other operations. Add server-side Zod validation to restrict which fields can be written. At minimum, add Firestore rules to prevent clients from writing sensitive fields like 'isAdmin', 'privilegeType', 'disabled', 'isSoftDeleted', 'migratedFrom'. Example rule: 'allow write: if isOwner(userId) && !request.resource.data.diff(resource.data).affectedKeys().hasAny([\"isAdmin\", \"privilegeType\", \"disabled\", \"isSoftDeleted\"])'.","confidence":92}
{"title":"reCAPTCHA token made optional for data migration function","severity":"S2","category":"security","file":"functions/src/index.ts","line":516,"description":"The migrateAnonymousUserData function (lines 514-530) explicitly makes reCAPTCHA verification optional. When no token is provided, the function logs a warning but continues processing: 'Continue without reCAPTCHA protection - rely on other security layers'. Combined with App Check being disabled (finding #1), this means the migration function relies solely on Firebase authentication and rate limiting. Since anonymous accounts are free to create, an attacker could create many anonymous accounts and attempt migrations to enumerate or probe target UIDs. The rate limit of 5 requests per 5 minutes per user provides some protection, but the user creating the requests is the target user who initiated the migration.","recommendation":"Make reCAPTCHA verification mandatory for the migration function. Remove the fallback path that allows processing without a token. If network blocking is a genuine concern for some users, consider implementing an alternative verification mechanism rather than skipping verification entirely.","confidence":82}
{"title":"Unpinned GitHub Actions in multiple workflows","severity":"S3","category":"security","file":".github/workflows/auto-label-review-tier.yml","line":29,"description":"Multiple GitHub Actions workflows use unpinned version tags instead of SHA-pinned references. The auto-label-review-tier.yml uses 'tj-actions/changed-files@v46' (line 29), 'actions/checkout@v4' (line 18), 'actions/setup-node@v4' (line 22), and 'actions/github-script@v7' (lines 79, 103). Similarly, docs-lint.yml uses 'tj-actions/changed-files@v46' (line 36). The ci.yml correctly pins tj-actions/changed-files to a SHA (line 45) with a comment referencing CVE-2025-30066, but other workflows do not follow this pattern. Unpinned tags can be force-pushed to point to malicious code, enabling supply chain attacks.","recommendation":"Pin all third-party GitHub Actions to specific commit SHAs across all workflow files. The ci.yml already demonstrates the correct pattern: 'uses: tj-actions/changed-files@26a38635fc1173cc5820336ce97be6188d0de9f5 # v46.0.2'. Apply this same approach to all actions/checkout, actions/setup-node, actions/github-script, and tj-actions/changed-files references in auto-label-review-tier.yml, docs-lint.yml, review-check.yml, and deploy-firebase.yml.","confidence":88}
{"title":"Admin function input validation inconsistency - meetingId and homeId not validated","severity":"S3","category":"security","file":"functions/src/admin.ts","line":768,"description":"The adminDeleteMeeting function (line 768) and adminDeleteSoberLiving function (line 862) only check if meetingId/homeId is truthy but do not validate the format or length of these IDs. A malicious admin could pass excessively long strings or strings with special characters as document IDs. While Firestore handles most edge cases, very long document IDs (>1500 bytes) would cause Firestore errors, and the raw ID values are included in security log metadata without sanitization (line 779: 'metadata: { meetingId }'). In contrast, the soft-delete functions properly validate UIDs with Zod schemas (line 1513-1516). The adminSaveMeeting function validates the meeting data via meetingSchema.parse() but uses the client-provided 'validated.id' directly as the document ID without format validation.","recommendation":"Add Zod schema validation for document IDs in all admin delete and save functions. Apply a consistent pattern: validate that IDs are non-empty strings matching the expected Firestore auto-ID format (alphanumeric, 20 characters). Apply the same pattern used in softDeleteSchema and undeleteSchema to all admin functions.","confidence":78}
{"title":"Firestore security rules missing for security_logs and admin_jobs collections","severity":"S3","category":"security","file":"firestore.rules","line":151,"description":"The Firestore security rules do not include explicit rules for the security_logs collection (written by Cloud Functions at security-logger.ts:324), admin_jobs collection (written by jobs.ts), or admin_logs collection (read by admin.ts:1098). Firestore's default behavior when no rule matches is to deny access, which means these collections are implicitly denied for client access. However, relying on implicit deny is a security anti-pattern because: (1) it provides no documentation of intent, (2) a future rule change with a wildcard match could accidentally expose these collections, (3) the dev/{document=**} wildcard rule (line 138) demonstrates that broad matching rules exist in this ruleset.","recommendation":"Add explicit deny rules for internal collections to document intent and prevent accidental exposure: 'match /security_logs/{docId} { allow read, write: if false; }', 'match /admin_jobs/{docId} { allow read, write: if false; }', 'match /admin_logs/{docId} { allow read, write: if false; }'. This makes the security posture explicit and resistant to future wildcard additions.","confidence":72}
{"title":"User ID hash truncation reduces collision resistance for privacy-sensitive logs","severity":"S3","category":"security","file":"functions/src/security-logger.ts","line":74,"description":"The hashUserId function (lines 70-77) truncates SHA-256 hashes to 12 hex characters (48 bits of entropy). While the comment states this provides '~281 trillion combinations', this level of collision resistance may be insufficient for privacy guarantees. With a user base of N users, the birthday paradox means collisions become likely around sqrt(2^48) = ~16.7 million users. More importantly, because Firebase UIDs have a known format (28 alphanumeric characters), and the hash has no salt, an attacker with access to security logs could build a rainbow table by hashing all possible Firebase UIDs to find the original UID from a 12-character hash. Without a salt, the hash is deterministic and reversible for known-format inputs.","recommendation":"Add a secret salt to the hashUserId function that is stored in GCP Secret Manager (not in source code). This prevents rainbow table attacks even if the hash algorithm and truncation length are known. Consider using HMAC-SHA256 with a secret key instead of plain SHA-256. If increasing hash length is acceptable, use 16 or 20 characters to improve collision resistance.","confidence":70}
{"title":"Service account credentials written to disk in CI deploy workflow","severity":"S3","category":"security","file":".github/workflows/deploy-firebase.yml","line":58,"description":"The deploy-firebase.yml workflow writes the FIREBASE_SERVICE_ACCOUNT secret to a file on disk (line 58: 'echo ... > $HOME/gcloud-key.json'), sets file permissions to 600, and later cleans up with 'rm -f'. While the cleanup step uses 'if: always()' to ensure it runs even on failure, writing credentials to disk creates a window of vulnerability. If the runner is compromised or the workflow fails between write and cleanup, the credentials could be exfiltrated. Additionally, the echo command may be captured in runner process logs.","recommendation":"Use the google-github-actions/auth action with Workload Identity Federation instead of service account key files. This eliminates the need to store or write any credentials to disk. If key files must be used, consider using a tmpfs/memory-backed filesystem and ensure the cleanup step cannot be skipped. Also consider using 'echo ... | gcloud auth activate-service-account --key-file=-' to pipe directly without writing to disk.","confidence":68}
