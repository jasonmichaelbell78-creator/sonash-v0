{"title":"App Check disabled across all Cloud Functions","severity":"S1","category":"security","file":"functions\\src\\index.ts","line":84,"description":"Every Cloud Function (saveDailyLog, saveJournalEntry, softDeleteJournalEntry, saveInventoryEntry, migrateAnonymousUserData) has requireAppCheck set to false with the comment 'TEMPORARILY DISABLED - waiting for throttle to clear'. App Check is the primary defense against automated abuse and API scraping from unauthorized clients. Without it, any HTTP client can call these functions if they obtain a valid Firebase auth token. The commented-out initialization in lib/firebase.ts (lines 57-90) confirms the client side is also disabled. This has persisted since at least December 2025 based on the comments, meaning this 'temporary' disable has been in effect for over a month. OWASP A07:2021 - Identification and Authentication Failures.","recommendation":"Re-enable App Check on all Cloud Functions by setting requireAppCheck to true in the withSecurityChecks options. Uncomment and configure the App Check initialization in lib/firebase.ts. If reCAPTCHA Enterprise throttling is an ongoing concern, consider using the App Attest or Play Integrity providers as alternatives. Implement a timeline to ensure temporary disables do not persist indefinitely.","confidence":95}
{"title":"Hardcoded reCAPTCHA site key in server-side verification","severity":"S2","category":"security","file":"functions\\src\\recaptcha-verify.ts","line":66,"description":"The reCAPTCHA site key has a hardcoded fallback value on line 66: process.env.RECAPTCHA_SITE_KEY || '6LdeazosAAAAAMDNCh1hTUDKh_UeS6xWY1-85B2O'. This embeds a secret directly in source code that is committed to version control. While reCAPTCHA site keys are semi-public (they appear in client HTML), hardcoding them server-side creates a configuration management problem: if the key needs to be rotated, a code deployment is required instead of just updating an environment variable. More importantly, it masks misconfiguration -- if the environment variable is missing, the function silently falls back instead of failing loudly. OWASP A05:2021 - Security Misconfiguration.","recommendation":"Remove the hardcoded fallback and require the environment variable. If RECAPTCHA_SITE_KEY is not set, throw a configuration error early (fail-fast). Store the key in Firebase Functions config or GCP Secret Manager. Add a deployment check that verifies all required environment variables are present.","confidence":85}
{"title":"Migration function skips reCAPTCHA when token is missing","severity":"S2","category":"security","file":"functions\\src\\index.ts","line":516,"description":"The migrateAnonymousUserData function (lines 514-530) makes reCAPTCHA verification optional. When the token is missing or empty, it logs a warning but continues processing the request without bot protection. This is in contrast to the withSecurityChecks wrapper (security-wrapper.ts lines 186-212), which properly rejects requests without tokens (except in emulator mode). The migration function handles its own security checks instead of using withSecurityChecks, creating inconsistency. Combined with App Check being disabled, this function has significantly weaker bot protection. OWASP A07:2021 - Identification and Authentication Failures.","recommendation":"Refactor migrateAnonymousUserData to use the withSecurityChecks wrapper for consistent security enforcement. If reCAPTCHA must be optional for certain edge cases (network blocking), implement compensating controls such as stricter rate limiting or requiring additional verification for the migration operation.","confidence":82}
{"title":"User profile document allows unrestricted client-side writes","severity":"S2","category":"security","file":"firestore.rules","line":26,"description":"The Firestore security rule at line 26 grants full read/write access to the user profile document: 'allow read, write: if isOwner(userId)'. Unlike journal, daily_logs, and inventoryEntries collections which block client writes and require Cloud Functions, the user profile has no schema validation, no field restriction, and no write-through Cloud Function. A user could add arbitrary fields (e.g., 'admin: true', 'privilegeType: premium') to their own profile document directly from the client. While Firebase custom claims are the actual admin check, any application logic that reads profile fields for authorization decisions could be bypassed. The auth-context.tsx file (line 103) already performs a direct updateDoc to the user profile. OWASP A01:2021 - Broken Access Control.","recommendation":"Restrict user profile writes with field-level validation in Firestore rules. Only allow writes to specific approved fields (nickname, soberDate, theme preferences, lastActive). Alternatively, route profile updates through a Cloud Function with Zod validation, matching the pattern used for all other collections. Example rule: allow write: if isOwner(userId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['nickname', 'soberDate', 'lastActive', 'theme'])","confidence":88}
{"title":"Missing Content-Security-Policy header","severity":"S2","category":"security","file":"firebase.json","line":29,"description":"The firebase.json hosting configuration includes several good security headers (X-Frame-Options, X-Content-Type-Options, HSTS, Referrer-Policy, Permissions-Policy) but lacks a Content-Security-Policy (CSP) header. CSP is the primary defense against XSS attacks, preventing execution of injected scripts, loading of unauthorized resources, and other injection-based attacks. The application loads external scripts (reCAPTCHA from google.com, Sentry) which would need to be allowlisted, but the absence of CSP means any injected script would execute without restriction. OWASP A03:2021 - Injection.","recommendation":"Add a Content-Security-Policy header to the firebase.json headers configuration. Start with a report-only policy to identify violations without breaking functionality: Content-Security-Policy-Report-Only: default-src 'self'; script-src 'self' https://www.google.com/recaptcha/ https://www.gstatic.com/recaptcha/ https://*.sentry.io; connect-src 'self' https://*.googleapis.com https://*.firebaseio.com https://*.sentry.io; style-src 'self' 'unsafe-inline'; img-src 'self' data:; frame-src https://www.google.com/recaptcha/. After validating no legitimate resources are blocked, switch to enforcing mode.","confidence":92}
{"title":"Journal and inventory entry data field accepts arbitrary objects without depth or size limits","severity":"S2","category":"security","file":"functions\\src\\schemas.ts","line":32,"description":"The journalEntrySchema (line 32) and inventoryEntrySchema (line 51) both use z.record(z.string(), z.unknown()) for the 'data' field. This accepts any JSON object of any depth and any size without restriction. While the content field in dailyLogSchema has a 50KB max, the data field in journal and inventory entries has no size constraint. A malicious user could send deeply nested objects (prototype pollution risk if consumed carelessly) or very large payloads that consume Firestore document size limits (1MB) and bandwidth. The saveInventoryEntry function does implement a sanitizeData helper with MAX_DEPTH=50 and cycle detection, but saveJournalEntry stores entryData directly without sanitization (line 198 of index.ts). OWASP A03:2021 - Injection.","recommendation":"Add size and depth constraints to the data field in Zod schemas. Use z.record(z.string(), z.unknown()).refine(data => JSON.stringify(data).length < 100000, 'Data too large') for size limits. Apply the sanitizeData helper from saveInventoryEntry consistently to saveJournalEntry as well. Consider defining stricter per-type schemas for the data field instead of accepting arbitrary objects.","confidence":80}
{"title":"No middleware.ts for server-side route protection","severity":"S3","category":"security","file":"next.config.mjs","line":13,"description":"The application uses Next.js with output: 'export' (static export) and has no middleware.ts file. While this is a conscious architectural decision (Firebase Hosting serves static files), it means there is no server-side route protection, no server-side session validation, and no ability to redirect unauthenticated users before page load. All authentication checks happen client-side in the AuthProvider component. For a statically exported SPA this is the expected pattern, but it means the HTML/JS for all routes (including admin pages) is delivered to every user, and route protection relies entirely on client-side JavaScript. An attacker can view the full admin UI code even without admin privileges (though data access is still protected by Cloud Functions).","recommendation":"This is acceptable for the current architecture (static SPA + Firebase), but ensure that no sensitive data is embedded in the static build output. Verify that admin page components do not contain hardcoded secrets or sensitive configuration. Consider using Next.js server-side rendering for admin routes if the application migrates away from static export in the future.","confidence":70}
{"title":"Firestore security_logs collection missing from security rules","severity":"S2","category":"security","file":"firestore.rules","line":1,"description":"The security-logger.ts (line 324) writes security events to a 'security_logs' collection, and the admin functions read from it (adminGetLogs). However, the firestore.rules file has no explicit rule for the security_logs collection. In Firestore, any collection without a matching rule at the root level falls under no default rule, which means access is denied by default. This is actually secure by default for client access, but it also means there is no documented access policy. More critically, the admin_logs and admin_jobs collections referenced in the admin dashboard stats (admin.ts lines 1097, 1123) also lack explicit rules. While Cloud Functions using Admin SDK bypass rules, the lack of explicit deny rules means if a future developer adds a client-side read path, it would silently fail without a clear explanation.","recommendation":"Add explicit deny rules for internal collections to document access policy and prevent accidental exposure. Add: match /security_logs/{logId} { allow read, write: if false; } and similarly for admin_logs and admin_jobs. This makes the access policy explicit even though the default behavior is already secure.","confidence":72}
{"title":"Daily quotes collection allows direct admin client writes bypassing Cloud Functions","severity":"S3","category":"security","file":"firestore.rules","line":104,"description":"The daily_quotes collection (line 104) allows direct writes from users with the admin custom claim: allow write: if isAdmin(). This is inconsistent with the security pattern used for other admin-managed collections (meetings, sober_living) which use 'allow write: if false' and require writes through Cloud Functions (adminSaveMeeting, adminDeleteMeeting, etc.). Direct client writes bypass Cloud Function protections including rate limiting, Zod schema validation, and structured audit logging. The same inconsistency exists for glossary, slogans, quick_links, and prayers collections (lines 109-131).","recommendation":"Change the write rules for daily_quotes, glossary, slogans, quick_links, and prayers to 'allow write: if false' and route all writes through admin Cloud Functions with proper validation and audit logging. This ensures consistent defense-in-depth across all admin-writable collections.","confidence":78}
{"title":"Rate limiter document ID uses unsanitized user input","severity":"S3","category":"security","file":"functions\\src\\firestore-rate-limiter.ts","line":82,"description":"The Firestore rate limiter constructs document IDs by concatenating user-provided values: const docId = `${key}_${operation}` (line 82), where key includes the userId or IP address. While Firestore document IDs have a 1500-byte limit and accept most UTF-8 characters, the operation parameter comes from hardcoded function names. However, the consumeByIp method uses the raw (normalized) IP address as part of the key. IPv6 addresses can contain colons and other characters. While Firestore handles these characters, extremely long or malformed IP strings could create unexpectedly named documents. The userId is validated by Firebase Auth (always alphanumeric), so the user-based path is safe.","recommendation":"Validate or hash the IP address before using it in the document ID. Apply the same FIREBASE_UID_PATTERN validation used in admin.ts, or hash the IP with SHA-256 before constructing the key. This prevents edge cases with unusual IP formats and also avoids storing raw IP addresses in Firestore document IDs (PII concern).","confidence":60}
{"title":"Migration function does not verify source anonymous user is actually anonymous","severity":"S2","category":"security","file":"functions\\src\\index.ts","line":565,"description":"The migrateAnonymousUserData function checks that the anonymous user document exists in Firestore (line 565-569) but does not verify via Firebase Auth that the source account (anonymousUid) is actually an anonymous account. A malicious user who knows another user's UID could potentially trigger a migration from a non-anonymous account, copying that user's journal entries, daily logs, and inventory entries into their own account. The only authorization check is that the caller must be the target user (line 550), not that they have any relationship to the source. While the rate limit (5 per 5 minutes) provides some protection, a determined attacker could exfiltrate data from multiple accounts over time. OWASP A01:2021 - Broken Access Control.","recommendation":"Add a Firebase Auth verification step to confirm the source user is actually anonymous: const sourceAuthUser = await admin.auth().getUser(validatedData.anonymousUid); if (!sourceAuthUser.providerData || sourceAuthUser.providerData.length > 0) { throw new HttpsError('permission-denied', 'Source account is not anonymous'); }. Additionally, consider verifying that the caller was recently authenticated as the anonymous user (e.g., by checking if the anonymous UID matches a recently linked account).","confidence":85}
{"title":"Error message in migration validation leaks Zod schema details to client","severity":"S3","category":"security","file":"functions\\src\\index.ts","line":545,"description":"The migrateAnonymousUserData function (line 545) throws a validation error that includes the raw Zod error messages: throw new HttpsError('invalid-argument', 'Validation failed: ' + errorMessages). This contrasts with the withSecurityChecks wrapper (security-wrapper.ts line 258) which returns a generic 'Invalid input data' message. The detailed Zod messages could reveal internal schema structure (field names, validation rules, expected formats) to an attacker, aiding in crafting bypass payloads. OWASP A04:2021 - Insecure Design.","recommendation":"Replace the detailed validation error with a generic message: throw new HttpsError('invalid-argument', 'Invalid migration request. Please check your input.'). Log the detailed Zod errors server-side only for debugging purposes.","confidence":88}
{"title":"Client-side logger may leak sensitive data in development console","severity":"S3","category":"security","file":"lib\\firestore-service.ts","line":229,"description":"In development mode (line 224-230), the firestore-service.ts logs the full payload to console with console.log, masking only the content field. Other potentially sensitive fields like userId, date, mood, cravings, and used status are logged in plaintext. While this is development-only, developers may share console output in bug reports or screenshots. The userId in particular should be masked consistently. Additionally, the logger.ts redactValue function (line 63) partially redacts strings that look like sensitive IDs (showing first 4 chars), which may be enough for an attacker to correlate users if the logs are exposed.","recommendation":"Apply the maskIdentifier helper to the userId field in development debug logging. Consider removing detailed payload logging entirely and relying on Cloud Function server-side logs for debugging. Ensure the development logging is gated behind an additional opt-in flag (e.g., NEXT_PUBLIC_DEBUG_LOGGING=true) rather than automatically enabled for all development builds.","confidence":65}
